//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let __eslint_react_ast = require("@eslint-react/ast");
__eslint_react_ast = __toESM(__eslint_react_ast);
let __eslint_react_eff = require("@eslint-react/eff");
__eslint_react_eff = __toESM(__eslint_react_eff);
let __eslint_react_kit = require("@eslint-react/kit");
__eslint_react_kit = __toESM(__eslint_react_kit);
let __eslint_react_shared = require("@eslint-react/shared");
__eslint_react_shared = __toESM(__eslint_react_shared);
let __typescript_eslint_types = require("@typescript-eslint/types");
__typescript_eslint_types = __toESM(__typescript_eslint_types);
let __eslint_react_var = require("@eslint-react/var");
__eslint_react_var = __toESM(__eslint_react_var);
let ts_pattern = require("ts-pattern");
ts_pattern = __toESM(ts_pattern);
let birecord = require("birecord");
birecord = __toESM(birecord);

//#region src/utils/get-instance-id.ts
/** @internal */
function getInstanceId(node, prev) {
	switch (true) {
		case node.type === __typescript_eslint_types.AST_NODE_TYPES.VariableDeclarator && node.init === prev: return node.id;
		case node.type === __typescript_eslint_types.AST_NODE_TYPES.AssignmentExpression && node.right === prev: return node.left;
		case node.type === __typescript_eslint_types.AST_NODE_TYPES.PropertyDefinition && node.value === prev: return node.key;
		case node.type === __typescript_eslint_types.AST_NODE_TYPES.BlockStatement || node.type === __typescript_eslint_types.AST_NODE_TYPES.Program || node.parent === node: return __eslint_react_eff.unit;
		default: return getInstanceId(node.parent, node);
	}
}

//#endregion
//#region src/utils/is-from-react.ts
/**
* Get the arguments of a require expression
* @param node The node to match
* @returns The require expression arguments or undefined if the node is not a require expression
*/
function getRequireExpressionArguments(node) {
	return (0, ts_pattern.match)(node).with({
		type: __typescript_eslint_types.AST_NODE_TYPES.CallExpression,
		arguments: ts_pattern.P.select(),
		callee: {
			type: __typescript_eslint_types.AST_NODE_TYPES.Identifier,
			name: "require"
		}
	}, __eslint_react_eff.identity).with({
		type: __typescript_eslint_types.AST_NODE_TYPES.MemberExpression,
		object: ts_pattern.P.select()
	}, getRequireExpressionArguments).otherwise(() => null);
}
/**
* Check if an identifier name is initialized from react
* @param name The top-level identifier's name
* @param importSource The import source to check against
* @param initialScope Initial scope to search for the identifier
* @returns Whether the identifier name is initialized from react
* @internal
*/
function isInitializedFromReact(name, importSource, initialScope) {
	if (name.toLowerCase() === "react") return true;
	const latestDef = __eslint_react_var.findVariable(name, initialScope)?.defs.at(-1);
	if (latestDef == null) return false;
	const { node, parent } = latestDef;
	if (node.type === __typescript_eslint_types.AST_NODE_TYPES.VariableDeclarator && node.init != null) {
		const { init } = node;
		if (init.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && init.object.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier) return isInitializedFromReact(init.object.name, importSource, initialScope);
		if (init.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier) return isInitializedFromReact(init.name, importSource, initialScope);
		const arg0 = getRequireExpressionArguments(init)?.[0];
		if (arg0 == null || !__eslint_react_ast.isLiteral(arg0, "string")) return false;
		return arg0.value === importSource || arg0.value.startsWith(`${importSource}/`);
	}
	return parent?.type === __typescript_eslint_types.AST_NODE_TYPES.ImportDeclaration && parent.source.value === importSource;
}

//#endregion
//#region src/utils/is-instance-id-equal.ts
/** @internal */
function isInstanceIdEqual(context, a, b) {
	return __eslint_react_ast.isNodeEqual(a, b) || __eslint_react_var.isNodeValueEqual(a, b, [context.sourceCode.getScope(a), context.sourceCode.getScope(b)]);
}

//#endregion
//#region src/utils/is-react-api.ts
function isReactAPI(api) {
	const func = (context, node) => {
		if (node == null) return false;
		const getText = (n) => context.sourceCode.getText(n);
		const name = __eslint_react_ast.toString(node, getText);
		if (name === api) return true;
		if (name.substring(name.indexOf(".") + 1) === api) return true;
		return false;
	};
	return (0, __eslint_react_eff.dual)(2, func);
}
function isReactAPICall(api) {
	const func = (context, node) => {
		if (node == null) return false;
		if (node.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return false;
		return isReactAPI(api)(context, node.callee);
	};
	return (0, __eslint_react_eff.dual)(2, func);
}
const isCaptureOwnerStack = isReactAPI("captureOwnerStack");
const isChildrenCount = isReactAPI("Children.count");
const isChildrenForEach = isReactAPI("Children.forEach");
const isChildrenMap = isReactAPI("Children.map");
const isChildrenOnly = isReactAPI("Children.only");
const isChildrenToArray = isReactAPI("Children.toArray");
const isCloneElement = isReactAPI("cloneElement");
const isCreateContext = isReactAPI("createContext");
const isCreateElement = isReactAPI("createElement");
const isCreateRef = isReactAPI("createRef");
const isForwardRef = isReactAPI("forwardRef");
const isMemo = isReactAPI("memo");
const isLazy = isReactAPI("lazy");
const isCaptureOwnerStackCall = isReactAPICall("captureOwnerStack");
const isChildrenCountCall = isReactAPICall("Children.count");
const isChildrenForEachCall = isReactAPICall("Children.forEach");
const isChildrenMapCall = isReactAPICall("Children.map");
const isChildrenOnlyCall = isReactAPICall("Children.only");
const isChildrenToArrayCall = isReactAPICall("Children.toArray");
const isCloneElementCall = isReactAPICall("cloneElement");
const isCreateContextCall = isReactAPICall("createContext");
const isCreateElementCall = isReactAPICall("createElement");
const isCreateRefCall = isReactAPICall("createRef");
const isForwardRefCall = isReactAPICall("forwardRef");
const isMemoCall = isReactAPICall("memo");
const isLazyCall = isReactAPICall("lazy");

//#endregion
//#region src/hook/hook-name.ts
/**
* Catch all identifiers that begin with "use" followed by an uppercase Latin
* character to exclude identifiers like "user".
* @param name The name of the identifier to check.
* @see https://github.com/facebook/react/blob/1d6c8168db1d82713202e842df3167787ffa00ed/packages/eslint-plugin-react-hooks/src/rules/RulesOfHooks.ts#L16
*/
function isReactHookName(name) {
	return name === "use" || /^use[A-Z0-9]/.test(name);
}

//#endregion
//#region src/hook/hook-is.ts
function isReactHook(node) {
	if (node == null) return false;
	const id = __eslint_react_ast.getFunctionId(node);
	return id?.name != null && isReactHookName(id.name);
}
/**
* Check if the given node is a React Hook call by its name.
* @param node The node to check.
* @returns `true` if the node is a React Hook call, `false` otherwise.
*/
function isReactHookCall(node) {
	if (node == null) return false;
	if (node.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return false;
	if (node.callee.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier) return isReactHookName(node.callee.name);
	if (node.callee.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression) return node.callee.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && isReactHookName(node.callee.property.name);
	return false;
}
function isReactHookCallWithName(context, node) {
	if (node == null || node.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return __eslint_react_eff.constFalse;
	const { importSource = __eslint_react_shared.DEFAULT_ESLINT_REACT_SETTINGS.importSource, skipImportCheck = true } = (0, __eslint_react_shared.coerceSettings)(context.settings);
	const initialScope = context.sourceCode.getScope(node);
	return (name) => {
		switch (true) {
			case node.callee.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.callee.name === name: return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
			case node.callee.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object: return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
			default: return false;
		}
	};
}
function isReactHookCallWithNameLoose(node) {
	if (node == null || node.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return __eslint_react_eff.constFalse;
	return (name) => {
		switch (node.callee.type) {
			case __typescript_eslint_types.AST_NODE_TYPES.Identifier: return node.callee.name === name;
			case __typescript_eslint_types.AST_NODE_TYPES.MemberExpression: return node.callee.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.callee.property.name === name;
			default: return false;
		}
	};
}
function isReactHookCallWithNameAlias(context, name, alias = []) {
	const { importSource = __eslint_react_shared.DEFAULT_ESLINT_REACT_SETTINGS.importSource, skipImportCheck = true } = (0, __eslint_react_shared.coerceSettings)(context.settings);
	return (node) => {
		const initialScope = context.sourceCode.getScope(node);
		switch (true) {
			case node.callee.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.callee.name === name: return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
			case node.callee.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object: return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
			default: return alias.some(isReactHookCallWithNameLoose(node));
		}
	};
}
function isUseEffectCallLoose(node) {
	if (node == null) return false;
	if (node.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return false;
	switch (node.callee.type) {
		case __typescript_eslint_types.AST_NODE_TYPES.Identifier: return /^use\w*Effect$/u.test(node.callee.name);
		case __typescript_eslint_types.AST_NODE_TYPES.MemberExpression: return node.callee.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && /^use\w*Effect$/u.test(node.callee.property.name);
		default: return false;
	}
}
const isUseCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("use");
const isUseActionStateCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useActionState");
const isUseCallbackCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useCallback");
const isUseContextCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useContext");
const isUseDebugValueCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useDebugValue");
const isUseDeferredValueCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useDeferredValue");
const isUseEffectCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useEffect");
const isUseFormStatusCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useFormStatus");
const isUseIdCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useId");
const isUseImperativeHandleCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useImperativeHandle");
const isUseInsertionEffectCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useInsertionEffect");
const isUseLayoutEffectCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useLayoutEffect");
const isUseMemoCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useMemo");
const isUseOptimisticCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useOptimistic");
const isUseReducerCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useReducer");
const isUseRefCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useRef");
const isUseStateCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useState");
const isUseSyncExternalStoreCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useSyncExternalStore");
const isUseTransitionCall = (0, __eslint_react_eff.flip)(isReactHookCallWithName)("useTransition");

//#endregion
//#region src/hook/hook-collector.ts
function useHookCollector() {
	const hooks = /* @__PURE__ */ new Map();
	const functionEntries = [];
	const onFunctionEnter = (node) => {
		const id = __eslint_react_ast.getFunctionId(node);
		const key = (0, __eslint_react_shared.getId)();
		const name = id?.name;
		if (name != null && isReactHookName(name)) {
			functionEntries.push({
				key,
				node,
				isHook: true
			});
			hooks.set(key, {
				id,
				key,
				kind: "function",
				name,
				node,
				flag: 0n,
				hint: 0n,
				hookCalls: []
			});
			return;
		}
		functionEntries.push({
			key,
			node,
			isHook: false
		});
	};
	const onFunctionExit = () => {
		functionEntries.pop();
	};
	return {
		ctx: { getAllHooks(node) {
			return hooks;
		} },
		listeners: {
			":function[type]": onFunctionEnter,
			":function[type]:exit": onFunctionExit,
			"CallExpression[type]"(node) {
				if (!isReactHookCall(node)) return;
				const fEntry = functionEntries.at(-1);
				if (fEntry?.key == null) return;
				const hook = hooks.get(fEntry.key);
				if (hook == null) return;
				hook.hookCalls.push(node);
			}
		}
	};
}

//#endregion
//#region src/hook/hook-hierarchy.ts
function isFunctionOfUseEffectSetup(node) {
	if (node == null) return false;
	return node.parent?.type === __typescript_eslint_types.AST_NODE_TYPES.CallExpression && node.parent.arguments.at(0) === node && isUseEffectCallLoose(node.parent);
}
function isFunctionOfUseEffectCleanup(node) {
	if (node == null) return false;
	const pReturn = __eslint_react_ast.findParentNode(node, __eslint_react_ast.is(__typescript_eslint_types.AST_NODE_TYPES.ReturnStatement));
	const pFunction = __eslint_react_ast.findParentNode(node, __eslint_react_ast.isFunction);
	const pFunctionOfReturn = __eslint_react_ast.findParentNode(pReturn, __eslint_react_ast.isFunction);
	if (pFunction !== pFunctionOfReturn) return false;
	return isFunctionOfUseEffectSetup(pFunction);
}

//#endregion
//#region src/jsx/jsx-stringify.ts
/**
* Get the stringified representation of a JSX node
* @param node The JSX node
* @returns The stringified representation
*/
function stringifyJsx(node) {
	switch (node.type) {
		case __typescript_eslint_types.AST_NODE_TYPES.JSXIdentifier: return node.name;
		case __typescript_eslint_types.AST_NODE_TYPES.JSXNamespacedName: return `${node.namespace.name}:${node.name.name}`;
		case __typescript_eslint_types.AST_NODE_TYPES.JSXMemberExpression: return `${stringifyJsx(node.object)}.${stringifyJsx(node.property)}`;
		case __typescript_eslint_types.AST_NODE_TYPES.JSXText: return node.value;
		case __typescript_eslint_types.AST_NODE_TYPES.JSXOpeningElement: return `<${stringifyJsx(node.name)}>`;
		case __typescript_eslint_types.AST_NODE_TYPES.JSXClosingElement: return `</${stringifyJsx(node.name)}>`;
		case __typescript_eslint_types.AST_NODE_TYPES.JSXOpeningFragment: return "<>";
		case __typescript_eslint_types.AST_NODE_TYPES.JSXClosingFragment: return "</>";
	}
}

//#endregion
//#region src/jsx/jsx-attribute-name.ts
/**
* Get the stringified name of a JSX attribute
* @param context The ESLint rule context
* @param node The JSX attribute node
* @returns The name of the attribute
*/
function getAttributeName(context, node) {
	return stringifyJsx(node.name);
}

//#endregion
//#region src/jsx/jsx-attribute.ts
/**
* Get the JSX attribute node with the given name
* @param context The ESLint rule context
* @param name The name of the attribute
* @param attributes The attributes to search
* @param initialScope The initial scope to use for variable resolution
* @returns The JSX attribute node or undefined
*/
function getAttribute(context, name, attributes, initialScope) {
	return attributes.findLast((attr) => {
		if (attr.type === __typescript_eslint_types.AST_NODE_TYPES.JSXAttribute) return getAttributeName(context, attr) === name;
		if (initialScope == null) return false;
		switch (attr.argument.type) {
			case __typescript_eslint_types.AST_NODE_TYPES.Identifier: {
				const variable = __eslint_react_var.findVariable(attr.argument.name, initialScope);
				const variableNode = __eslint_react_var.getVariableInitNode(variable, 0);
				if (variableNode?.type === __typescript_eslint_types.AST_NODE_TYPES.ObjectExpression) return __eslint_react_var.findPropertyInProperties(name, variableNode.properties, initialScope) != null;
				return false;
			}
			case __typescript_eslint_types.AST_NODE_TYPES.ObjectExpression: return __eslint_react_var.findPropertyInProperties(name, attr.argument.properties, initialScope) != null;
		}
		return false;
	});
}

//#endregion
//#region src/jsx/jsx-attribute-value.ts
/**
* Get a StaticValue of the attribute value
* @param context The rule context
* @param node The JSX attribute node
* @param name The name of the attribute
* @returns The StaticValue of the attribute value
*/
function getAttributeValue(context, node, name) {
	const initialScope = context.sourceCode.getScope(node);
	switch (node.type) {
		case __typescript_eslint_types.AST_NODE_TYPES.JSXAttribute:
			if (node.value?.type === __typescript_eslint_types.AST_NODE_TYPES.Literal) return {
				kind: "some",
				node: node.value,
				initialScope,
				value: node.value.value
			};
			if (node.value?.type === __typescript_eslint_types.AST_NODE_TYPES.JSXExpressionContainer) return __eslint_react_var.toStaticValue({
				kind: "lazy",
				node: node.value.expression,
				initialScope
			});
			return {
				kind: "none",
				node,
				initialScope
			};
		case __typescript_eslint_types.AST_NODE_TYPES.JSXSpreadAttribute: {
			const staticValue = __eslint_react_var.toStaticValue({
				kind: "lazy",
				node: node.argument,
				initialScope
			});
			if (staticValue.kind === "none") return staticValue;
			return (0, ts_pattern.match)(staticValue.value).with({ [name]: ts_pattern.P.select(ts_pattern.P.any) }, (value) => ({
				kind: "some",
				node: node.argument,
				initialScope,
				value
			})).otherwise(() => ({
				kind: "none",
				node,
				initialScope
			}));
		}
		default: return {
			kind: "none",
			node,
			initialScope
		};
	}
}

//#endregion
//#region src/jsx/jsx-detection-hint.ts
const JSXDetectionHint = {
	None: 0n,
	SkipUndefined: 1n << 0n,
	SkipNullLiteral: 1n << 1n,
	SkipBooleanLiteral: 1n << 2n,
	SkipStringLiteral: 1n << 3n,
	SkipNumberLiteral: 1n << 4n,
	SkipBigIntLiteral: 1n << 5n,
	SkipEmptyArray: 1n << 6n,
	SkipCreateElement: 1n << 7n,
	StrictArray: 1n << 8n,
	StrictLogical: 1n << 9n,
	StrictConditional: 1n << 10n
};
const DEFAULT_JSX_DETECTION_HINT = 0n | JSXDetectionHint.SkipUndefined | JSXDetectionHint.SkipBooleanLiteral;

//#endregion
//#region src/jsx/jsx-detection.ts
/**
* Check if a node is a `JSXText` or a `Literal` node
* @param node The AST node to check
* @returns `true` if the node is a `JSXText` or a `Literal` node
*/
function isJsxText(node) {
	if (node == null) return false;
	return node.type === __typescript_eslint_types.AST_NODE_TYPES.JSXText || node.type === __typescript_eslint_types.AST_NODE_TYPES.Literal;
}
/**
* Heuristic decision to determine if a node is a JSX-like node.
* @param code The sourceCode object
* @param code.getScope The function to get the scope of a node
* @param node The AST node to check
* @param hint The `JSXDetectionHint` to use
* @returns boolean
*/
function isJsxLike(code, node, hint = DEFAULT_JSX_DETECTION_HINT) {
	if (node == null) return false;
	if (__eslint_react_ast.isJSX(node)) return true;
	switch (node.type) {
		case __typescript_eslint_types.AST_NODE_TYPES.Literal:
			switch (typeof node.value) {
				case "boolean": return !(hint & JSXDetectionHint.SkipBooleanLiteral);
				case "string": return !(hint & JSXDetectionHint.SkipStringLiteral);
				case "number": return !(hint & JSXDetectionHint.SkipNumberLiteral);
				case "bigint": return !(hint & JSXDetectionHint.SkipBigIntLiteral);
			}
			if (node.value == null) return !(hint & JSXDetectionHint.SkipNullLiteral);
			return false;
		case __typescript_eslint_types.AST_NODE_TYPES.TemplateLiteral: return !(hint & JSXDetectionHint.SkipStringLiteral);
		case __typescript_eslint_types.AST_NODE_TYPES.ArrayExpression:
			if (node.elements.length === 0) return !(hint & JSXDetectionHint.SkipEmptyArray);
			if (hint & JSXDetectionHint.StrictArray) return node.elements.every((n) => isJsxLike(code, n, hint));
			return node.elements.some((n) => isJsxLike(code, n, hint));
		case __typescript_eslint_types.AST_NODE_TYPES.LogicalExpression:
			if (hint & JSXDetectionHint.StrictLogical) return isJsxLike(code, node.left, hint) && isJsxLike(code, node.right, hint);
			return isJsxLike(code, node.left, hint) || isJsxLike(code, node.right, hint);
		case __typescript_eslint_types.AST_NODE_TYPES.ConditionalExpression: {
			function leftHasJSX(node$1) {
				if (Array.isArray(node$1.consequent)) {
					if (node$1.consequent.length === 0) return !(hint & JSXDetectionHint.SkipEmptyArray);
					if (hint & JSXDetectionHint.StrictArray) return node$1.consequent.every((n) => isJsxLike(code, n, hint));
					return node$1.consequent.some((n) => isJsxLike(code, n, hint));
				}
				return isJsxLike(code, node$1.consequent, hint);
			}
			function rightHasJSX(node$1) {
				return isJsxLike(code, node$1.alternate, hint);
			}
			if (hint & JSXDetectionHint.StrictConditional) return leftHasJSX(node) && rightHasJSX(node);
			return leftHasJSX(node) || rightHasJSX(node);
		}
		case __typescript_eslint_types.AST_NODE_TYPES.SequenceExpression: {
			const exp = node.expressions.at(-1);
			return isJsxLike(code, exp, hint);
		}
		case __typescript_eslint_types.AST_NODE_TYPES.CallExpression:
			if (hint & JSXDetectionHint.SkipCreateElement) return false;
			switch (node.callee.type) {
				case __typescript_eslint_types.AST_NODE_TYPES.Identifier: return node.callee.name === "createElement";
				case __typescript_eslint_types.AST_NODE_TYPES.MemberExpression: return node.callee.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.callee.property.name === "createElement";
			}
			return false;
		case __typescript_eslint_types.AST_NODE_TYPES.Identifier: {
			const { name } = node;
			if (name === "undefined") return !(hint & JSXDetectionHint.SkipUndefined);
			if (__eslint_react_ast.isJSXTagNameExpression(node)) return true;
			const variable = __eslint_react_var.findVariable(name, code.getScope(node));
			const variableNode = variable && __eslint_react_var.getVariableInitNode(variable, 0);
			return !!variableNode && isJsxLike(code, variableNode, hint);
		}
	}
	return false;
}

//#endregion
//#region src/jsx/jsx-element-type.ts
/**
* Get the stringified type of a JSX element
* @param context The ESLint rule context
* @param node The JSX element node
* @returns The type of the element
*/
function getElementType(context, node) {
	if (node.type === __typescript_eslint_types.AST_NODE_TYPES.JSXFragment) return "";
	return stringifyJsx(node.openingElement.name);
}

//#endregion
//#region src/jsx/jsx-has.ts
function hasAttribute(context, name, attributes, initialScope) {
	return getAttribute(context, name, attributes, initialScope) != null;
}
function hasAnyAttribute(context, names, attributes, initialScope) {
	return names.some((n) => hasAttribute(context, n, attributes, initialScope));
}
function hasEveryAttribute(context, names, attributes, initialScope) {
	return names.every((n) => hasAttribute(context, n, attributes, initialScope));
}

//#endregion
//#region src/jsx/jsx-hierarchy.ts
/**
* Find the parent JSX attribute node of a node
* @param node The node to find the parent attribute of
* @param test The test to apply to the parent attribute
* @returns The parent attribute node or undefined
*/
function findParentAttribute(node, test = __eslint_react_eff.constTrue) {
	const guard = (node$1) => {
		return node$1.type === __typescript_eslint_types.AST_NODE_TYPES.JSXAttribute && test(node$1);
	};
	return __eslint_react_ast.findParentNode(node, guard);
}

//#endregion
//#region src/jsx/jsx-is.ts
function isHostElement(context, node) {
	return node.type === __typescript_eslint_types.AST_NODE_TYPES.JSXElement && node.openingElement.name.type === __typescript_eslint_types.AST_NODE_TYPES.JSXIdentifier && /^[a-z]/u.test(node.openingElement.name.name);
}
function isKeyedElement(context, node, initialScope) {
	return node.type === __typescript_eslint_types.AST_NODE_TYPES.JSXElement && hasAttribute(context, "key", node.openingElement.attributes, initialScope);
}
function isFragmentElement(context, node, allowJSXFragment = false) {
	if (node == null) return false;
	if (node.type !== __typescript_eslint_types.AST_NODE_TYPES.JSXElement && node.type !== __typescript_eslint_types.AST_NODE_TYPES.JSXFragment) return false;
	if (node.type === __typescript_eslint_types.AST_NODE_TYPES.JSXFragment) return allowJSXFragment;
	return getElementType(context, node).split(".").at(-1) === "Fragment";
}

//#endregion
//#region src/component/component-detection-hint.ts
/**
* Hints for component collector
*/
const ComponentDetectionHint = {
	...JSXDetectionHint,
	SkipMemo: 1n << 64n,
	SkipForwardRef: 1n << 65n,
	SkipArrayMapArgument: 1n << 66n,
	SkipObjectMethod: 1n << 67n,
	SkipClassMethod: 1n << 68n,
	SkipClassProperty: 1n << 69n
};
/**
* Default component detection hint
*/
const DEFAULT_COMPONENT_DETECTION_HINT = 0n | ComponentDetectionHint.SkipBooleanLiteral | ComponentDetectionHint.SkipEmptyArray | ComponentDetectionHint.SkipArrayMapArgument | ComponentDetectionHint.SkipNumberLiteral | ComponentDetectionHint.SkipStringLiteral | ComponentDetectionHint.SkipUndefined | ComponentDetectionHint.StrictArray | ComponentDetectionHint.StrictConditional | ComponentDetectionHint.StrictLogical;

//#endregion
//#region src/component/component-is.ts
/**
* Check if a node is a React class component
* @param node The AST node to check
* @returns `true` if the node is a class component, `false` otherwise
*/
function isClassComponent(node) {
	if ("superClass" in node && node.superClass != null) {
		const re = /^(?:Pure)?Component$/u;
		switch (true) {
			case node.superClass.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier: return re.test(node.superClass.name);
			case node.superClass.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && node.superClass.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier: return re.test(node.superClass.property.name);
		}
	}
	return false;
}
/**
* Check if a node is a React PureComponent
* @param node The AST node to check
* @returns `true` if the node is a pure component, `false` otherwise
*/
function isPureComponent(node) {
	if ("superClass" in node && node.superClass != null) {
		const re = /^PureComponent$/u;
		switch (true) {
			case node.superClass.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier: return re.test(node.superClass.name);
			case node.superClass.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && node.superClass.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier: return re.test(node.superClass.property.name);
		}
	}
	return false;
}

//#endregion
//#region src/component/component-lifecycle.ts
function isComponentDidCatch(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidCatch";
}
function isComponentDidMount(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
function isComponentDidUpdate(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidUpdate";
}
function isComponentWillMount(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillMount";
}
function isComponentWillReceiveProps(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillReceiveProps";
}
function isComponentWillUnmount(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUnmount";
}
function isComponentWillUpdate(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
function isGetChildContext(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "getChildContext";
}
function isGetDefaultProps(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "getDefaultProps";
}
function isGetInitialState(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "getInitialState";
}
function isGetSnapshotBeforeUpdate(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "getSnapshotBeforeUpdate";
}
function isShouldComponentUpdate(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
function isUnsafeComponentWillMount(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
function isUnsafeComponentWillReceiveProps(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
function isUnsafeComponentWillUpdate(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && !node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
function isGetDerivedStateFromProps(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromProps";
}
function isGetDerivedStateFromError(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && node.static && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromError";
}

//#endregion
//#region src/component/component-render.ts
/**
* Check whether given node is a render function of a class component
* @example
* ```tsx
* class Component extends React.Component {
*   render() {
*    return <div />;
*  }
* }
* ```
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isRenderLike(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name === "render" && node.parent.parent.type === __typescript_eslint_types.AST_NODE_TYPES.ClassDeclaration;
}
/**
* Check whether given node is a function of a render function of a class component
* @example
* ```tsx
* class Component extends React.Component {
*   render = () => <div />;
* ```
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isFunctionOfRender(node) {
	if (!isRenderLike(node.parent)) return false;
	return isClassComponent(node.parent.parent.parent);
}

//#endregion
//#region src/component/component-render-method.ts
/**
* Check whether given node is a render method of a class component
* @example
* ```tsx
* class Component extends React.Component {
*   renderHeader = () => <div />;
*   renderFooter = () => <div />;
* }
* ```
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isRenderMethodLike(node) {
	return __eslint_react_ast.isMethodOrProperty(node) && node.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node.key.name.startsWith("render") && node.parent.parent.type === __typescript_eslint_types.AST_NODE_TYPES.ClassDeclaration;
}

//#endregion
//#region src/component/component-hierarchy.ts
/**
* Determines whether inside `createElement`'s children.
* @param context The rule context
* @param node The AST node to check
* @returns `true` if the node is inside createElement's children
*/
function isChildrenOfCreateElement(context, node) {
	const parent = node.parent;
	if (parent == null || parent.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return false;
	if (!isCreateElementCall(context, parent)) return false;
	return parent.arguments.slice(2).some((arg) => arg === node);
}
/**
* Check whether given node is declared inside class component's render block
* ```tsx
* class Component extends React.Component {
*   render() {
*     class NestedClassComponent extends React.Component {
*      render() { return <div />; }
*     }
*     const nestedFunctionComponent = () => <div />;
*  }
* }
* ```
* @param node The AST node being checked
* @returns `true` if node is inside class component's render block, `false` if not
*/
function isInsideRenderMethod(node) {
	return __eslint_react_ast.findParentNode(node, (n) => isRenderLike(n) && isClassComponent(n.parent.parent)) != null;
}
function isFunctionOfComponentDidMount(node) {
	return __eslint_react_ast.isFunction(node) && isComponentDidMount(node.parent) && node.parent.value === node;
}
function isFunctionOfComponentWillUnmount(node) {
	return __eslint_react_ast.isFunction(node) && isComponentWillUnmount(node.parent) && node.parent.value === node;
}
/**
* Check whether given node is a function of a render method of a class component
* @example
* ```tsx
* class Component extends React.Component {
*   renderHeader = () => <div />;
*   renderFooter = () => <div />;
* }
* ```
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isFunctionOfRenderMethod(node) {
	if (!isRenderMethodLike(node.parent)) return false;
	return isClassComponent(node.parent.parent.parent);
}

//#endregion
//#region src/component/component-definition.ts
const isFunctionOfClassMethod = (0, ts_pattern.isMatching)({
	type: ts_pattern.P.union(__typescript_eslint_types.AST_NODE_TYPES.ArrowFunctionExpression, __typescript_eslint_types.AST_NODE_TYPES.FunctionExpression),
	parent: __typescript_eslint_types.AST_NODE_TYPES.MethodDefinition
});
const isFunctionOfClassProperty = (0, ts_pattern.isMatching)({
	type: ts_pattern.P.union(__typescript_eslint_types.AST_NODE_TYPES.ArrowFunctionExpression, __typescript_eslint_types.AST_NODE_TYPES.FunctionExpression),
	parent: __typescript_eslint_types.AST_NODE_TYPES.Property
});
const isFunctionOfObjectMethod = (0, ts_pattern.isMatching)({
	type: ts_pattern.P.union(__typescript_eslint_types.AST_NODE_TYPES.ArrowFunctionExpression, __typescript_eslint_types.AST_NODE_TYPES.FunctionExpression),
	parent: {
		type: __typescript_eslint_types.AST_NODE_TYPES.Property,
		parent: { type: __typescript_eslint_types.AST_NODE_TYPES.ObjectExpression }
	}
});
function isValidComponentDefinition(context, node, hint) {
	if (isChildrenOfCreateElement(context, node) || isFunctionOfRenderMethod(node)) return false;
	if (hint & ComponentDetectionHint.SkipObjectMethod && isFunctionOfObjectMethod(node.parent)) return false;
	if (hint & ComponentDetectionHint.SkipClassMethod && isFunctionOfClassMethod(node.parent)) return false;
	if (hint & ComponentDetectionHint.SkipClassProperty && isFunctionOfClassProperty(node.parent)) return false;
	if (hint & ComponentDetectionHint.SkipArrayMapArgument && __eslint_react_ast.isArrayMapCall(node.parent)) return false;
	const significantParent = __eslint_react_ast.findParentNode(node, __eslint_react_ast.isOneOf([
		__typescript_eslint_types.AST_NODE_TYPES.JSXExpressionContainer,
		__typescript_eslint_types.AST_NODE_TYPES.ArrowFunctionExpression,
		__typescript_eslint_types.AST_NODE_TYPES.FunctionExpression,
		__typescript_eslint_types.AST_NODE_TYPES.Property,
		__typescript_eslint_types.AST_NODE_TYPES.ClassBody
	]));
	return significantParent == null || significantParent.type !== __typescript_eslint_types.AST_NODE_TYPES.JSXExpressionContainer;
}

//#endregion
//#region src/component/component-wrapper.ts
/**
* Check if the node is a call expression for a component wrapper
* @param context The ESLint rule context
* @param node The node to check
* @returns `true` if the node is a call expression for a component wrapper
*/
function isComponentWrapperCall(context, node) {
	if (node.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return false;
	return isMemoCall(context, node) || isForwardRefCall(context, node);
}
/**
* Check if the node is a call expression for a component wrapper loosely
* @param context The ESLint rule context
* @param node The node to check
* @returns `true` if the node is a call expression for a component wrapper loosely
*/
function isComponentWrapperCallLoose(context, node) {
	if (node.type !== __typescript_eslint_types.AST_NODE_TYPES.CallExpression) return false;
	return isComponentWrapperCall(context, node) || isUseCallbackCall(context, node);
}

//#endregion
//#region src/component/component-id.ts
function getFunctionComponentId(context, node) {
	const functionId = __eslint_react_ast.getFunctionId(node);
	if (functionId != null) return functionId;
	const { parent } = node;
	if (parent.type === __typescript_eslint_types.AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === __typescript_eslint_types.AST_NODE_TYPES.VariableDeclarator && parent.parent.id.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier) return parent.parent.id;
	if (parent.type === __typescript_eslint_types.AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === __typescript_eslint_types.AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent.parent) && parent.parent.parent.type === __typescript_eslint_types.AST_NODE_TYPES.VariableDeclarator && parent.parent.parent.id.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier) return parent.parent.parent.id;
	return __eslint_react_eff.unit;
}

//#endregion
//#region src/component/component-flag.ts
const ComponentFlag = {
	None: 0n,
	PureComponent: 1n << 0n,
	CreateElement: 1n << 1n,
	Memo: 1n << 2n,
	ForwardRef: 1n << 3n,
	Async: 1n << 4n
};

//#endregion
//#region src/component/component-init-path.ts
function getComponentFlagFromInitPath(initPath) {
	let flag = ComponentFlag.None;
	if (initPath != null && __eslint_react_ast.hasCallInFunctionInitPath("memo", initPath)) flag |= ComponentFlag.Memo;
	if (initPath != null && __eslint_react_ast.hasCallInFunctionInitPath("forwardRef", initPath)) flag |= ComponentFlag.ForwardRef;
	return flag;
}

//#endregion
//#region src/component/component-name.ts
function isComponentName(name) {
	return __eslint_react_kit.RegExp.COMPONENT_NAME.test(name);
}
function isComponentNameLoose(name) {
	return __eslint_react_kit.RegExp.COMPONENT_NAME_LOOSE.test(name);
}
function getComponentNameFromId(id) {
	if (id == null) return __eslint_react_eff.unit;
	return Array.isArray(id) ? id.map((n) => n.name).join(".") : id.name;
}
function hasNoneOrLooseComponentName(context, fn) {
	const id = getFunctionComponentId(context, fn);
	if (id == null) return true;
	const name = Array.isArray(id) ? id.at(-1)?.name : id.name;
	return name != null && isComponentNameLoose(name);
}

//#endregion
//#region src/component/component-collector.ts
/**
* Get a ctx and listeners for the rule to collect function components
* @param context The ESLint rule context
* @param options The options to use
* @returns The component collector
*/
function useComponentCollector(context, options = {}) {
	const { collectDisplayName = false, collectHookCalls = false, hint = DEFAULT_COMPONENT_DETECTION_HINT } = options;
	const components = /* @__PURE__ */ new Map();
	const functionEntries = [];
	const getCurrentEntry = () => functionEntries.at(-1);
	const onFunctionEnter = (node) => {
		const key = (0, __eslint_react_shared.getId)();
		functionEntries.push({
			key,
			node,
			hookCalls: [],
			isComponent: false
		});
	};
	const onFunctionExit = () => {
		const entry = functionEntries.at(-1);
		if (entry == null) return;
		if (!entry.isComponent) return functionEntries.pop();
		const rets = __eslint_react_ast.getNestedReturnStatements(entry.node.body);
		for (let i = rets.length - 1; i >= 0; i--) {
			const ret = rets[i];
			if (ret == null) continue;
			if (context.sourceCode.getScope(ret).block === entry.node && ret.argument != null && !isJsxLike(context.sourceCode, ret.argument, hint)) {
				components.delete(entry.key);
				break;
			}
		}
		return functionEntries.pop();
	};
	const ctx = {
		getAllComponents(node) {
			return components;
		},
		getCurrentEntries() {
			return [...functionEntries];
		},
		getCurrentEntry
	};
	const listeners = {
		":function[type]": onFunctionEnter,
		":function[type]:exit": onFunctionExit,
		"ArrowFunctionExpression[body.type!='BlockStatement']"() {
			const entry = getCurrentEntry();
			if (entry == null) return;
			const { body } = entry.node;
			if (!(hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, body, hint) && isValidComponentDefinition(context, entry.node, hint))) return;
			const initPath = __eslint_react_ast.getFunctionInitPath(entry.node);
			const id = getFunctionComponentId(context, entry.node);
			const name = getComponentNameFromId(id);
			const key = (0, __eslint_react_shared.getId)();
			components.set(key, {
				id,
				key,
				kind: "function",
				name,
				node: entry.node,
				displayName: __eslint_react_eff.unit,
				flag: getComponentFlagFromInitPath(initPath),
				hint,
				hookCalls: entry.hookCalls,
				initPath
			});
		},
		...collectDisplayName ? { [__eslint_react_kit.Selector.DISPLAY_NAME_ASSIGNMENT_EXPRESSION](node) {
			const { left, right } = node;
			if (left.type !== __typescript_eslint_types.AST_NODE_TYPES.MemberExpression) return;
			const componentName = left.object.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier ? left.object.name : __eslint_react_eff.unit;
			const component = [...components.values()].findLast(({ name }) => name != null && name === componentName);
			if (component == null) return;
			component.displayName = right;
		} } : {},
		...collectHookCalls ? { "CallExpression[type]:exit"(node) {
			if (!isReactHookCall(node)) return;
			const entry = getCurrentEntry();
			if (entry == null) return;
			entry.hookCalls.push(node);
		} } : {},
		"ReturnStatement[type]"(node) {
			const entry = getCurrentEntry();
			if (entry == null) return;
			if (!(hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, node.argument, hint) && isValidComponentDefinition(context, entry.node, hint))) return;
			entry.isComponent = true;
			const initPath = __eslint_react_ast.getFunctionInitPath(entry.node);
			const id = getFunctionComponentId(context, entry.node);
			const name = getComponentNameFromId(id);
			components.set(entry.key, {
				id,
				key: entry.key,
				kind: "function",
				name,
				node: entry.node,
				displayName: __eslint_react_eff.unit,
				flag: getComponentFlagFromInitPath(initPath),
				hint,
				hookCalls: entry.hookCalls,
				initPath
			});
		}
	};
	return {
		ctx,
		listeners
	};
}

//#endregion
//#region src/component/component-collector-legacy.ts
/**
* Get a ctx and listeners object for the rule to collect class components
* @returns The context and listeners for the rule
*/
function useComponentCollectorLegacy() {
	const components = /* @__PURE__ */ new Map();
	const ctx = { getAllComponents(node) {
		return components;
	} };
	const collect = (node) => {
		if (!isClassComponent(node)) return;
		const id = __eslint_react_ast.getClassId(node);
		const key = (0, __eslint_react_shared.getId)();
		const flag = isPureComponent(node) ? ComponentFlag.PureComponent : ComponentFlag.None;
		components.set(key, {
			id,
			key,
			kind: "class",
			name: id?.name,
			node,
			displayName: __eslint_react_eff.unit,
			flag,
			hint: 0n,
			methods: []
		});
	};
	return {
		ctx,
		listeners: {
			"ClassDeclaration[type]": collect,
			"ClassExpression[type]": collect
		}
	};
}

//#endregion
//#region src/component/component-phase.ts
const ComponentPhaseRelevance = (0, birecord.default)({
	mount: "unmount",
	setup: "cleanup"
});
const isInversePhase = (0, __eslint_react_eff.dual)(2, (a, b) => ComponentPhaseRelevance.get(a) === b);

//#endregion
//#region src/component/component-render-prop.ts
/**
* Unsafe check whether given node is a render function
* ```tsx
* const renderRow = () => <div />
* `                 ^^^^^^^^^^^^`
* _ = <Component renderRow={() => <div />} />
* `                         ^^^^^^^^^^^^^   `
* ```
* @param context The rule context
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isRenderFunctionLoose(context, node) {
	const { body, parent } = node;
	if (__eslint_react_ast.getFunctionId(node)?.name.startsWith("render")) return parent.type === __typescript_eslint_types.AST_NODE_TYPES.JSXExpressionContainer && parent.parent.type === __typescript_eslint_types.AST_NODE_TYPES.JSXAttribute && parent.parent.name.type === __typescript_eslint_types.AST_NODE_TYPES.JSXIdentifier && parent.parent.name.name.startsWith("render");
	return isJsxLike(context.sourceCode, body, JSXDetectionHint.SkipNullLiteral | JSXDetectionHint.SkipUndefined | JSXDetectionHint.StrictLogical | JSXDetectionHint.StrictConditional);
}
/**
* Unsafe check whether given JSXAttribute is a render prop
* ```tsx
* _ = <Component renderRow={() => <div />} />
* `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
* ```
* @param context The rule context
* @param node The AST node to check
* @returns `true` if node is a render prop, `false` if not
*/
function isRenderPropLoose(context, node) {
	if (node.name.type !== __typescript_eslint_types.AST_NODE_TYPES.JSXIdentifier) return false;
	return node.name.name.startsWith("render") && node.value?.type === __typescript_eslint_types.AST_NODE_TYPES.JSXExpressionContainer && __eslint_react_ast.isFunction(node.value.expression) && isRenderFunctionLoose(context, node.value.expression);
}
/**
* Unsafe check whether given node is declared directly inside a render property
* ```tsx
* const rows = { render: () => <div /> }
* `                      ^^^^^^^^^^^^^ `
* _ = <Component rows={ [{ render: () => <div /> }] } />
* `                                ^^^^^^^^^^^^^       `
*  ```
* @internal
* @param node The AST node to check
* @returns `true` if component is declared inside a render property, `false` if not
*/
function isDirectValueOfRenderPropertyLoose(node) {
	const matching = (node$1) => {
		return node$1.type === __typescript_eslint_types.AST_NODE_TYPES.Property && node$1.key.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && node$1.key.name.startsWith("render");
	};
	return matching(node) || node.parent != null && matching(node.parent);
}
/**
* Unsafe check whether given node is declared inside a render prop
* ```tsx
* _ = <Component renderRow={"node"} />
* `                         ^^^^^^   `
* _ = <Component rows={ [{ render: "node" }] } />
* `                                ^^^^^^       `
* ```
* @param node The AST node to check
* @returns `true` if component is declared inside a render prop, `false` if not
*/
function isDeclaredInRenderPropLoose(node) {
	if (isDirectValueOfRenderPropertyLoose(node)) return true;
	const parent = __eslint_react_ast.findParentNode(node, __eslint_react_ast.is(__typescript_eslint_types.AST_NODE_TYPES.JSXExpressionContainer))?.parent;
	if (parent?.type !== __typescript_eslint_types.AST_NODE_TYPES.JSXAttribute) return false;
	return parent.name.type === __typescript_eslint_types.AST_NODE_TYPES.JSXIdentifier && parent.name.name.startsWith("render");
}

//#endregion
//#region src/component/component-state.ts
function isThisSetState(node) {
	const { callee } = node;
	return callee.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && __eslint_react_ast.isThisExpression(callee.object) && callee.property.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && callee.property.name === "setState";
}
function isAssignmentToThisState(node) {
	const { left } = node;
	return left.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && __eslint_react_ast.isThisExpression(left.object) && __eslint_react_ast.getPropertyName(left.property) === "state";
}

//#endregion
exports.ComponentDetectionHint = ComponentDetectionHint;
exports.ComponentFlag = ComponentFlag;
exports.ComponentPhaseRelevance = ComponentPhaseRelevance;
exports.DEFAULT_COMPONENT_DETECTION_HINT = DEFAULT_COMPONENT_DETECTION_HINT;
exports.DEFAULT_JSX_DETECTION_HINT = DEFAULT_JSX_DETECTION_HINT;
exports.JSXDetectionHint = JSXDetectionHint;
exports.findParentAttribute = findParentAttribute;
exports.getAttribute = getAttribute;
exports.getAttributeName = getAttributeName;
exports.getAttributeValue = getAttributeValue;
exports.getComponentFlagFromInitPath = getComponentFlagFromInitPath;
exports.getComponentNameFromId = getComponentNameFromId;
exports.getElementType = getElementType;
exports.getFunctionComponentId = getFunctionComponentId;
exports.getInstanceId = getInstanceId;
exports.hasAnyAttribute = hasAnyAttribute;
exports.hasAttribute = hasAttribute;
exports.hasEveryAttribute = hasEveryAttribute;
exports.hasNoneOrLooseComponentName = hasNoneOrLooseComponentName;
exports.isAssignmentToThisState = isAssignmentToThisState;
exports.isCaptureOwnerStack = isCaptureOwnerStack;
exports.isCaptureOwnerStackCall = isCaptureOwnerStackCall;
exports.isChildrenCount = isChildrenCount;
exports.isChildrenCountCall = isChildrenCountCall;
exports.isChildrenForEach = isChildrenForEach;
exports.isChildrenForEachCall = isChildrenForEachCall;
exports.isChildrenMap = isChildrenMap;
exports.isChildrenMapCall = isChildrenMapCall;
exports.isChildrenOfCreateElement = isChildrenOfCreateElement;
exports.isChildrenOnly = isChildrenOnly;
exports.isChildrenOnlyCall = isChildrenOnlyCall;
exports.isChildrenToArray = isChildrenToArray;
exports.isChildrenToArrayCall = isChildrenToArrayCall;
exports.isClassComponent = isClassComponent;
exports.isCloneElement = isCloneElement;
exports.isCloneElementCall = isCloneElementCall;
exports.isComponentDidCatch = isComponentDidCatch;
exports.isComponentDidMount = isComponentDidMount;
exports.isComponentDidUpdate = isComponentDidUpdate;
exports.isComponentName = isComponentName;
exports.isComponentNameLoose = isComponentNameLoose;
exports.isComponentWillMount = isComponentWillMount;
exports.isComponentWillReceiveProps = isComponentWillReceiveProps;
exports.isComponentWillUnmount = isComponentWillUnmount;
exports.isComponentWillUpdate = isComponentWillUpdate;
exports.isComponentWrapperCall = isComponentWrapperCall;
exports.isComponentWrapperCallLoose = isComponentWrapperCallLoose;
exports.isCreateContext = isCreateContext;
exports.isCreateContextCall = isCreateContextCall;
exports.isCreateElement = isCreateElement;
exports.isCreateElementCall = isCreateElementCall;
exports.isCreateRef = isCreateRef;
exports.isCreateRefCall = isCreateRefCall;
exports.isDeclaredInRenderPropLoose = isDeclaredInRenderPropLoose;
exports.isDirectValueOfRenderPropertyLoose = isDirectValueOfRenderPropertyLoose;
exports.isForwardRef = isForwardRef;
exports.isForwardRefCall = isForwardRefCall;
exports.isFragmentElement = isFragmentElement;
exports.isFunctionOfComponentDidMount = isFunctionOfComponentDidMount;
exports.isFunctionOfComponentWillUnmount = isFunctionOfComponentWillUnmount;
exports.isFunctionOfRender = isFunctionOfRender;
exports.isFunctionOfRenderMethod = isFunctionOfRenderMethod;
exports.isFunctionOfUseEffectCleanup = isFunctionOfUseEffectCleanup;
exports.isFunctionOfUseEffectSetup = isFunctionOfUseEffectSetup;
exports.isGetChildContext = isGetChildContext;
exports.isGetDefaultProps = isGetDefaultProps;
exports.isGetDerivedStateFromError = isGetDerivedStateFromError;
exports.isGetDerivedStateFromProps = isGetDerivedStateFromProps;
exports.isGetInitialState = isGetInitialState;
exports.isGetSnapshotBeforeUpdate = isGetSnapshotBeforeUpdate;
exports.isHostElement = isHostElement;
exports.isInitializedFromReact = isInitializedFromReact;
exports.isInsideRenderMethod = isInsideRenderMethod;
exports.isInstanceIdEqual = isInstanceIdEqual;
exports.isInversePhase = isInversePhase;
exports.isJsxLike = isJsxLike;
exports.isJsxText = isJsxText;
exports.isKeyedElement = isKeyedElement;
exports.isLazy = isLazy;
exports.isLazyCall = isLazyCall;
exports.isMemo = isMemo;
exports.isMemoCall = isMemoCall;
exports.isPureComponent = isPureComponent;
exports.isReactAPI = isReactAPI;
exports.isReactAPICall = isReactAPICall;
exports.isReactHook = isReactHook;
exports.isReactHookCall = isReactHookCall;
exports.isReactHookCallWithName = isReactHookCallWithName;
exports.isReactHookCallWithNameAlias = isReactHookCallWithNameAlias;
exports.isReactHookCallWithNameLoose = isReactHookCallWithNameLoose;
exports.isReactHookName = isReactHookName;
exports.isRenderFunctionLoose = isRenderFunctionLoose;
exports.isRenderLike = isRenderLike;
exports.isRenderMethodLike = isRenderMethodLike;
exports.isRenderPropLoose = isRenderPropLoose;
exports.isShouldComponentUpdate = isShouldComponentUpdate;
exports.isThisSetState = isThisSetState;
exports.isUnsafeComponentWillMount = isUnsafeComponentWillMount;
exports.isUnsafeComponentWillReceiveProps = isUnsafeComponentWillReceiveProps;
exports.isUnsafeComponentWillUpdate = isUnsafeComponentWillUpdate;
exports.isUseActionStateCall = isUseActionStateCall;
exports.isUseCall = isUseCall;
exports.isUseCallbackCall = isUseCallbackCall;
exports.isUseContextCall = isUseContextCall;
exports.isUseDebugValueCall = isUseDebugValueCall;
exports.isUseDeferredValueCall = isUseDeferredValueCall;
exports.isUseEffectCall = isUseEffectCall;
exports.isUseEffectCallLoose = isUseEffectCallLoose;
exports.isUseFormStatusCall = isUseFormStatusCall;
exports.isUseIdCall = isUseIdCall;
exports.isUseImperativeHandleCall = isUseImperativeHandleCall;
exports.isUseInsertionEffectCall = isUseInsertionEffectCall;
exports.isUseLayoutEffectCall = isUseLayoutEffectCall;
exports.isUseMemoCall = isUseMemoCall;
exports.isUseOptimisticCall = isUseOptimisticCall;
exports.isUseReducerCall = isUseReducerCall;
exports.isUseRefCall = isUseRefCall;
exports.isUseStateCall = isUseStateCall;
exports.isUseSyncExternalStoreCall = isUseSyncExternalStoreCall;
exports.isUseTransitionCall = isUseTransitionCall;
exports.isValidComponentDefinition = isValidComponentDefinition;
exports.stringifyJsx = stringifyJsx;
exports.useComponentCollector = useComponentCollector;
exports.useComponentCollectorLegacy = useComponentCollectorLegacy;
exports.useHookCollector = useHookCollector;