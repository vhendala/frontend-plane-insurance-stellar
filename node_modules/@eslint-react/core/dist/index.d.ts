import * as AST from "@eslint-react/ast";
import { unit } from "@eslint-react/eff";
import { RuleContext } from "@eslint-react/kit";
import { TSESTree } from "@typescript-eslint/types";
import { ESLintUtils, TSESTree as TSESTree$1 } from "@typescript-eslint/utils";
import * as birecord0 from "birecord";
import { Scope } from "@typescript-eslint/scope-manager";
import * as VAR from "@eslint-react/var";

//#region src/component/component-detection-hint.d.ts
type ComponentDetectionHint = bigint;
/**
 * Hints for component collector
 */
declare const ComponentDetectionHint: {
  /**
   * Skip function component created by React.memo
   */
  readonly SkipMemo: bigint;
  /**
   * Skip function component created by React.forwardRef
   */
  readonly SkipForwardRef: bigint;
  /**
   * Skip function component defined as array map argument
   */
  readonly SkipArrayMapArgument: bigint;
  /**
   * Skip function component defined on object method
   */
  readonly SkipObjectMethod: bigint;
  /**
   * Skip function component defined on class method
   */
  readonly SkipClassMethod: bigint;
  /**
   * Skip function component defined on class property
   */
  readonly SkipClassProperty: bigint;
  readonly None: 0n;
  readonly SkipUndefined: bigint;
  readonly SkipNullLiteral: bigint;
  readonly SkipBooleanLiteral: bigint;
  readonly SkipStringLiteral: bigint;
  readonly SkipNumberLiteral: bigint;
  readonly SkipBigIntLiteral: bigint;
  readonly SkipEmptyArray: bigint;
  readonly SkipCreateElement: bigint;
  readonly StrictArray: bigint;
  readonly StrictLogical: bigint;
  readonly StrictConditional: bigint;
};
/**
 * Default component detection hint
 */
declare const DEFAULT_COMPONENT_DETECTION_HINT: bigint;
//#endregion
//#region src/component/component-phase.d.ts
type ComponentEffectPhaseKind = "cleanup" | "setup";
type ComponentLifecyclePhaseKind = "mount" | "unmount";
type ComponentPhaseKind = ComponentEffectPhaseKind | ComponentLifecyclePhaseKind;
declare const ComponentPhaseRelevance: birecord0.BiRecord<{
  readonly mount: "unmount";
  readonly setup: "cleanup";
}>;
declare const isInversePhase: {
  (a: ComponentPhaseKind): (b: ComponentPhaseKind) => boolean;
  (a: ComponentPhaseKind, b: ComponentPhaseKind): boolean;
};
//#endregion
//#region src/semantic/semantic-entry.d.ts
interface SemanticEntry {
  node: TSESTree.Node;
  phase: ComponentPhaseKind;
}
//#endregion
//#region src/semantic/semantic-node.d.ts
interface SemanticNode {
  id: unit | TSESTree.Identifier | TSESTree.Identifier[];
  key: string;
  kind: string;
  name: unit | string;
  node: TSESTree.Node;
  flag: bigint;
  hint: bigint;
}
//#endregion
//#region src/component/component-flag.d.ts
type ComponentFlag = bigint;
declare const ComponentFlag: {
  None: bigint;
  PureComponent: bigint;
  CreateElement: bigint;
  Memo: bigint;
  ForwardRef: bigint;
  Async: bigint;
};
//#endregion
//#region src/component/component-semantic-node.d.ts
interface FunctionComponent extends SemanticNode {
  id: unit | TSESTree.Identifier | TSESTree.Identifier[];
  kind: "function";
  node: AST.TSESTreeFunction;
  flag: ComponentFlag;
  hint: ComponentDetectionHint;
  initPath: unit | AST.FunctionInitPath;
  hookCalls: TSESTree.CallExpression[];
  displayName: unit | TSESTree.Expression;
}
interface ClassComponent extends SemanticNode {
  id: unit | TSESTree.Identifier;
  kind: "class";
  node: AST.TSESTreeClass;
  flag: ComponentFlag;
  hint: ComponentDetectionHint;
  methods: AST.TSESTreeMethodOrProperty[];
  displayName: unit | TSESTree.Expression;
}
type Component = ClassComponent | FunctionComponent;
//#endregion
//#region src/component/component-collector.d.ts
type FunctionEntry = {
  key: string;
  node: AST.TSESTreeFunction;
  hookCalls: TSESTree.CallExpression[];
  isComponent: boolean;
};
declare namespace useComponentCollector {
  type Options = {
    collectDisplayName?: boolean;
    collectHookCalls?: boolean;
    hint?: ComponentDetectionHint;
  };
  type ReturnType = {
    ctx: {
      getAllComponents: (node: TSESTree.Program) => Map<string, FunctionComponent>;
      getCurrentEntries: () => FunctionEntry[];
      getCurrentEntry: () => FunctionEntry | unit;
    };
    listeners: ESLintUtils.RuleListener;
  };
}
/**
 * Get a ctx and listeners for the rule to collect function components
 * @param context The ESLint rule context
 * @param options The options to use
 * @returns The component collector
 */
declare function useComponentCollector(context: RuleContext, options?: useComponentCollector.Options): useComponentCollector.ReturnType;
//#endregion
//#region src/component/component-collector-legacy.d.ts
declare namespace useComponentCollectorLegacy {
  type ReturnType = {
    ctx: {
      getAllComponents: (node: TSESTree$1.Program) => Map<string, ClassComponent>;
    };
    listeners: ESLintUtils.RuleListener;
  };
}
/**
 * Get a ctx and listeners object for the rule to collect class components
 * @returns The context and listeners for the rule
 */
declare function useComponentCollectorLegacy(): useComponentCollectorLegacy.ReturnType;
//#endregion
//#region src/component/component-definition.d.ts
declare function isValidComponentDefinition(context: RuleContext, node: AST.TSESTreeFunction, hint: bigint): boolean;
//#endregion
//#region src/component/component-hierarchy.d.ts
/**
 * Determines whether inside `createElement`'s children.
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if the node is inside createElement's children
 */
declare function isChildrenOfCreateElement(context: RuleContext, node: TSESTree.Node): boolean;
/**
 * Check whether given node is declared inside class component's render block
 * ```tsx
 * class Component extends React.Component {
 *   render() {
 *     class NestedClassComponent extends React.Component {
 *      render() { return <div />; }
 *     }
 *     const nestedFunctionComponent = () => <div />;
 *  }
 * }
 * ```
 * @param node The AST node being checked
 * @returns `true` if node is inside class component's render block, `false` if not
 */
declare function isInsideRenderMethod(node: TSESTree.Node): boolean;
declare function isFunctionOfComponentDidMount(node: TSESTree.Node): boolean;
declare function isFunctionOfComponentWillUnmount(node: TSESTree.Node): boolean;
/**
 * Check whether given node is a function of a render method of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   renderHeader = () => <div />;
 *   renderFooter = () => <div />;
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isFunctionOfRenderMethod(node: AST.TSESTreeFunction): boolean;
//#endregion
//#region src/component/component-id.d.ts
declare function getFunctionComponentId(context: RuleContext, node: AST.TSESTreeFunction): TSESTree.Identifier | TSESTree.Identifier[] | unit;
//#endregion
//#region src/component/component-init-path.d.ts
declare function getComponentFlagFromInitPath(initPath: FunctionComponent["initPath"]): bigint;
//#endregion
//#region src/component/component-is.d.ts
/**
 * Check if a node is a React class component
 * @param node The AST node to check
 * @returns `true` if the node is a class component, `false` otherwise
 */
declare function isClassComponent(node: TSESTree.Node): node is AST.TSESTreeClass;
/**
 * Check if a node is a React PureComponent
 * @param node The AST node to check
 * @returns `true` if the node is a pure component, `false` otherwise
 */
declare function isPureComponent(node: TSESTree.Node): boolean;
//#endregion
//#region src/component/component-kind.d.ts
type ComponentKind = "classComponent" | "functionComponent";
//#endregion
//#region src/component/component-lifecycle.d.ts
declare function isComponentDidCatch(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentDidMount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentDidUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillMount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillReceiveProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillUnmount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetChildContext(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDefaultProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetInitialState(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetSnapshotBeforeUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isShouldComponentUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isUnsafeComponentWillMount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isUnsafeComponentWillReceiveProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isUnsafeComponentWillUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDerivedStateFromProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDerivedStateFromError(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
//#endregion
//#region src/component/component-name.d.ts
declare function isComponentName(name: string): boolean;
declare function isComponentNameLoose(name: string): boolean;
declare function getComponentNameFromId(id: TSESTree.Identifier | TSESTree.Identifier[] | unit): string | undefined;
declare function hasNoneOrLooseComponentName(context: RuleContext, fn: AST.TSESTreeFunction): boolean;
//#endregion
//#region src/component/component-render.d.ts
/**
 * Check whether given node is a render function of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   render() {
 *    return <div />;
 *  }
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderLike(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
/**
 * Check whether given node is a function of a render function of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   render = () => <div />;
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isFunctionOfRender(node: AST.TSESTreeFunction): boolean;
//#endregion
//#region src/component/component-render-method.d.ts
/**
 * Check whether given node is a render method of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   renderHeader = () => <div />;
 *   renderFooter = () => <div />;
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderMethodLike(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
//#endregion
//#region src/component/component-render-prop.d.ts
/**
 * Unsafe check whether given node is a render function
 * ```tsx
 * const renderRow = () => <div />
 * `                 ^^^^^^^^^^^^`
 * _ = <Component renderRow={() => <div />} />
 * `                         ^^^^^^^^^^^^^   `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderFunctionLoose(context: RuleContext, node: AST.TSESTreeFunction): boolean;
/**
 * Unsafe check whether given JSXAttribute is a render prop
 * ```tsx
 * _ = <Component renderRow={() => <div />} />
 * `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render prop, `false` if not
 */
declare function isRenderPropLoose(context: RuleContext, node: TSESTree.JSXAttribute): boolean;
/**
 * Unsafe check whether given node is declared directly inside a render property
 * ```tsx
 * const rows = { render: () => <div /> }
 * `                      ^^^^^^^^^^^^^ `
 * _ = <Component rows={ [{ render: () => <div /> }] } />
 * `                                ^^^^^^^^^^^^^       `
 *  ```
 * @internal
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render property, `false` if not
 */
declare function isDirectValueOfRenderPropertyLoose(node: TSESTree.Node): boolean;
/**
 * Unsafe check whether given node is declared inside a render prop
 * ```tsx
 * _ = <Component renderRow={"node"} />
 * `                         ^^^^^^   `
 * _ = <Component rows={ [{ render: "node" }] } />
 * `                                ^^^^^^       `
 * ```
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render prop, `false` if not
 */
declare function isDeclaredInRenderPropLoose(node: TSESTree.Node): boolean;
//#endregion
//#region src/component/component-state.d.ts
type ComponentStateKind = "actionState" | "state";
declare function isThisSetState(node: TSESTree.CallExpression): boolean;
declare function isAssignmentToThisState(node: TSESTree.AssignmentExpression): boolean;
//#endregion
//#region src/component/component-wrapper.d.ts
/**
 * Check if the node is a call expression for a component wrapper
 * @param context The ESLint rule context
 * @param node The node to check
 * @returns `true` if the node is a call expression for a component wrapper
 */
declare function isComponentWrapperCall(context: RuleContext, node: TSESTree.Node): boolean;
/**
 * Check if the node is a call expression for a component wrapper loosely
 * @param context The ESLint rule context
 * @param node The node to check
 * @returns `true` if the node is a call expression for a component wrapper loosely
 */
declare function isComponentWrapperCallLoose(context: RuleContext, node: TSESTree.Node): boolean;
//#endregion
//#region src/effect/effect-kind.d.ts
type EffectKind = "useEffect" | "useLayoutEffect" | "useInsertionEffect";
//#endregion
//#region src/hook/hook-semantic-node.d.ts
interface Hook extends SemanticNode {
  id: TSESTree.Identifier | unit;
  node: AST.TSESTreeFunction;
  name: string;
  hookCalls: TSESTree.CallExpression[];
}
//#endregion
//#region src/hook/hook-collector.d.ts
declare namespace useHookCollector {
  type ReturnType = {
    ctx: {
      getAllHooks(node: TSESTree$1.Program): Map<string, Hook>;
    };
    listeners: ESLintUtils.RuleListener;
  };
}
declare function useHookCollector(): useHookCollector.ReturnType;
//#endregion
//#region src/hook/hook-hierarchy.d.ts
declare function isFunctionOfUseEffectSetup(node: TSESTree.Node | unit): boolean;
declare function isFunctionOfUseEffectCleanup(node: TSESTree.Node | unit): boolean;
//#endregion
//#region src/hook/hook-is.d.ts
declare function isReactHook(node: AST.TSESTreeFunction | unit): boolean;
/**
 * Check if the given node is a React Hook call by its name.
 * @param node The node to check.
 * @returns `true` if the node is a React Hook call, `false` otherwise.
 */
declare function isReactHookCall(node: TSESTree.Node | unit): boolean;
declare function isReactHookCallWithName(context: RuleContext, node: TSESTree.Node | unit): (name: string) => boolean;
declare function isReactHookCallWithNameLoose(node: TSESTree.Node | unit): (name: string) => boolean;
declare function isReactHookCallWithNameAlias(context: RuleContext, name: string, alias?: unit | string[]): (node: TSESTree.CallExpression) => boolean;
declare function isUseEffectCallLoose(node: TSESTree.Node | unit): boolean;
declare const isUseCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseActionStateCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseCallbackCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseContextCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseDebugValueCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseDeferredValueCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseEffectCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseFormStatusCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseIdCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseImperativeHandleCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseInsertionEffectCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseLayoutEffectCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseMemoCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseOptimisticCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseReducerCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseRefCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseStateCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseSyncExternalStoreCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseTransitionCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
//#endregion
//#region src/hook/hook-kind.d.ts
type HookKind = "custom" | "useActionState" | "useCallback" | "useContext" | "useDebugValue" | "useDeferredValue" | "useEffect" | "useId" | "useImperativeHandle" | "useInsertionEffect" | "useLayoutEffect" | "useMemo" | "useOptimistic" | "useReducer" | "useRef" | "useState" | "useSyncExternalStore" | "useTransition";
//#endregion
//#region src/hook/hook-name.d.ts
/**
 * Catch all identifiers that begin with "use" followed by an uppercase Latin
 * character to exclude identifiers like "user".
 * @param name The name of the identifier to check.
 * @see https://github.com/facebook/react/blob/1d6c8168db1d82713202e842df3167787ffa00ed/packages/eslint-plugin-react-hooks/src/rules/RulesOfHooks.ts#L16
 */
declare function isReactHookName(name: string): boolean;
//#endregion
//#region src/jsx/jsx-attribute.d.ts
/**
 * Get the JSX attribute node with the given name
 * @param context The ESLint rule context
 * @param name The name of the attribute
 * @param attributes The attributes to search
 * @param initialScope The initial scope to use for variable resolution
 * @returns The JSX attribute node or undefined
 */
declare function getAttribute(context: RuleContext, name: string, attributes: (TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute)[], initialScope?: Scope): TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute | unit;
//#endregion
//#region src/jsx/jsx-attribute-name.d.ts
/**
 * Get the stringified name of a JSX attribute
 * @param context The ESLint rule context
 * @param node The JSX attribute node
 * @returns The name of the attribute
 */
declare function getAttributeName(context: RuleContext, node: TSESTree$1.JSXAttribute): string;
//#endregion
//#region src/jsx/jsx-attribute-value.d.ts
/**
 * Get a StaticValue of the attribute value
 * @param context The rule context
 * @param node The JSX attribute node
 * @param name The name of the attribute
 * @returns The StaticValue of the attribute value
 */
declare function getAttributeValue(context: RuleContext, node: TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute, name: string): Exclude<VAR.LazyValue, {
  kind: "lazy";
}>;
//#endregion
//#region src/jsx/jsx-detection-hint.d.ts
type JSXDetectionHint = bigint;
declare const JSXDetectionHint: {
  readonly None: 0n;
  readonly SkipUndefined: bigint;
  readonly SkipNullLiteral: bigint;
  readonly SkipBooleanLiteral: bigint;
  readonly SkipStringLiteral: bigint;
  readonly SkipNumberLiteral: bigint;
  readonly SkipBigIntLiteral: bigint;
  readonly SkipEmptyArray: bigint;
  readonly SkipCreateElement: bigint;
  readonly StrictArray: bigint;
  readonly StrictLogical: bigint;
  readonly StrictConditional: bigint;
};
declare const DEFAULT_JSX_DETECTION_HINT: bigint;
//#endregion
//#region src/jsx/jsx-detection.d.ts
/**
 * Check if a node is a `JSXText` or a `Literal` node
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXText` or a `Literal` node
 */
declare function isJsxText(node: TSESTree$1.Node | null | unit): node is TSESTree$1.JSXText | TSESTree$1.Literal;
/**
 * Heuristic decision to determine if a node is a JSX-like node.
 * @param code The sourceCode object
 * @param code.getScope The function to get the scope of a node
 * @param node The AST node to check
 * @param hint The `JSXDetectionHint` to use
 * @returns boolean
 */
declare function isJsxLike(code: {
  getScope: (node: TSESTree$1.Node) => Scope;
}, node: TSESTree$1.Node | unit | null, hint?: JSXDetectionHint): boolean;
//#endregion
//#region src/jsx/jsx-element-type.d.ts
/**
 * Get the stringified type of a JSX element
 * @param context The ESLint rule context
 * @param node The JSX element node
 * @returns The type of the element
 */
declare function getElementType(context: RuleContext, node: TSESTree.JSXElement | TSESTree.JSXFragment): string;
//#endregion
//#region src/jsx/jsx-has.d.ts
declare function hasAttribute(context: RuleContext, name: string, attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
declare function hasAnyAttribute(context: RuleContext, names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
declare function hasEveryAttribute(context: RuleContext, names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
//#endregion
//#region src/jsx/jsx-hierarchy.d.ts
/**
 * Find the parent JSX attribute node of a node
 * @param node The node to find the parent attribute of
 * @param test The test to apply to the parent attribute
 * @returns The parent attribute node or undefined
 */
declare function findParentAttribute(node: TSESTree.Node, test?: (node: TSESTree.JSXAttribute) => boolean): TSESTree.JSXAttribute | unit;
//#endregion
//#region src/jsx/jsx-is.d.ts
declare function isHostElement(context: RuleContext, node: TSESTree.Node): boolean;
declare function isKeyedElement(context: RuleContext, node: TSESTree.Node, initialScope?: Scope): boolean;
declare function isFragmentElement(context: RuleContext, node: TSESTree.Node | null | unit, allowJSXFragment?: false): node is TSESTree.JSXElement;
declare function isFragmentElement(context: RuleContext, node: TSESTree.Node | null | unit, allowJSXFragment?: true): node is TSESTree.JSXElement | TSESTree.JSXFragment;
//#endregion
//#region src/jsx/jsx-stringify.d.ts
/**
 * Get the stringified representation of a JSX node
 * @param node The JSX node
 * @returns The stringified representation
 */
declare function stringifyJsx(node: TSESTree$1.JSXIdentifier | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXClosingElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXText): string;
//#endregion
//#region src/utils/get-instance-id.d.ts
/** @internal */
declare function getInstanceId(node: TSESTree.Node, prev?: TSESTree.Node): TSESTree.ArrayExpression | TSESTree.ArrayPattern | TSESTree.ArrowFunctionExpression | TSESTree.AssignmentExpression | TSESTree.AwaitExpression | TSESTree.BinaryExpression | TSESTree.CallExpression | TSESTree.ChainExpression | TSESTree.ClassExpression | TSESTree.ConditionalExpression | TSESTree.FunctionExpression | TSESTree.Identifier | TSESTree.ImportExpression | TSESTree.JSXElement | TSESTree.JSXFragment | TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.LogicalExpression | TSESTree.MemberExpressionComputedName | TSESTree.MemberExpressionNonComputedName | TSESTree.MetaProperty | TSESTree.NewExpression | TSESTree.ObjectExpression | TSESTree.ObjectPattern | TSESTree.PrivateIdentifier | TSESTree.SequenceExpression | TSESTree.Super | TSESTree.TaggedTemplateExpression | TSESTree.TemplateLiteral | TSESTree.ThisExpression | TSESTree.TSAsExpression | TSESTree.TSInstantiationExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion | TSESTree.UnaryExpression | TSESTree.UpdateExpression | TSESTree.YieldExpression | undefined;
//#endregion
//#region src/utils/is-from-react.d.ts
/**
 * Check if an identifier name is initialized from react
 * @param name The top-level identifier's name
 * @param importSource The import source to check against
 * @param initialScope Initial scope to search for the identifier
 * @returns Whether the identifier name is initialized from react
 * @internal
 */
declare function isInitializedFromReact(name: string, importSource: string, initialScope: Scope): boolean;
//#endregion
//#region src/utils/is-instance-id-equal.d.ts
/** @internal */
declare function isInstanceIdEqual(context: RuleContext, a: TSESTree.Node, b: TSESTree.Node): boolean;
//#endregion
//#region src/utils/is-react-api.d.ts
declare namespace isReactAPI {
  type ReturnType = {
    (context: RuleContext, node: unit | null | TSESTree.Node): node is TSESTree.Identifier | TSESTree.MemberExpression;
    (context: RuleContext): (node: unit | null | TSESTree.Node) => node is TSESTree.MemberExpression | TSESTree.Identifier;
  };
}
declare function isReactAPI(api: string): isReactAPI.ReturnType;
declare namespace isReactAPICall {
  type ReturnType = {
    (context: RuleContext, node: unit | null | TSESTree.Node): node is TSESTree.CallExpression;
    (context: RuleContext): (node: unit | null | TSESTree.Node) => node is TSESTree.CallExpression;
  };
}
declare function isReactAPICall(api: string): isReactAPICall.ReturnType;
declare const isCaptureOwnerStack: isReactAPI.ReturnType;
declare const isChildrenCount: isReactAPI.ReturnType;
declare const isChildrenForEach: isReactAPI.ReturnType;
declare const isChildrenMap: isReactAPI.ReturnType;
declare const isChildrenOnly: isReactAPI.ReturnType;
declare const isChildrenToArray: isReactAPI.ReturnType;
declare const isCloneElement: isReactAPI.ReturnType;
declare const isCreateContext: isReactAPI.ReturnType;
declare const isCreateElement: isReactAPI.ReturnType;
declare const isCreateRef: isReactAPI.ReturnType;
declare const isForwardRef: isReactAPI.ReturnType;
declare const isMemo: isReactAPI.ReturnType;
declare const isLazy: isReactAPI.ReturnType;
declare const isCaptureOwnerStackCall: isReactAPICall.ReturnType;
declare const isChildrenCountCall: isReactAPICall.ReturnType;
declare const isChildrenForEachCall: isReactAPICall.ReturnType;
declare const isChildrenMapCall: isReactAPICall.ReturnType;
declare const isChildrenOnlyCall: isReactAPICall.ReturnType;
declare const isChildrenToArrayCall: isReactAPICall.ReturnType;
declare const isCloneElementCall: isReactAPICall.ReturnType;
declare const isCreateContextCall: isReactAPICall.ReturnType;
declare const isCreateElementCall: isReactAPICall.ReturnType;
declare const isCreateRefCall: isReactAPICall.ReturnType;
declare const isForwardRefCall: isReactAPICall.ReturnType;
declare const isMemoCall: isReactAPICall.ReturnType;
declare const isLazyCall: isReactAPICall.ReturnType;
//#endregion
export { ClassComponent, Component, ComponentDetectionHint, ComponentEffectPhaseKind, ComponentFlag, ComponentKind, ComponentLifecyclePhaseKind, ComponentPhaseKind, ComponentPhaseRelevance, ComponentStateKind, DEFAULT_COMPONENT_DETECTION_HINT, DEFAULT_JSX_DETECTION_HINT, EffectKind, FunctionComponent, Hook, HookKind, JSXDetectionHint, SemanticEntry, SemanticNode, findParentAttribute, getAttribute, getAttributeName, getAttributeValue, getComponentFlagFromInitPath, getComponentNameFromId, getElementType, getFunctionComponentId, getInstanceId, hasAnyAttribute, hasAttribute, hasEveryAttribute, hasNoneOrLooseComponentName, isAssignmentToThisState, isCaptureOwnerStack, isCaptureOwnerStackCall, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCloneElement, isCloneElementCall, isComponentDidCatch, isComponentDidMount, isComponentDidUpdate, isComponentName, isComponentNameLoose, isComponentWillMount, isComponentWillReceiveProps, isComponentWillUnmount, isComponentWillUpdate, isComponentWrapperCall, isComponentWrapperCallLoose, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFunctionOfComponentDidMount, isFunctionOfComponentWillUnmount, isFunctionOfRender, isFunctionOfRenderMethod, isFunctionOfUseEffectCleanup, isFunctionOfUseEffectSetup, isGetChildContext, isGetDefaultProps, isGetDerivedStateFromError, isGetDerivedStateFromProps, isGetInitialState, isGetSnapshotBeforeUpdate, isHostElement, isInitializedFromReact, isInsideRenderMethod, isInstanceIdEqual, isInversePhase, isJsxLike, isJsxText, isKeyedElement, isLazy, isLazyCall, isMemo, isMemoCall, isPureComponent, isReactAPI, isReactAPICall, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookCallWithNameLoose, isReactHookName, isRenderFunctionLoose, isRenderLike, isRenderMethodLike, isRenderPropLoose, isShouldComponentUpdate, isThisSetState, isUnsafeComponentWillMount, isUnsafeComponentWillReceiveProps, isUnsafeComponentWillUpdate, isUseActionStateCall, isUseCall, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectCallLoose, isUseFormStatusCall, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseOptimisticCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, isValidComponentDefinition, stringifyJsx, useComponentCollector, useComponentCollectorLegacy, useHookCollector };