//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (all) => {
	let target = {};
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let __eslint_react_eff = require("@eslint-react/eff");
__eslint_react_eff = __toESM(__eslint_react_eff);
let zod_v4 = require("zod/v4");
zod_v4 = __toESM(zod_v4);

//#region src/RegExp.ts
var RegExp_exports = __export({
	ANNOTATION_JSX: () => ANNOTATION_JSX,
	ANNOTATION_JSX_FRAG: () => ANNOTATION_JSX_FRAG,
	ANNOTATION_JSX_IMPORT_SOURCE: () => ANNOTATION_JSX_IMPORT_SOURCE,
	ANNOTATION_JSX_RUNTIME: () => ANNOTATION_JSX_RUNTIME,
	CAMEL_CASE: () => CAMEL_CASE,
	COMPONENT_NAME: () => COMPONENT_NAME,
	COMPONENT_NAME_LOOSE: () => COMPONENT_NAME_LOOSE,
	CONSTANT_CASE: () => CONSTANT_CASE,
	HOOK_NAME: () => HOOK_NAME,
	HTML_TAG: () => HTML_TAG,
	JAVASCRIPT_PROTOCOL: () => JAVASCRIPT_PROTOCOL,
	JS_EXT: () => JS_EXT,
	JS_IDENTIFIER: () => JS_IDENTIFIER,
	KEBAB_CASE: () => KEBAB_CASE,
	PASCAL_CASE: () => PASCAL_CASE,
	REGEXP_STR: () => REGEXP_STR,
	SNAKE_CASE: () => SNAKE_CASE,
	TS_EXT: () => TS_EXT,
	isRegExp: () => isRegExp,
	toRegExp: () => toRegExp
});
/**
* Regular expressions for matching a HTML tag name
*/
const HTML_TAG = /^[a-z][^-]*$/u;
/**
* Regular expression for matching a TypeScript file extension.
*/
const TS_EXT = /^[cm]?tsx?$/u;
/**
* Regular expression for matching a JavaScript file extension.
*/
const JS_EXT = /^[cm]?jsx?$/u;
/**
* Regular expression for matching a PascalCase string.
*/
const PASCAL_CASE = /^[A-Z][\dA-Za-z]*$/u;
/**
* Regular expression for matching a camelCase string.
*/
const CAMEL_CASE = /^[a-z][\dA-Za-z]*$/u;
/**
* Regular expression for matching a kebab-case string.
*/
const KEBAB_CASE = /^[a-z][\d\-a-z]*$/u;
/**
* Regular expression for matching a snake_case string.
*/
const SNAKE_CASE = /^[a-z][\d_a-z]*$/u;
/**
* Regular expression for matching a CONSTANT_CASE string.
*/
const CONSTANT_CASE = /^[A-Z][\d_A-Z]*$/u;
const JAVASCRIPT_PROTOCOL = /^[\u0000-\u001F ]*j[\t\n\r]*a[\t\n\r]*v[\t\n\r]*a[\t\n\r]*s[\t\n\r]*c[\t\n\r]*r[\t\n\r]*i[\t\n\r]*p[\t\n\r]*t[\t\n\r]*:/iu;
/**
* Regular expression for matching a valid JavaScript identifier.
*/
const JS_IDENTIFIER = /^[_$a-z][\w$]*$/i;
/**
* Regular expression for matching a RegExp string.
*/
const REGEXP_STR = /^\/(.+)\/([A-Za-z]*)$/u;
/**
* Regular expression for matching a `@jsx` annotation comment.
*/
const ANNOTATION_JSX = /@jsx\s+(\S+)/u;
/**
* Regular expression for matching a `@jsxFrag` annotation comment.
*/
const ANNOTATION_JSX_FRAG = /@jsxFrag\s+(\S+)/u;
/**
* Regular expression for matching a `@jsxRuntime` annotation comment.
*/
const ANNOTATION_JSX_RUNTIME = /@jsxRuntime\s+(\S+)/u;
/**
* Regular expression for matching a `@jsxImportSource` annotation comment.
*/
const ANNOTATION_JSX_IMPORT_SOURCE = /@jsxImportSource\s+(\S+)/u;
/**
* Regular expression for matching a React component name.
*/
const COMPONENT_NAME = /^[A-Z]/u;
/**
* Regular expression for matching a React component name (loose).
*/
const COMPONENT_NAME_LOOSE = /^_?[A-Z]/u;
/**
* Regular expression for matching a React Hook name.
*/
const HOOK_NAME = /^use/u;
/**
* Convert a string to the `RegExp`.
* Normal strings (e.g. `"foo"`) is converted to `/^foo$/` of `RegExp`.
* Strings like `"/^foo/i"` are converted to `/^foo/i` of `RegExp`.
* @see https://github.com/sveltejs/eslint-plugin-svelte/blob/main/packages/eslint-plugin-svelte/src/utils/regexp.ts
* @param string The string to convert.
* @returns Returns the `RegExp`.
*/
function toRegExp(string) {
	const [, pattern, flags = "u"] = REGEXP_STR.exec(string) ?? [];
	if (pattern != null) return new RegExp(pattern, flags);
	return { test: (s) => s === string };
}
/**
* Checks whether given string is regexp string
* @param string The string to check
* @returns boolean
*/
function isRegExp(string) {
	return REGEXP_STR.test(string);
}

//#endregion
//#region src/JsxConfig/JsxConfig.ts
const JsxEmit = {
	None: 0,
	Preserve: 1,
	React: 2,
	ReactNative: 3,
	ReactJSX: 4,
	ReactJSXDev: 5
};
/**
* Create a JsxConfig object
* @returns JsxConfig
*/
function make$2() {
	return {};
}
/**
* Get JsxConfig from RuleContext
* @param context The RuleContext
* @returns JsxConfig
*/
function getFromContext$1(context) {
	const options = context.sourceCode.parserServices?.program?.getCompilerOptions() ?? {};
	return {
		jsx: options.jsx ?? JsxEmit.ReactJSX,
		jsxFactory: options.jsxFactory ?? "React.createElement",
		jsxFragmentFactory: options.jsxFragmentFactory ?? "React.Fragment",
		jsxImportSource: options.jsxImportSource ?? "react",
		reactNamespace: options.reactNamespace ?? "React"
	};
}
const cache = /* @__PURE__ */ new WeakMap();
/**
* Get JsxConfig from annotation
* @param context The RuleContext
* @returns JsxConfig
*/
function getFromAnnotation(context) {
	return (0, __eslint_react_eff.getOrElseUpdate)(cache, context.sourceCode, () => {
		const options = make$2();
		if (!context.sourceCode.text.includes("@jsx")) return options;
		let jsx, jsxFrag, jsxRuntime, jsxImportSource;
		for (const comment of context.sourceCode.getAllComments().reverse()) {
			const value = comment.value;
			jsx ??= value.match(ANNOTATION_JSX)?.[1];
			jsxFrag ??= value.match(ANNOTATION_JSX_FRAG)?.[1];
			jsxRuntime ??= value.match(ANNOTATION_JSX_RUNTIME)?.[1];
			jsxImportSource ??= value.match(ANNOTATION_JSX_IMPORT_SOURCE)?.[1];
		}
		if (jsx != null) options.jsxFactory = jsx;
		if (jsxFrag != null) options.jsxFragmentFactory = jsxFrag;
		if (jsxRuntime != null) options.jsx = jsxRuntime === "classic" ? JsxEmit.React : JsxEmit.ReactJSX;
		if (jsxImportSource != null) options.jsxImportSource = jsxImportSource;
		return options;
	});
}

//#endregion
//#region src/JsxConfig/index.ts
var JsxConfig_exports = __export({
	JsxEmit: () => JsxEmit,
	getFromAnnotation: () => getFromAnnotation,
	getFromContext: () => getFromContext$1,
	make: () => make$2
});

//#endregion
//#region src/LanguagePreference/LanguagePreference.ts
/**
* Get a copy of the default LanguagePreference.
*/
function make$1() {
	return {
		indentStyle: "space",
		indentWidth: 2,
		jsxQuoteStyle: "double",
		quoteStyle: "single",
		semicolons: "always",
		trailingCommas: "all"
	};
}
/**
* A default LanguagePreference object.
*/
const defaultLanguagePreference = make$1();
function getFromContext() {
	throw new Error("getFromContext is not implemented");
}

//#endregion
//#region src/LanguagePreference/LanguagePreferenceSchema.ts
/**
* @internal
*/
const LanguagePreferenceSchema = zod_v4.z.object({
	indentStyle: zod_v4.z.optional(zod_v4.z.union([zod_v4.z.literal("tab"), zod_v4.z.literal("space")])),
	indentWidth: zod_v4.z.optional(zod_v4.z.number()),
	quoteStyle: zod_v4.z.optional(zod_v4.z.union([zod_v4.z.literal("single"), zod_v4.z.literal("double")])),
	semicolons: zod_v4.z.optional(zod_v4.z.union([zod_v4.z.literal("always"), zod_v4.z.literal("asNeeded")])),
	trailingCommas: zod_v4.z.optional(zod_v4.z.union([
		zod_v4.z.literal("all"),
		zod_v4.z.literal("es5"),
		zod_v4.z.literal("none")
	])),
	jsxQuoteStyle: zod_v4.z.optional(zod_v4.z.union([zod_v4.z.literal("single"), zod_v4.z.literal("double")]))
}, {});

//#endregion
//#region src/LanguagePreference/index.ts
var LanguagePreference_exports = __export({
	LanguagePreferenceSchema: () => LanguagePreferenceSchema,
	defaultLanguagePreference: () => defaultLanguagePreference,
	getFromContext: () => getFromContext,
	make: () => make$1
});

//#endregion
//#region src/Reporter.ts
var Reporter_exports = __export({
	make: () => make,
	send: () => send,
	sendOrElse: () => sendOrElse
});
const send = (0, __eslint_react_eff.dual)(2, (context, descriptor) => {
	if (descriptor == null) return;
	return context.report(descriptor);
});
const sendOrElse = (0, __eslint_react_eff.dual)(3, (context, descriptor, cb) => {
	if (descriptor == null) return cb();
	return context.report(descriptor);
});
function make(context) {
	return {
		send: (...args) => send(context, ...args),
		sendOrElse: (...args) => sendOrElse(context, ...args)
	};
}

//#endregion
//#region src/Selector.ts
var Selector_exports = __export({
	DISPLAY_NAME_ASSIGNMENT_EXPRESSION: () => DISPLAY_NAME_ASSIGNMENT_EXPRESSION,
	IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION: () => IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION,
	OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR: () => OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR
});
const IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION = "ArrowFunctionExpression[body.type!='BlockStatement']";
const OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR = [
	"VariableDeclarator",
	"[id.type='ObjectPattern']",
	"[init.type='Identifier']"
].join("");
const DISPLAY_NAME_ASSIGNMENT_EXPRESSION = [
	"AssignmentExpression",
	"[operator='=']",
	"[left.type='MemberExpression']",
	"[left.property.name='displayName']"
].join("");

//#endregion
Object.defineProperty(exports, 'JsxConfig', {
  enumerable: true,
  get: function () {
    return JsxConfig_exports;
  }
});
Object.defineProperty(exports, 'LanguagePreference', {
  enumerable: true,
  get: function () {
    return LanguagePreference_exports;
  }
});
Object.defineProperty(exports, 'RegExp', {
  enumerable: true,
  get: function () {
    return RegExp_exports;
  }
});
Object.defineProperty(exports, 'Reporter', {
  enumerable: true,
  get: function () {
    return Reporter_exports;
  }
});
Object.defineProperty(exports, 'Selector', {
  enumerable: true,
  get: function () {
    return Selector_exports;
  }
});