import { unit } from "@eslint-react/eff";
import { z } from "zod/v4";
import * as typescript0 from "typescript";
import * as tseslint from "@typescript-eslint/utils/ts-eslint";
import { ReportDescriptor } from "@typescript-eslint/utils/ts-eslint";
import { TSESTree } from "@typescript-eslint/utils";

//#region src/types.d.ts
/**
 * Rule severity.
 * @since 0.0.1
 */
type SeverityName = "off" | "warn" | "error";
/**
 * The numeric severity level for a rule.
 *
 * - `0` means off.
 * - `1` means warn.
 * - `2` means error.
 */
type SeverityLevel = 0 | 1 | 2;
/**
 * The severity of a rule in a configuration.
 */
type Severity = SeverityName | SeverityLevel;
/**
 * Rule declaration.
 * @internal
 * @since 0.0.1
 */
type RuleConfig<RuleOptions extends unknown[] = unknown[]> = Severity | [Severity, ...Partial<RuleOptions>];
/**
 * Rule context.
 * @since 0.0.1
 */
type RuleContext<MessageIds extends string = string, Options extends readonly unknown[] = readonly unknown[]> = tseslint.RuleContext<MessageIds, Options>;
/**
 * Rule feature.
 * @since 1.20.0
 */
type RuleFeature = "CFG" | "DBG" | "FIX" | "MOD" | "TSC" | "EXP";
type RulePolicy = number;
type RuleSuggest<MessageIds extends string = string> = {
  messageId: MessageIds;
  data?: Record<string, unknown>;
  fix: tseslint.ReportFixFunction;
};
/**
 * A collection of settings.
 */
interface SettingsConfig {
  [key: string]: unknown;
}
interface CompatibleRule {
  meta: Record<string, any>;
  create: (...args: any[]) => any;
}
interface CompatiblePlugin {
  meta: {
    name: string;
    version: string;
  };
  rules: Record<string, CompatibleRule>;
}
interface CompatibleConfig {
  name?: string;
  rules?: Record<string, RuleConfig>;
  settings?: SettingsConfig;
}
//#endregion
//#region src/JsxConfig/JsxConfig.d.ts
declare const JsxEmit: {
  readonly None: 0;
  readonly Preserve: 1;
  readonly React: 2;
  readonly ReactNative: 3;
  readonly ReactJSX: 4;
  readonly ReactJSXDev: 5;
};
interface JsxConfig {
  jsx?: number;
  jsxFactory?: string;
  jsxFragmentFactory?: string;
  jsxImportSource?: string;
}
/**
 * Create a JsxConfig object
 * @returns JsxConfig
 */
declare function make$2(): JsxConfig;
/**
 * Get JsxConfig from RuleContext
 * @param context The RuleContext
 * @returns JsxConfig
 */
declare function getFromContext$1(context: RuleContext): {
  jsx: 4 | typescript0.JsxEmit;
  jsxFactory: string;
  jsxFragmentFactory: string;
  jsxImportSource: string;
  reactNamespace: string;
};
/**
 * Get JsxConfig from annotation
 * @param context The RuleContext
 * @returns JsxConfig
 */
declare function getFromAnnotation(context: RuleContext): JsxConfig;
declare namespace index_d_exports {
  export { JsxConfig, JsxEmit, getFromAnnotation, getFromContext$1 as getFromContext, make$2 as make };
}
//#endregion
//#region src/LanguagePreference/LanguagePreferenceSchema.d.ts
/**
 * @internal
 */
declare const LanguagePreferenceSchema: z.ZodObject<{
  indentStyle: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"tab">, z.ZodLiteral<"space">]>>;
  indentWidth: z.ZodOptional<z.ZodNumber>;
  quoteStyle: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"single">, z.ZodLiteral<"double">]>>;
  semicolons: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"always">, z.ZodLiteral<"asNeeded">]>>;
  trailingCommas: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"all">, z.ZodLiteral<"es5">, z.ZodLiteral<"none">]>>;
  jsxQuoteStyle: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"single">, z.ZodLiteral<"double">]>>;
}, z.core.$strip>;
//#endregion
//#region src/LanguagePreference/LanguagePreference.d.ts
/**
 * @internal
 */
type LanguagePreference = z.infer<typeof LanguagePreferenceSchema>;
/**
 * Get a copy of the default LanguagePreference.
 */
declare function make$1(): LanguagePreference;
/**
 * A default LanguagePreference object.
 */
declare const defaultLanguagePreference: {
  indentStyle?: "tab" | "space" | undefined;
  indentWidth?: number | undefined;
  quoteStyle?: "single" | "double" | undefined;
  semicolons?: "always" | "asNeeded" | undefined;
  trailingCommas?: "all" | "es5" | "none" | undefined;
  jsxQuoteStyle?: "single" | "double" | undefined;
};
declare function getFromContext(): void;
declare module "@typescript-eslint/utils/ts-eslint" {
  interface SharedConfigurationSettings {}
}
declare namespace index_d_exports$1 {
  export { LanguagePreference, LanguagePreferenceSchema, defaultLanguagePreference, getFromContext, make$1 as make };
}
declare namespace RegExp_d_exports {
  export { ANNOTATION_JSX, ANNOTATION_JSX_FRAG, ANNOTATION_JSX_IMPORT_SOURCE, ANNOTATION_JSX_RUNTIME, CAMEL_CASE, COMPONENT_NAME, COMPONENT_NAME_LOOSE, CONSTANT_CASE, HOOK_NAME, HTML_TAG, JAVASCRIPT_PROTOCOL, JS_EXT, JS_IDENTIFIER, KEBAB_CASE, PASCAL_CASE, REGEXP_STR, SNAKE_CASE, TS_EXT, isRegExp, toRegExp };
}
/**
 * Regular expressions for matching a HTML tag name
 */
declare const HTML_TAG: RegExp;
/**
 * Regular expression for matching a TypeScript file extension.
 */
declare const TS_EXT: RegExp;
/**
 * Regular expression for matching a JavaScript file extension.
 */
declare const JS_EXT: RegExp;
/**
 * Regular expression for matching a PascalCase string.
 */
declare const PASCAL_CASE: RegExp;
/**
 * Regular expression for matching a camelCase string.
 */
declare const CAMEL_CASE: RegExp;
/**
 * Regular expression for matching a kebab-case string.
 */
declare const KEBAB_CASE: RegExp;
/**
 * Regular expression for matching a snake_case string.
 */
declare const SNAKE_CASE: RegExp;
/**
 * Regular expression for matching a CONSTANT_CASE string.
 */
declare const CONSTANT_CASE: RegExp;
declare const JAVASCRIPT_PROTOCOL: RegExp;
/**
 * Regular expression for matching a valid JavaScript identifier.
 */
declare const JS_IDENTIFIER: RegExp;
/**
 * Regular expression for matching a RegExp string.
 */
declare const REGEXP_STR: RegExp;
/**
 * Regular expression for matching a `@jsx` annotation comment.
 */
declare const ANNOTATION_JSX: RegExp;
/**
 * Regular expression for matching a `@jsxFrag` annotation comment.
 */
declare const ANNOTATION_JSX_FRAG: RegExp;
/**
 * Regular expression for matching a `@jsxRuntime` annotation comment.
 */
declare const ANNOTATION_JSX_RUNTIME: RegExp;
/**
 * Regular expression for matching a `@jsxImportSource` annotation comment.
 */
declare const ANNOTATION_JSX_IMPORT_SOURCE: RegExp;
/**
 * Regular expression for matching a React component name.
 */
declare const COMPONENT_NAME: RegExp;
/**
 * Regular expression for matching a React component name (loose).
 */
declare const COMPONENT_NAME_LOOSE: RegExp;
/**
 * Regular expression for matching a React Hook name.
 */
declare const HOOK_NAME: RegExp;
/**
 * Convert a string to the `RegExp`.
 * Normal strings (e.g. `"foo"`) is converted to `/^foo$/` of `RegExp`.
 * Strings like `"/^foo/i"` are converted to `/^foo/i` of `RegExp`.
 * @see https://github.com/sveltejs/eslint-plugin-svelte/blob/main/packages/eslint-plugin-svelte/src/utils/regexp.ts
 * @param string The string to convert.
 * @returns Returns the `RegExp`.
 */
declare function toRegExp(string: string): {
  test(s: string): boolean;
};
/**
 * Checks whether given string is regexp string
 * @param string The string to check
 * @returns boolean
 */
declare function isRegExp(string: string): boolean;
declare namespace Reporter_d_exports {
  export { Reporter, make, send, sendOrElse };
}
interface Reporter<TMessageID extends string> {
  send: (descriptor: unit | null | ReportDescriptor<TMessageID>) => void;
  sendOrElse: <TElse>(descriptor: unit | null | ReportDescriptor<TMessageID>, cb: () => TElse) => unit | TElse;
}
declare const send: {
  <TMessageID extends string>(context: RuleContext, descriptor: unit | null | ReportDescriptor<TMessageID>): void;
  <TMessageID extends string>(context: RuleContext): (descriptor: unit | null | ReportDescriptor<TMessageID>) => void;
};
declare const sendOrElse: {
  <TMessageID extends string, TElse>(context: RuleContext, descriptor: unit | null | ReportDescriptor<TMessageID>, cb: () => TElse): unit | TElse;
  <TMessageID extends string, TElse>(context: RuleContext): (descriptor: unit | null | ReportDescriptor<TMessageID>) => (cb: () => TElse) => unit | TElse;
};
declare function make<TMessageID extends string>(context: RuleContext): Reporter<TMessageID>;
declare namespace Selector_d_exports {
  export { DISPLAY_NAME_ASSIGNMENT_EXPRESSION, DisplayNameAssignmentExpression, IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION, ImplicitReturnArrowFunctionExpression, OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR, ObjectDestructuringVariableDeclarator };
}
type ImplicitReturnArrowFunctionExpression = TSESTree.ArrowFunctionExpression & {
  body: TSESTree.Expression;
};
type ObjectDestructuringVariableDeclarator = TSESTree.VariableDeclarator & {
  id: TSESTree.ObjectPattern;
  init: TSESTree.Identifier;
};
type DisplayNameAssignmentExpression = TSESTree.AssignmentExpression & {
  type: "AssignmentExpression";
  left: TSESTree.MemberExpression & {
    property: TSESTree.Identifier & {
      name: "displayName";
    };
  };
  operator: "=";
  right: TSESTree.Literal;
};
declare const IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION = "ArrowFunctionExpression[body.type!='BlockStatement']";
declare const OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR: string;
declare const DISPLAY_NAME_ASSIGNMENT_EXPRESSION: string;
//#endregion
export { CompatibleConfig, CompatiblePlugin, CompatibleRule, index_d_exports as JsxConfig, index_d_exports$1 as LanguagePreference, RegExp_d_exports as RegExp, Reporter_d_exports as Reporter, RuleConfig, RuleContext, RuleFeature, RulePolicy, RuleSuggest, Selector_d_exports as Selector, SettingsConfig, Severity, SeverityLevel, SeverityName };