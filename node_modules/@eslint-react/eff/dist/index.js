
//#region src/index.ts
/**
* alias for `undefined`
*/
const unit = void 0;
function not(predicate) {
	return (data) => !predicate(data);
}
function or(a, b) {
	return (data) => a(data) || b(data);
}
/**
* A function that checks if the passed parameter is an Array and narrows its type accordingly.
*
* @param data - The variable to check.
* @returns True if the passed input is an Array, false otherwise. s
*/
function isArray(data) {
	return Array.isArray(data);
}
/**
* Checks if the given parameter is of type `"object"` via `typeof`, excluding `null`.
*
* @param data - The variable to be checked for being an object type.
* @returns The input type, narrowed to only objects.
*/
function isObject(data) {
	return typeof data === "object" && data !== null;
}
/**
* A function that checks if the passed parameter is truthy and narrows its type accordingly.
*
* @param data - The variable to check.
* @returns True if the passed input is truthy, false otherwise.
*/
function isTruthy(data) {
	return Boolean(data);
}
/**
* Tests if a value is a `function`.
*
* @param input - The value to test.
* @example
* ```ts
* import * as assert from "node:assert"
* import { isFunction } from "effect/Predicate"
*
* assert.deepStrictEqual(isFunction(isFunction), true)
* assert.deepStrictEqual(isFunction("function"), false)
* ```
*
* @since 1.0.0
*/
const isFunction = (input) => typeof input === "function";
/**
* Returns its argument.
* @param x - The value to return.
*/
function identity(x) {
	return x;
}
/**
* Creates a function that can be used in a data-last (aka `pipe`able) or
* data-first style.
*
* The first parameter to `dual` is either the arity of the uncurried function
* or a predicate that determines if the function is being used in a data-first
* or data-last style.
*
* Using the arity is the most common use case, but there are some cases where
* you may want to use a predicate. For example, if you have a function that
* takes an optional argument, you can use a predicate to determine if the
* function is being used in a data-first or data-last style.
*
* You can pass either the arity of the uncurried function or a predicate
* which determines if the function is being used in a data-first or
* data-last style.
*
* **Example** (Using arity to determine data-first or data-last style)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum = dual<
*   (that: number) => (self: number) => number,
*   (self: number, that: number) => number
* >(2, (self, that) => self + that)
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* **Example** (Using call signatures to define the overloads)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum: {
*   (that: number): (self: number) => number
*   (self: number, that: number): number
* } = dual(2, (self: number, that: number): number => self + that)
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* **Example** (Using a predicate to determine data-first or data-last style)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum = dual<
*   (that: number) => (self: number) => number,
*   (self: number, that: number) => number
* >(
*   (args) => args.length === 2,
*   (self, that) => self + that
* )
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* @param arity - The arity of the uncurried function or a predicate that determines if the function is being used in a data-first or data-last style.
* @param body - The function to be curried.
* @since 1.0.0
*/
const dual = function(arity, body) {
	if (typeof arity === "function") return function() {
		return arity(arguments) ? body.apply(this, arguments) : ((self) => body(self, ...arguments));
	};
	switch (arity) {
		case 0:
		case 1: throw new RangeError(`Invalid arity ${arity}`);
		case 2: return function(a, b) {
			if (arguments.length >= 2) return body(a, b);
			return function(self) {
				return body(self, a);
			};
		};
		case 3: return function(a, b, c) {
			if (arguments.length >= 3) return body(a, b, c);
			return function(self) {
				return body(self, a, b);
			};
		};
		default: return function() {
			if (arguments.length >= arity) return body.apply(this, arguments);
			const args = arguments;
			return function(self) {
				return body(self, ...args);
			};
		};
	}
};
/**
* Apply a function to a given value.
*
* @param a - The value to apply.
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, apply } from "effect/Function"
* import { length } from "effect/String"
*
* assert.deepStrictEqual(pipe(length, apply("hello")), 5)
* ```
*
* @since 1.0.0
*/
const apply = (a) => (self) => self(a);
/**
* Returns a function that always returns the same value.
* @param x - The value to return.
*/
function constant(x) {
	return () => x;
}
/**
* Do nothing and return void
*/
function constVoid() {}
/**
* Do nothing and return null
*/
function constNull() {
	return null;
}
/**
* Do nothing and return true
*/
function constTrue() {
	return true;
}
/**
* Do nothing and return false
*/
function constFalse() {
	return false;
}
/**
* Reverses the order of arguments for a curried function.
*
* @param f - The function to flip.
* @example
* ```ts
* import * as assert from "node:assert"
* import { flip } from "effect/Function"
*
* const f = (a: number) => (b: string) => a - b.length
*
* assert.deepStrictEqual(flip(f)('aaa')(2), -1)
* ```
*
* @since 1.0.0
*/
const flip = (f) => (...b) => (...a) => f(...a)(...b);
/**
* Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
* The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { compose } from "effect/Function"
*
* const increment = (n: number) => n + 1;
* const square = (n: number) => n * n;
*
* assert.strictEqual(compose(increment, square)(2), 9);
* ```
*
* @since 1.0.0
*/
const compose = dual(2, (ab, bc) => (a) => bc(ab(a)));
/**
* The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,
* meaning that it should be impossible for this code to be executed.
*
* This function is particularly useful when it's necessary to specify that certain cases are impossible.
*
* @param _ - The value of type `never` that is passed to the function.
* @since 1.0.0
*/
const absurd = (_) => {
	throw new Error("Called `absurd` function which should be uncallable");
};
/**
* Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.
*
* @param f - The function to be converted.
* @example
* ```ts
* import * as assert from "node:assert"
* import { tupled } from "effect/Function"
*
* const sumTupled = tupled((x: number, y: number): number => x + y)
*
* assert.deepStrictEqual(sumTupled([1, 2]), 3)
* ```
*
* @since 1.0.0
*/
const tupled = (f) => (a) => f(...a);
/**
* Inverse function of `tupled`
*
* @param f - The function to be converted.
* @example
* ```ts
* import * as assert from "node:assert"
* import { untupled } from "effect/Function"
*
* const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])
*
* assert.deepStrictEqual(getFirst(1, 2), 1)
* ```
*
* @since 1.0.0
*/
const untupled = (f) => (...a) => f(a);
/**
* @param self - The value to pipe.
* @param args - The functions to apply.
* @since 1.0.0
*/
const pipeArguments = (self, args) => {
	switch (args.length) {
		case 0: return self;
		case 1: return args[0](self);
		case 2: return args[1](args[0](self));
		case 3: return args[2](args[1](args[0](self)));
		case 4: return args[3](args[2](args[1](args[0](self))));
		case 5: return args[4](args[3](args[2](args[1](args[0](self)))));
		case 6: return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
		case 7: return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
		case 8: return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
		case 9: return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
		default: {
			let ret = self;
			for (let i = 0, len = args.length; i < len; i++) ret = args[i](ret);
			return ret;
		}
	}
};
function pipe(a, ...args) {
	return pipeArguments(a, args);
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
	switch (arguments.length) {
		case 1: return ab;
		case 2: return function() {
			return bc(ab.apply(this, arguments));
		};
		case 3: return function() {
			return cd(bc(ab.apply(this, arguments)));
		};
		case 4: return function() {
			return de(cd(bc(ab.apply(this, arguments))));
		};
		case 5: return function() {
			return ef(de(cd(bc(ab.apply(this, arguments)))));
		};
		case 6: return function() {
			return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
		};
		case 7: return function() {
			return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
		};
		case 8: return function() {
			return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
		};
		case 9: return function() {
			return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
		};
	}
}
function getOrElse(map, key, callback) {
	if (map.has(key)) return map.get(key);
	return callback();
}
function getOrElseUpdate(map, key, callback) {
	if (map.has(key)) return map.get(key);
	const value = callback();
	map.set(key, value);
	return value;
}
/**
* Attempts to add a value to a Set, but only if it doesn't already exist.
*
* @param set - The Set to potentially add to
* @param value - The value to add if it doesn't already exist in the Set
* @returns true if the value was added, false if it already existed
*/
function tryAddToSet(set, value) {
	if (!set.has(value)) {
		set.add(value);
		return true;
	}
	return false;
}

//#endregion
exports.absurd = absurd;
exports.apply = apply;
exports.compose = compose;
exports.constFalse = constFalse;
exports.constNull = constNull;
exports.constTrue = constTrue;
exports.constVoid = constVoid;
exports.constant = constant;
exports.dual = dual;
exports.flip = flip;
exports.flow = flow;
exports.getOrElse = getOrElse;
exports.getOrElseUpdate = getOrElseUpdate;
exports.identity = identity;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isObject = isObject;
exports.isTruthy = isTruthy;
exports.not = not;
exports.or = or;
exports.pipe = pipe;
exports.pipeArguments = pipeArguments;
exports.tryAddToSet = tryAddToSet;
exports.tupled = tupled;
exports.unit = unit;
exports.untupled = untupled;