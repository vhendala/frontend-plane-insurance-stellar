import { AST_NODE_TYPES, TSESTree } from "@typescript-eslint/types";
import { unit } from "@eslint-react/eff";
import { TSESTree as TSESTree$1 } from "@typescript-eslint/utils";

//#region src/ast-array-method.d.ts
declare function isArrayFromCall(node: TSESTree.Node, loose?: boolean): node is TSESTree.CallExpression;
declare function isArrayMapCall(node: TSESTree.Node, loose?: boolean): node is TSESTree.CallExpression;
//#endregion
//#region src/ast-array-method-callback.d.ts
declare function getArrayMethodCallbackIndexParamPosition(methodName: string): number;
//#endregion
//#region src/ast-node.d.ts
type TSESTreeFunction = TSESTree$1.ArrowFunctionExpression | TSESTree$1.FunctionDeclaration | TSESTree$1.FunctionExpression;
type TSESTreeFunctionType = TSESTree$1.TSCallSignatureDeclaration | TSESTree$1.TSConstructSignatureDeclaration | TSESTree$1.TSDeclareFunction | TSESTree$1.TSEmptyBodyFunctionExpression | TSESTree$1.TSFunctionType | TSESTree$1.TSMethodSignature | TSESTreeFunction;
type TSESTreeClass = TSESTree$1.ClassDeclaration | TSESTree$1.ClassExpression;
type TSESTreeMethodOrProperty = TSESTree$1.PropertyDefinition | TSESTree$1.MethodDefinition;
type TSESTreeLoop = TSESTree$1.DoWhileStatement | TSESTree$1.ForInStatement | TSESTree$1.ForOfStatement | TSESTree$1.ForStatement | TSESTree$1.WhileStatement;
type TSESTreeArrayTupleType = TSESTree$1.TSArrayType | TSESTree$1.TSTupleType;
type TSESTreeProperty = TSESTree$1.PropertyDefinition | TSESTree$1.TSIndexSignature | TSESTree$1.TSParameterProperty | TSESTree$1.TSPropertySignature;
type TSESTreeJSX = TSESTree$1.JSXAttribute | TSESTree$1.JSXChild | TSESTree$1.JSXClosingElement | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXElement | TSESTree$1.JSXEmptyExpression | TSESTree$1.JSXExpression | TSESTree$1.JSXExpressionContainer | TSESTree$1.JSXFragment | TSESTree$1.JSXIdentifier | TSESTree$1.JSXIdentifierToken | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXSpreadAttribute | TSESTree$1.JSXSpreadChild | TSESTree$1.JSXTagNameExpression | TSESTree$1.JSXText | TSESTree$1.JSXTextToken;
type TSESTreeDestructuringPattern = TSESTree$1.ArrayPattern | TSESTree$1.AssignmentPattern | TSESTree$1.ObjectPattern | TSESTree$1.RestElement;
type TSESTreeTypeDeclaration = TSESTree$1.TSInterfaceDeclaration | TSESTree$1.TSTypeAliasDeclaration;
type TSESTreeTypeExpression = TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion | TSESTree$1.TSInstantiationExpression;
type TSESTreeTypeAssertionExpression = TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion;
//#endregion
//#region src/ast-class-id.d.ts
/**
 * Gets class identifier from ClassDeclaration or ClassExpression
 * @param node The AST node to check
 * @returns class identifier or null
 */
declare function getClassId(node: TSESTreeClass): unit | TSESTree.Identifier;
//#endregion
//#region src/ast-expression.d.ts
/**
 * Recursively get the inner expression until it's not a TypeExpression
 * @param node - The node to get the expression from
 * @returns The inner expression
 */
declare function getJSExpression(node: TSESTree.Node): Exclude<TSESTree.Node, TSESTreeTypeExpression>;
declare function isThisExpression(node: TSESTree.Expression): boolean;
//#endregion
//#region src/ast-function-id.d.ts
declare function getFunctionId(node: TSESTree.Expression | TSESTreeFunction): unit | TSESTree.Identifier;
//#endregion
//#region src/ast-function-init-path.d.ts
type FunctionInitPath =
/**
 * function Comp() { return <div />; }
 */
readonly [TSESTree.FunctionDeclaration]
/**
 * const Comp = () => <div />;
 * const Comp = function () { return <div />; };
 */ | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTreeFunction]
/**
 * const Comp = React.memo(() => <div />);
 * const Comp = React.forwardRef(() => <div />);
 */ | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.CallExpression, TSESTreeFunction]
/**
 * const Comp = React.memo(React.forwardRef(() => <div />));
 */ | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.CallExpression, TSESTree.CallExpression, TSESTreeFunction]
/**
 * const Comps = {
 *  TopNav() { return <div />; },
 *  SidPanel: () => <div />,
 * }
 */ | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.ObjectExpression, TSESTree.Property, TSESTreeFunction]
/**
 * const Comps = {
 *  TopNav: React.memo(() => <div />),
 *  SidPanel: React.forwardRef(() => <div />),
 * }
 */ | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.ObjectExpression, TSESTree.Property, TSESTree.CallExpression, TSESTreeFunction]
/**
 * const Comps = {
 * TopNav: React.memo(React.forwardRef(() => <div />)),
 * SidPanel: React.forwardRef(React.memo(() => <div />)),
 * }
 */ | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.ObjectExpression, TSESTree.Property, TSESTree.CallExpression, TSESTree.CallExpression, TSESTreeFunction]
/**
 * class Comp {
 *   TopNav() { return <div />; }
 * }
 */ | readonly [TSESTree.ClassDeclaration, TSESTree.ClassBody, TSESTree.MethodDefinition, TSESTreeFunction]
/**
 * class Comp {
 *   TopNav = () => <div />;
 * }
 */ | readonly [TSESTree.ClassDeclaration, TSESTree.ClassBody, TSESTree.PropertyDefinition, TSESTreeFunction];
declare function getFunctionInitPath(node: TSESTreeFunction): unit | FunctionInitPath;
declare function hasCallInFunctionInitPath(callName: string, initPath: FunctionInitPath): boolean;
//#endregion
//#region src/ast-function-is.d.ts
declare function isEmptyFunction(node: TSESTreeFunction): boolean;
//#endregion
//#region src/ast-hierarchy.d.ts
/**
 * Find the parent node that satisfies the test function
 * @param node The AST node
 * @param test The test function
 * @returns The parent node that satisfies the test function or `_` if not found
 */
declare function findParentNode<A extends TSESTree.Node>(node: TSESTree.Node | unit, test: (n: TSESTree.Node) => n is A): A | unit;
/**
 * Find the parent node that satisfies the test function or `_` if not found
 * @param node The AST node
 * @param test The test function
 * @returns The parent node that satisfies the test function
 */
declare function findParentNode(node: TSESTree.Node | unit, test: (node: TSESTree.Node) => boolean): TSESTree.Node | unit;
/**
 * Get all nested identifiers in a expression like node
 * @param node The node to get the nested identifiers from
 * @returns All nested identifiers
 */
declare function getNestedIdentifiers(node: TSESTree.Node): readonly TSESTree.Identifier[];
/**
 * Gets the nested return statements in the node that are within the same function
 * @param node The AST node
 * @returns The nested return statements in the node
 */
declare function getNestedReturnStatements(node: TSESTree.Node): readonly TSESTree.ReturnStatement[];
/**
 * Get all nested expressions of type T in an expression like node
 * @param type The type of the expression to retrieve within the node
 * @returns A partially applied function bound to a predicate of type T. The returned function can be called passing a
 * node, and it will return an array of all nested expressions of type T.
 */
declare function getNestedExpressionsOfType<TNodeType extends AST_NODE_TYPES>(type: TNodeType): (node: TSESTree.Node) => Extract<TSESTree.Node, {
  type: TNodeType;
}>[];
/**
 * Get all nested new expressions in an expression like node
 * @param node The node to get the nested new expressions from
 * @returns All nested new expressions
 */
declare const getNestedNewExpressions: (node: TSESTree.Node) => TSESTree.NewExpression[];
/**
 * Get all nested call expressions in a expression like node
 * @param node The node to get the nested call expressions from
 * @returns All nested call expressions
 */
declare const getNestedCallExpressions: (node: TSESTree.Node) => TSESTree.CallExpression[];
//#endregion
//#region src/ast-is.d.ts
declare const is: <NodeType extends TSESTree.AST_NODE_TYPES>(nodeType: NodeType) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
  type: NodeType;
}>;
declare const isOneOf: <NodeTypes extends readonly TSESTree.AST_NODE_TYPES[]>(nodeTypes: NodeTypes) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
  type: NodeTypes[number];
}>;
declare const isFunction: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression;
declare const isFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression | TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunctionNoDeclare | TSESTree.TSDeclareFunctionWithDeclare | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName;
declare const isClass: (node: TSESTree.Node | null | undefined) => node is TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.ClassExpression;
declare const isMethodOrProperty: (node: TSESTree.Node | null | undefined) => node is TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName | TSESTree.PropertyDefinitionComputedName | TSESTree.PropertyDefinitionNonComputedName;
declare const isProperty: (node: TSESTree.Node | null | undefined) => node is TSESTree.PropertyDefinitionComputedName | TSESTree.PropertyDefinitionNonComputedName | TSESTree.TSIndexSignature | TSESTree.TSParameterProperty | TSESTree.TSPropertySignatureComputedName | TSESTree.TSPropertySignatureNonComputedName;
declare const isJSXElement: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXElement;
declare const isJSXFragment: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXFragment;
declare const isJSXTagNameExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXIdentifier | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName;
declare const isJSX: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXAttribute | TSESTree.JSXClosingElement | TSESTree.JSXClosingFragment | TSESTree.JSXElement | TSESTree.JSXEmptyExpression | TSESTree.JSXExpressionContainer | TSESTree.JSXFragment | TSESTree.JSXIdentifier | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName | TSESTree.JSXOpeningElement | TSESTree.JSXOpeningFragment | TSESTree.JSXSpreadAttribute | TSESTree.JSXSpreadChild | TSESTree.JSXText;
declare const isLoop: (node: TSESTree.Node | null | undefined) => node is TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;
declare const isTypeExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSAsExpression | TSESTree.TSInstantiationExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion;
declare const isTypeAssertionExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSAsExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion;
//#endregion
//#region src/ast-line.d.ts
/**
 * Check if a node is multiline
 * @param node The AST node to check
 * @returns  `true` if the node is multiline
 */
declare function isMultiLine(node: TSESTree.Node): boolean;
/**
 * Check if a node is a line break
 * @param node The AST node to check
 * @returns boolean
 */
declare function isLineBreak(node: TSESTree.Node): boolean;
//#endregion
//#region src/ast-literal-is.d.ts
declare function isLiteral(node: TSESTree.Node): node is TSESTree.Literal;
declare function isLiteral(node: TSESTree.Node, type: "boolean"): node is TSESTree.BooleanLiteral;
declare function isLiteral(node: TSESTree.Node, type: "null"): node is TSESTree.NullLiteral;
declare function isLiteral(node: TSESTree.Node, type: "number"): node is TSESTree.NumberLiteral;
declare function isLiteral(node: TSESTree.Node, type: "regexp"): node is TSESTree.RegExpLiteral;
declare function isLiteral(node: TSESTree.Node, type: "string"): node is TSESTree.StringLiteral;
//#endregion
//#region src/ast-node-equal.d.ts
/**
 * Determines whether node equals to another node
 * @param a node to compare
 * @param b node to compare
 * @returns `true` if node equal
 * @see https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/src/util/isNodeEqual.ts
 */
declare const isNodeEqual: {
  (a: TSESTree.Node): (b: TSESTree.Node) => boolean;
  (a: TSESTree.Node, b: TSESTree.Node): boolean;
};
//#endregion
//#region src/ast-process-env-node-env.d.ts
/**
 * Check if the given node is a member expression that accesses `process.env.NODE_ENV`
 * @param node The AST node
 * @returns True if the node is a member expression that accesses `process.env.NODE_ENV`, false otherwise
 */
declare function isProcessEnvNodeEnv(node: TSESTree.Node | null | unit): node is TSESTree.MemberExpression;
/**
 * Check if the given node is a binary expression that compares `process.env.NODE_ENV` with a string literal
 * @param node The AST node
 * @param operator The operator used in the comparison
 * @param value The string literal value to compare against
 * @returns True if the node is a binary expression that compares `process.env.NODE_ENV` with the specified value, false otherwise
 */
declare function isProcessEnvNodeEnvCompare(node: TSESTree.Node | null | unit, operator: "===" | "!==", value: "development" | "production"): node is TSESTree.BinaryExpression;
//#endregion
//#region src/ast-property-name.d.ts
declare function getPropertyName(node: TSESTree.Node): string | unit;
//#endregion
//#region src/ast-to-string.d.ts
declare function toDelimiterCaseType(node: TSESTree.Node, delimiter?: string): "RegExp literal" | Lowercase<string> | `JSX ${Lowercase<string>}`;
/**
 * Returns human readable node name for given AST node
 * @param node AST node
 * @param getText A function that returns the text of the node in the source code
 * @returns Human readable node name
 */
declare function toString(node: TSESTree.Node, getText: (node: TSESTree.Node) => string): string;
//#endregion
export { FunctionInitPath, TSESTreeArrayTupleType, TSESTreeClass, TSESTreeDestructuringPattern, TSESTreeFunction, TSESTreeFunctionType, TSESTreeJSX, TSESTreeLoop, TSESTreeMethodOrProperty, TSESTreeProperty, TSESTreeTypeAssertionExpression, TSESTreeTypeDeclaration, TSESTreeTypeExpression, findParentNode, getArrayMethodCallbackIndexParamPosition, getClassId, getFunctionId, getFunctionInitPath, getJSExpression, getNestedCallExpressions, getNestedExpressionsOfType, getNestedIdentifiers, getNestedNewExpressions, getNestedReturnStatements, getPropertyName, hasCallInFunctionInitPath, is, isArrayFromCall, isArrayMapCall, isClass, isEmptyFunction, isFunction, isFunctionType, isJSX, isJSXElement, isJSXFragment, isJSXTagNameExpression, isLineBreak, isLiteral, isLoop, isMethodOrProperty, isMultiLine, isNodeEqual, isOneOf, isProcessEnvNodeEnv, isProcessEnvNodeEnvCompare, isProperty, isThisExpression, isTypeAssertionExpression, isTypeExpression, toDelimiterCaseType, toString };