//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let __eslint_react_eff = require("@eslint-react/eff");
__eslint_react_eff = __toESM(__eslint_react_eff);
let __typescript_eslint_scope_manager = require("@typescript-eslint/scope-manager");
__typescript_eslint_scope_manager = __toESM(__typescript_eslint_scope_manager);
let __typescript_eslint_types = require("@typescript-eslint/types");
__typescript_eslint_types = __toESM(__typescript_eslint_types);
let __typescript_eslint_utils_ast_utils = require("@typescript-eslint/utils/ast-utils");
__typescript_eslint_utils_ast_utils = __toESM(__typescript_eslint_utils_ast_utils);
let __eslint_react_ast = require("@eslint-react/ast");
__eslint_react_ast = __toESM(__eslint_react_ast);

//#region src/var-init-node.ts
function getVariableInitNode(variable, at) {
	if (variable == null) return __eslint_react_eff.unit;
	const def = variable.defs.at(at);
	if (def == null) return __eslint_react_eff.unit;
	switch (true) {
		case def.type === __typescript_eslint_scope_manager.DefinitionType.FunctionName && def.node.type === __typescript_eslint_types.AST_NODE_TYPES.FunctionDeclaration: return def.node;
		case def.type === __typescript_eslint_scope_manager.DefinitionType.ClassName && def.node.type === __typescript_eslint_types.AST_NODE_TYPES.ClassDeclaration: return def.node;
		case "init" in def.node && def.node.init != null && !("declarations" in def.node.init): return def.node.init;
		default: return __eslint_react_eff.unit;
	}
}

//#endregion
//#region src/var-collect.ts
/**
* Get all variables from the given scope up to the global scope
* @param initialScope The scope to start from
* @returns All variables from the given scope up to the global scope
*/
function getVariables(initialScope) {
	let scope = initialScope;
	const variables = [...scope.variables];
	while (scope.type !== __typescript_eslint_scope_manager.ScopeType.global) {
		scope = scope.upper;
		variables.push(...scope.variables);
	}
	return variables.reverse();
}
const findVariable = (0, __eslint_react_eff.dual)(2, (nameOrNode, initialScope) => {
	if (nameOrNode == null) return __eslint_react_eff.unit;
	return __typescript_eslint_utils_ast_utils.findVariable(initialScope, nameOrNode) ?? __eslint_react_eff.unit;
});
function findPropertyInProperties(name, properties, initialScope, seen = /* @__PURE__ */ new Set()) {
	return properties.findLast((prop) => {
		if (prop.type === __typescript_eslint_types.AST_NODE_TYPES.Property) return "name" in prop.key && prop.key.name === name;
		if (prop.type === __typescript_eslint_types.AST_NODE_TYPES.SpreadElement) switch (prop.argument.type) {
			case __typescript_eslint_types.AST_NODE_TYPES.Identifier: {
				if (seen.has(prop.argument.name)) return false;
				const variable = findVariable(prop.argument.name, initialScope);
				const variableNode = getVariableInitNode(variable, 0);
				if (variableNode?.type === __typescript_eslint_types.AST_NODE_TYPES.ObjectExpression) {
					seen.add(prop.argument.name);
					return findPropertyInProperties(name, variableNode.properties, initialScope, seen) != null;
				}
				return false;
			}
			case __typescript_eslint_types.AST_NODE_TYPES.ObjectExpression: return findPropertyInProperties(name, prop.argument.properties, initialScope, seen) != null;
			default: return false;
		}
		return false;
	});
}

//#endregion
//#region src/var-construction.ts
const ConstructionDetectionHint = {
	None: 0n,
	StrictCallExpression: 1n << 0n
};
/**
* Detects the construction type of a given node.
* @param node The node to check.
* @param initialScope  The initial scope to check for variable declarations.
* @param hint Optional hint to control the detection behavior.
* @returns The construction type of the node, or `_` if not found.
*/
function getConstruction(node, initialScope, hint = ConstructionDetectionHint.None) {
	if (node == null) return __eslint_react_eff.unit;
	switch (node.type) {
		case __typescript_eslint_types.AST_NODE_TYPES.JSXElement:
		case __typescript_eslint_types.AST_NODE_TYPES.JSXFragment: return {
			kind: "JSXElement",
			node
		};
		case __typescript_eslint_types.AST_NODE_TYPES.ArrayExpression: return {
			kind: "ArrayExpression",
			node
		};
		case __typescript_eslint_types.AST_NODE_TYPES.ObjectExpression: return {
			kind: "ObjectExpression",
			node
		};
		case __typescript_eslint_types.AST_NODE_TYPES.ClassExpression: return {
			kind: "ClassExpression",
			node
		};
		case __typescript_eslint_types.AST_NODE_TYPES.NewExpression: return {
			kind: "NewExpression",
			node
		};
		case __typescript_eslint_types.AST_NODE_TYPES.FunctionExpression:
		case __typescript_eslint_types.AST_NODE_TYPES.ArrowFunctionExpression: return {
			kind: "FunctionExpression",
			node
		};
		case __typescript_eslint_types.AST_NODE_TYPES.CallExpression:
			if (hint & ConstructionDetectionHint.StrictCallExpression) return {
				kind: "CallExpression",
				node
			};
			return __eslint_react_eff.unit;
		case __typescript_eslint_types.AST_NODE_TYPES.MemberExpression:
			if (!("object" in node)) return __eslint_react_eff.unit;
			return getConstruction(node.object, initialScope, hint);
		case __typescript_eslint_types.AST_NODE_TYPES.AssignmentExpression:
		case __typescript_eslint_types.AST_NODE_TYPES.AssignmentPattern:
			if (!("right" in node)) return __eslint_react_eff.unit;
			return getConstruction(node.right, initialScope, hint);
		case __typescript_eslint_types.AST_NODE_TYPES.LogicalExpression:
			if (getConstruction(node.left, initialScope, hint) == null) return __eslint_react_eff.unit;
			return getConstruction(node.right, initialScope, hint);
		case __typescript_eslint_types.AST_NODE_TYPES.ConditionalExpression:
			if (getConstruction(node.consequent, initialScope, hint) == null) return __eslint_react_eff.unit;
			return getConstruction(node.alternate, initialScope, hint);
		case __typescript_eslint_types.AST_NODE_TYPES.Identifier: {
			if (!("name" in node) || typeof node.name !== "string") return __eslint_react_eff.unit;
			const variable = initialScope.set.get(node.name);
			const variableNode = getVariableInitNode(variable, -1);
			return getConstruction(variableNode, initialScope, hint);
		}
		case __typescript_eslint_types.AST_NODE_TYPES.Literal:
			if ("regex" in node) return {
				kind: "RegExpLiteral",
				node
			};
			return __eslint_react_eff.unit;
		default:
			if (!("expression" in node) || typeof node.expression !== "object") return __eslint_react_eff.unit;
			return getConstruction(node.expression, initialScope, hint);
	}
}

//#endregion
//#region src/var-declarator-id.ts
function getVariableDeclaratorId(node, prev) {
	if (node == null) return __eslint_react_eff.unit;
	switch (true) {
		case node.type === __typescript_eslint_types.AST_NODE_TYPES.VariableDeclarator && node.init === prev: return node.id;
		case node.type === __typescript_eslint_types.AST_NODE_TYPES.AssignmentExpression && node.right === prev: return node.left;
		case node.type === __typescript_eslint_types.AST_NODE_TYPES.BlockStatement || node.type === __typescript_eslint_types.AST_NODE_TYPES.Program || node.parent === node: return __eslint_react_eff.unit;
		default: return getVariableDeclaratorId(node.parent, node);
	}
}

//#endregion
//#region src/var-scope.ts
function getChidScopes(scope) {
	const scopes = [scope];
	for (const childScope of scope.childScopes) scopes.push(...getChidScopes(childScope));
	return scopes;
}

//#endregion
//#region src/var-value.ts
function toStaticValue(lazyValue) {
	const { kind, node, initialScope } = lazyValue;
	if (kind !== "lazy") return lazyValue;
	const staticValue = initialScope == null ? (0, __typescript_eslint_utils_ast_utils.getStaticValue)(node) : (0, __typescript_eslint_utils_ast_utils.getStaticValue)(node, initialScope);
	return staticValue == null ? {
		kind: "none",
		node,
		initialScope
	} : {
		kind: "some",
		node,
		initialScope,
		value: staticValue.value
	};
}

//#endregion
//#region src/var-value-equal.ts
const thisBlockTypes = [
	__typescript_eslint_types.AST_NODE_TYPES.FunctionDeclaration,
	__typescript_eslint_types.AST_NODE_TYPES.FunctionExpression,
	__typescript_eslint_types.AST_NODE_TYPES.ClassBody,
	__typescript_eslint_types.AST_NODE_TYPES.Program
];
/**
* Determines whether node value equals to another node value
* @param a node to compare
* @param b node to compare
* @param initialScopes initial scopes of the two nodes
* @returns `true` if node value equal
*/
function isNodeValueEqual(a, b, initialScopes) {
	const [aScope, bScope] = initialScopes;
	switch (true) {
		case a === b: return true;
		case a.type === __typescript_eslint_types.AST_NODE_TYPES.Literal && b.type === __typescript_eslint_types.AST_NODE_TYPES.Literal: return a.value === b.value;
		case a.type === __typescript_eslint_types.AST_NODE_TYPES.TemplateElement && b.type === __typescript_eslint_types.AST_NODE_TYPES.TemplateElement: return a.value.cooked === b.value.cooked;
		case a.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier && b.type === __typescript_eslint_types.AST_NODE_TYPES.Identifier: {
			const aVar = findVariable(a, aScope);
			const bVar = findVariable(b, bScope);
			const aVarNode = getVariableInitNodeLoose(aVar, 0);
			const bVarNode = getVariableInitNodeLoose(bVar, 0);
			const aVarNodeParent = aVarNode?.parent;
			const bVarNodeParent = bVarNode?.parent;
			const aDef = aVar?.defs.at(0);
			const bDef = bVar?.defs.at(0);
			const aDefParentParent = aDef?.parent?.parent;
			const bDefParentParent = bDef?.parent?.parent;
			switch (true) {
				case aVarNodeParent?.type === __typescript_eslint_types.AST_NODE_TYPES.CallExpression && bVarNodeParent?.type === __typescript_eslint_types.AST_NODE_TYPES.CallExpression && __eslint_react_ast.isFunction(aVarNode) && __eslint_react_ast.isFunction(bVarNode): {
					if (!__eslint_react_ast.isNodeEqual(aVarNodeParent.callee, bVarNodeParent.callee)) return false;
					const aParams = aVarNode.params;
					const bParams = bVarNode.params;
					const aPos = aParams.findIndex((x) => __eslint_react_ast.isNodeEqual(x, a));
					const bPos = bParams.findIndex((x) => __eslint_react_ast.isNodeEqual(x, b));
					return aPos !== -1 && bPos !== -1 && aPos === bPos;
				}
				case aDefParentParent?.type === __typescript_eslint_types.AST_NODE_TYPES.ForOfStatement && bDefParentParent?.type === __typescript_eslint_types.AST_NODE_TYPES.ForOfStatement: {
					const aLeft = aDefParentParent.left;
					const bLeft = bDefParentParent.left;
					if (aLeft.type !== bLeft.type) return false;
					const aRight = aDefParentParent.right;
					const bRight = bDefParentParent.right;
					return __eslint_react_ast.isNodeEqual(aRight, bRight);
				}
				default: return aVar != null && bVar != null && aVar === bVar;
			}
		}
		case a.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression && b.type === __typescript_eslint_types.AST_NODE_TYPES.MemberExpression: return __eslint_react_ast.isNodeEqual(a.property, b.property) && isNodeValueEqual(a.object, b.object, initialScopes);
		case a.type === __typescript_eslint_types.AST_NODE_TYPES.ThisExpression && b.type === __typescript_eslint_types.AST_NODE_TYPES.ThisExpression: {
			if (aScope.block === bScope.block) return true;
			const aFunction = __eslint_react_ast.findParentNode(a, __eslint_react_ast.isOneOf(thisBlockTypes));
			const bFunction = __eslint_react_ast.findParentNode(b, __eslint_react_ast.isOneOf(thisBlockTypes));
			return aFunction === bFunction;
		}
		default: {
			const aStatic = toStaticValue({
				kind: "lazy",
				node: a,
				initialScope: aScope
			});
			const bStatic = toStaticValue({
				kind: "lazy",
				node: b,
				initialScope: bScope
			});
			return aStatic.kind !== "none" && bStatic.kind !== "none" && aStatic.value === bStatic.value;
		}
	}
}
function getVariableInitNodeLoose(variable, at) {
	if (variable == null) return __eslint_react_eff.unit;
	const node = getVariableInitNode(variable, at);
	if (node != null) return node;
	const def = variable.defs.at(at);
	if (def?.type === __typescript_eslint_scope_manager.DefinitionType.Parameter && __eslint_react_ast.isFunction(def.node)) return def.node;
	return __eslint_react_eff.unit;
}

//#endregion
exports.ConstructionDetectionHint = ConstructionDetectionHint;
exports.findPropertyInProperties = findPropertyInProperties;
exports.findVariable = findVariable;
exports.getChidScopes = getChidScopes;
exports.getConstruction = getConstruction;
exports.getVariableDeclaratorId = getVariableDeclaratorId;
exports.getVariableInitNode = getVariableInitNode;
exports.getVariables = getVariables;
exports.isNodeValueEqual = isNodeValueEqual;
exports.toStaticValue = toStaticValue;