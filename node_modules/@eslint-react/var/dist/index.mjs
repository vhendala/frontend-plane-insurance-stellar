import { dual, unit } from "@eslint-react/eff";
import { DefinitionType, ScopeType } from "@typescript-eslint/scope-manager";
import { AST_NODE_TYPES } from "@typescript-eslint/types";
import * as ASTUtils from "@typescript-eslint/utils/ast-utils";
import { getStaticValue } from "@typescript-eslint/utils/ast-utils";
import * as AST from "@eslint-react/ast";

//#region src/var-init-node.ts
function getVariableInitNode(variable, at) {
	if (variable == null) return unit;
	const def = variable.defs.at(at);
	if (def == null) return unit;
	switch (true) {
		case def.type === DefinitionType.FunctionName && def.node.type === AST_NODE_TYPES.FunctionDeclaration: return def.node;
		case def.type === DefinitionType.ClassName && def.node.type === AST_NODE_TYPES.ClassDeclaration: return def.node;
		case "init" in def.node && def.node.init != null && !("declarations" in def.node.init): return def.node.init;
		default: return unit;
	}
}

//#endregion
//#region src/var-collect.ts
/**
* Get all variables from the given scope up to the global scope
* @param initialScope The scope to start from
* @returns All variables from the given scope up to the global scope
*/
function getVariables(initialScope) {
	let scope = initialScope;
	const variables = [...scope.variables];
	while (scope.type !== ScopeType.global) {
		scope = scope.upper;
		variables.push(...scope.variables);
	}
	return variables.reverse();
}
const findVariable = dual(2, (nameOrNode, initialScope) => {
	if (nameOrNode == null) return unit;
	return ASTUtils.findVariable(initialScope, nameOrNode) ?? unit;
});
function findPropertyInProperties(name, properties, initialScope, seen = /* @__PURE__ */ new Set()) {
	return properties.findLast((prop) => {
		if (prop.type === AST_NODE_TYPES.Property) return "name" in prop.key && prop.key.name === name;
		if (prop.type === AST_NODE_TYPES.SpreadElement) switch (prop.argument.type) {
			case AST_NODE_TYPES.Identifier: {
				if (seen.has(prop.argument.name)) return false;
				const variable = findVariable(prop.argument.name, initialScope);
				const variableNode = getVariableInitNode(variable, 0);
				if (variableNode?.type === AST_NODE_TYPES.ObjectExpression) {
					seen.add(prop.argument.name);
					return findPropertyInProperties(name, variableNode.properties, initialScope, seen) != null;
				}
				return false;
			}
			case AST_NODE_TYPES.ObjectExpression: return findPropertyInProperties(name, prop.argument.properties, initialScope, seen) != null;
			default: return false;
		}
		return false;
	});
}

//#endregion
//#region src/var-construction.ts
const ConstructionDetectionHint = {
	None: 0n,
	StrictCallExpression: 1n << 0n
};
/**
* Detects the construction type of a given node.
* @param node The node to check.
* @param initialScope  The initial scope to check for variable declarations.
* @param hint Optional hint to control the detection behavior.
* @returns The construction type of the node, or `_` if not found.
*/
function getConstruction(node, initialScope, hint = ConstructionDetectionHint.None) {
	if (node == null) return unit;
	switch (node.type) {
		case AST_NODE_TYPES.JSXElement:
		case AST_NODE_TYPES.JSXFragment: return {
			kind: "JSXElement",
			node
		};
		case AST_NODE_TYPES.ArrayExpression: return {
			kind: "ArrayExpression",
			node
		};
		case AST_NODE_TYPES.ObjectExpression: return {
			kind: "ObjectExpression",
			node
		};
		case AST_NODE_TYPES.ClassExpression: return {
			kind: "ClassExpression",
			node
		};
		case AST_NODE_TYPES.NewExpression: return {
			kind: "NewExpression",
			node
		};
		case AST_NODE_TYPES.FunctionExpression:
		case AST_NODE_TYPES.ArrowFunctionExpression: return {
			kind: "FunctionExpression",
			node
		};
		case AST_NODE_TYPES.CallExpression:
			if (hint & ConstructionDetectionHint.StrictCallExpression) return {
				kind: "CallExpression",
				node
			};
			return unit;
		case AST_NODE_TYPES.MemberExpression:
			if (!("object" in node)) return unit;
			return getConstruction(node.object, initialScope, hint);
		case AST_NODE_TYPES.AssignmentExpression:
		case AST_NODE_TYPES.AssignmentPattern:
			if (!("right" in node)) return unit;
			return getConstruction(node.right, initialScope, hint);
		case AST_NODE_TYPES.LogicalExpression:
			if (getConstruction(node.left, initialScope, hint) == null) return unit;
			return getConstruction(node.right, initialScope, hint);
		case AST_NODE_TYPES.ConditionalExpression:
			if (getConstruction(node.consequent, initialScope, hint) == null) return unit;
			return getConstruction(node.alternate, initialScope, hint);
		case AST_NODE_TYPES.Identifier: {
			if (!("name" in node) || typeof node.name !== "string") return unit;
			const variable = initialScope.set.get(node.name);
			const variableNode = getVariableInitNode(variable, -1);
			return getConstruction(variableNode, initialScope, hint);
		}
		case AST_NODE_TYPES.Literal:
			if ("regex" in node) return {
				kind: "RegExpLiteral",
				node
			};
			return unit;
		default:
			if (!("expression" in node) || typeof node.expression !== "object") return unit;
			return getConstruction(node.expression, initialScope, hint);
	}
}

//#endregion
//#region src/var-declarator-id.ts
function getVariableDeclaratorId(node, prev) {
	if (node == null) return unit;
	switch (true) {
		case node.type === AST_NODE_TYPES.VariableDeclarator && node.init === prev: return node.id;
		case node.type === AST_NODE_TYPES.AssignmentExpression && node.right === prev: return node.left;
		case node.type === AST_NODE_TYPES.BlockStatement || node.type === AST_NODE_TYPES.Program || node.parent === node: return unit;
		default: return getVariableDeclaratorId(node.parent, node);
	}
}

//#endregion
//#region src/var-scope.ts
function getChidScopes(scope) {
	const scopes = [scope];
	for (const childScope of scope.childScopes) scopes.push(...getChidScopes(childScope));
	return scopes;
}

//#endregion
//#region src/var-value.ts
function toStaticValue(lazyValue) {
	const { kind, node, initialScope } = lazyValue;
	if (kind !== "lazy") return lazyValue;
	const staticValue = initialScope == null ? getStaticValue(node) : getStaticValue(node, initialScope);
	return staticValue == null ? {
		kind: "none",
		node,
		initialScope
	} : {
		kind: "some",
		node,
		initialScope,
		value: staticValue.value
	};
}

//#endregion
//#region src/var-value-equal.ts
const thisBlockTypes = [
	AST_NODE_TYPES.FunctionDeclaration,
	AST_NODE_TYPES.FunctionExpression,
	AST_NODE_TYPES.ClassBody,
	AST_NODE_TYPES.Program
];
/**
* Determines whether node value equals to another node value
* @param a node to compare
* @param b node to compare
* @param initialScopes initial scopes of the two nodes
* @returns `true` if node value equal
*/
function isNodeValueEqual(a, b, initialScopes) {
	const [aScope, bScope] = initialScopes;
	switch (true) {
		case a === b: return true;
		case a.type === AST_NODE_TYPES.Literal && b.type === AST_NODE_TYPES.Literal: return a.value === b.value;
		case a.type === AST_NODE_TYPES.TemplateElement && b.type === AST_NODE_TYPES.TemplateElement: return a.value.cooked === b.value.cooked;
		case a.type === AST_NODE_TYPES.Identifier && b.type === AST_NODE_TYPES.Identifier: {
			const aVar = findVariable(a, aScope);
			const bVar = findVariable(b, bScope);
			const aVarNode = getVariableInitNodeLoose(aVar, 0);
			const bVarNode = getVariableInitNodeLoose(bVar, 0);
			const aVarNodeParent = aVarNode?.parent;
			const bVarNodeParent = bVarNode?.parent;
			const aDef = aVar?.defs.at(0);
			const bDef = bVar?.defs.at(0);
			const aDefParentParent = aDef?.parent?.parent;
			const bDefParentParent = bDef?.parent?.parent;
			switch (true) {
				case aVarNodeParent?.type === AST_NODE_TYPES.CallExpression && bVarNodeParent?.type === AST_NODE_TYPES.CallExpression && AST.isFunction(aVarNode) && AST.isFunction(bVarNode): {
					if (!AST.isNodeEqual(aVarNodeParent.callee, bVarNodeParent.callee)) return false;
					const aParams = aVarNode.params;
					const bParams = bVarNode.params;
					const aPos = aParams.findIndex((x) => AST.isNodeEqual(x, a));
					const bPos = bParams.findIndex((x) => AST.isNodeEqual(x, b));
					return aPos !== -1 && bPos !== -1 && aPos === bPos;
				}
				case aDefParentParent?.type === AST_NODE_TYPES.ForOfStatement && bDefParentParent?.type === AST_NODE_TYPES.ForOfStatement: {
					const aLeft = aDefParentParent.left;
					const bLeft = bDefParentParent.left;
					if (aLeft.type !== bLeft.type) return false;
					const aRight = aDefParentParent.right;
					const bRight = bDefParentParent.right;
					return AST.isNodeEqual(aRight, bRight);
				}
				default: return aVar != null && bVar != null && aVar === bVar;
			}
		}
		case a.type === AST_NODE_TYPES.MemberExpression && b.type === AST_NODE_TYPES.MemberExpression: return AST.isNodeEqual(a.property, b.property) && isNodeValueEqual(a.object, b.object, initialScopes);
		case a.type === AST_NODE_TYPES.ThisExpression && b.type === AST_NODE_TYPES.ThisExpression: {
			if (aScope.block === bScope.block) return true;
			const aFunction = AST.findParentNode(a, AST.isOneOf(thisBlockTypes));
			const bFunction = AST.findParentNode(b, AST.isOneOf(thisBlockTypes));
			return aFunction === bFunction;
		}
		default: {
			const aStatic = toStaticValue({
				kind: "lazy",
				node: a,
				initialScope: aScope
			});
			const bStatic = toStaticValue({
				kind: "lazy",
				node: b,
				initialScope: bScope
			});
			return aStatic.kind !== "none" && bStatic.kind !== "none" && aStatic.value === bStatic.value;
		}
	}
}
function getVariableInitNodeLoose(variable, at) {
	if (variable == null) return unit;
	const node = getVariableInitNode(variable, at);
	if (node != null) return node;
	const def = variable.defs.at(at);
	if (def?.type === DefinitionType.Parameter && AST.isFunction(def.node)) return def.node;
	return unit;
}

//#endregion
export { ConstructionDetectionHint, findPropertyInProperties, findVariable, getChidScopes, getConstruction, getVariableDeclaratorId, getVariableInitNode, getVariables, isNodeValueEqual, toStaticValue };