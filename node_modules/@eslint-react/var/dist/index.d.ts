import { unit } from "@eslint-react/eff";
import { Scope, Variable } from "@typescript-eslint/scope-manager";
import { TSESTree } from "@typescript-eslint/types";

//#region src/var-collect.d.ts

/**
 * Get all variables from the given scope up to the global scope
 * @param initialScope The scope to start from
 * @returns All variables from the given scope up to the global scope
 */
declare function getVariables(initialScope: Scope): Variable[];
declare const findVariable: {
  (initialScope: Scope): (nameOrNode: string | TSESTree.Identifier | unit) => Variable | unit;
  (nameOrNode: string | TSESTree.Identifier | unit, initialScope: Scope): Variable | unit;
};
declare function findPropertyInProperties(name: string, properties: (TSESTree.Property | TSESTree.RestElement | TSESTree.SpreadElement)[], initialScope: Scope, seen?: Set<string>): (typeof properties)[number] | unit;
//#endregion
//#region src/var-construction.d.ts
declare const ConstructionDetectionHint: {
  None: bigint;
  StrictCallExpression: bigint;
};
type Construction = {
  kind: "ArrayExpression";
  node: TSESTree.ArrayExpression;
} | {
  kind: "CallExpression";
  node: TSESTree.CallExpression;
} | {
  kind: "ClassExpression";
  node: TSESTree.ClassExpression;
} | {
  kind: "FunctionDeclaration";
  node: TSESTree.FunctionDeclaration;
} | {
  kind: "FunctionExpression";
  node: TSESTree.FunctionExpression | TSESTree.ArrowFunctionExpression;
} | {
  kind: "JSXElement";
  node: TSESTree.JSXElement | TSESTree.JSXFragment;
} | {
  kind: "NewExpression";
  node: TSESTree.NewExpression;
} | {
  kind: "ObjectExpression";
  node: TSESTree.ObjectExpression;
} | {
  kind: "RegExpLiteral";
  node: TSESTree.RegExpLiteral;
};
/**
 * Detects the construction type of a given node.
 * @param node The node to check.
 * @param initialScope  The initial scope to check for variable declarations.
 * @param hint Optional hint to control the detection behavior.
 * @returns The construction type of the node, or `_` if not found.
 */
declare function getConstruction(node: TSESTree.Node | unit, initialScope: Scope, hint?: bigint): Construction | unit;
//#endregion
//#region src/var-declarator-id.d.ts
declare function getVariableDeclaratorId(node: TSESTree.Node | unit, prev?: TSESTree.Node): TSESTree.BindingName | TSESTree.Expression | unit;
//#endregion
//#region src/var-init-node.d.ts
declare function getVariableInitNode(variable: Variable | unit, at: number): unit | TSESTree.ClassDeclaration | TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.Expression | TSESTree.FunctionDeclaration | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName;
//#endregion
//#region src/var-scope.d.ts
declare function getChidScopes(scope: Scope): readonly Scope[];
//#endregion
//#region src/var-value.d.ts
type LazyValue = {
  kind: "lazy";
  node: TSESTree.Node;
  initialScope: Scope | unit;
} | {
  kind: "none";
  node: TSESTree.Node;
  initialScope: Scope | unit;
} | {
  kind: "some";
  node: TSESTree.Node;
  value: unknown;
  initialScope: Scope | unit;
};
declare function toStaticValue(lazyValue: LazyValue): {
  readonly kind: "none";
  readonly node: TSESTree.Node;
  readonly initialScope: Scope | undefined;
  readonly value?: never;
} | {
  readonly kind: "some";
  readonly node: TSESTree.Node;
  readonly initialScope: Scope | undefined;
  readonly value: unknown;
};
//#endregion
//#region src/var-value-equal.d.ts
/**
 * Determines whether node value equals to another node value
 * @param a node to compare
 * @param b node to compare
 * @param initialScopes initial scopes of the two nodes
 * @returns `true` if node value equal
 */
declare function isNodeValueEqual(a: TSESTree.Node, b: TSESTree.Node, initialScopes: [aScope: Scope, bScope: Scope]): boolean;
//#endregion
export { Construction, ConstructionDetectionHint, LazyValue, findPropertyInProperties, findVariable, getChidScopes, getConstruction, getVariableDeclaratorId, getVariableInitNode, getVariables, isNodeValueEqual, toStaticValue };