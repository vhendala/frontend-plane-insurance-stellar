import { DEFAULT_ESLINT_REACT_SETTINGS, coerceSettings, getConfigAdapters, getDocsUrl, getSettingsFromContext } from "@eslint-react/shared";
import * as ER from "@eslint-react/core";
import { ESLintUtils } from "@typescript-eslint/utils";
import { JsxConfig, LanguagePreference, Reporter, Selector } from "@eslint-react/kit";
import { AST_NODE_TYPES } from "@typescript-eslint/types";
import * as VAR from "@eslint-react/var";
import { P, isMatching, match } from "ts-pattern";
import * as AST from "@eslint-react/ast";
import { constFalse, constTrue, flow, getOrElseUpdate, unit } from "@eslint-react/eff";
import { compare } from "compare-versions";
import { getConstrainedTypeAtLocation, isTypeReadonly } from "@typescript-eslint/type-utils";
import { isFalseLiteralType, isTrueLiteralType, isTypeFlagSet, unionTypeParts } from "ts-api-utils";
import ts from "typescript";
import { getTypeImmutability, isImmutable, isReadonlyDeep, isReadonlyShallow, isUnknown } from "is-immutable-type";

//#region rolldown:runtime
var __defProp = Object.defineProperty;
var __export = (all) => {
	let target = {};
	for (var name$4 in all) __defProp(target, name$4, {
		get: all[name$4],
		enumerable: true
	});
	return target;
};

//#endregion
//#region src/configs/recommended.ts
var recommended_exports = __export({
	name: () => name$3,
	rules: () => rules$2,
	settings: () => settings$2
});
const name$3 = "react-x/recommended";
const rules$2 = {
	"react-x/jsx-key-before-spread": "warn",
	"react-x/jsx-no-duplicate-props": "warn",
	"react-x/jsx-uses-react": "warn",
	"react-x/jsx-uses-vars": "warn",
	"react-x/no-access-state-in-setstate": "error",
	"react-x/no-array-index-key": "warn",
	"react-x/no-children-count": "warn",
	"react-x/no-children-for-each": "warn",
	"react-x/no-children-map": "warn",
	"react-x/no-children-only": "warn",
	"react-x/no-children-to-array": "warn",
	"react-x/no-clone-element": "warn",
	"react-x/no-comment-textnodes": "warn",
	"react-x/no-component-will-mount": "error",
	"react-x/no-component-will-receive-props": "error",
	"react-x/no-component-will-update": "error",
	"react-x/no-context-provider": "warn",
	"react-x/no-create-ref": "error",
	"react-x/no-default-props": "error",
	"react-x/no-direct-mutation-state": "error",
	"react-x/no-duplicate-key": "warn",
	"react-x/no-forward-ref": "warn",
	"react-x/no-implicit-key": "warn",
	"react-x/no-missing-key": "error",
	"react-x/no-misused-capture-owner-stack": "error",
	"react-x/no-nested-component-definitions": "error",
	"react-x/no-nested-lazy-component-declarations": "warn",
	"react-x/no-prop-types": "error",
	"react-x/no-redundant-should-component-update": "error",
	"react-x/no-set-state-in-component-did-mount": "warn",
	"react-x/no-set-state-in-component-did-update": "warn",
	"react-x/no-set-state-in-component-will-update": "warn",
	"react-x/no-string-refs": "error",
	"react-x/no-unsafe-component-will-mount": "warn",
	"react-x/no-unsafe-component-will-receive-props": "warn",
	"react-x/no-unsafe-component-will-update": "warn",
	"react-x/no-unstable-context-value": "warn",
	"react-x/no-unstable-default-props": "warn",
	"react-x/no-unused-class-component-members": "warn",
	"react-x/no-unused-state": "warn",
	"react-x/no-use-context": "warn",
	"react-x/no-useless-forward-ref": "warn"
};
const settings$2 = { "react-x": DEFAULT_ESLINT_REACT_SETTINGS };

//#endregion
//#region src/configs/recommended-typescript.ts
var recommended_typescript_exports = __export({
	name: () => name$2,
	rules: () => rules$1,
	settings: () => settings$1
});
const name$2 = "react-x/recommended-typescript";
const rules$1 = {
	...rules$2,
	"react-x/jsx-no-duplicate-props": "off",
	"react-x/jsx-no-undef": "off",
	"react-x/jsx-uses-react": "off",
	"react-x/jsx-uses-vars": "off"
};
const settings$1 = { ...settings$2 };

//#endregion
//#region src/configs/recommended-type-checked.ts
var recommended_type_checked_exports = __export({
	name: () => name$1,
	rules: () => rules,
	settings: () => settings
});
const name$1 = "react-x/recommended-type-checked";
const rules = {
	...rules$1,
	"react-x/no-leaked-conditional-rendering": "warn"
};
const settings = { ...settings$1 };

//#endregion
//#region package.json
var name = "eslint-plugin-react-x";
var version = "1.53.1";

//#endregion
//#region src/utils/create-rule.ts
const createRule = ESLintUtils.RuleCreator(getDocsUrl("x"));

//#endregion
//#region src/rules/avoid-shorthand-boolean.ts
const RULE_NAME$57 = "avoid-shorthand-boolean";
const RULE_FEATURES$56 = [];
var avoid_shorthand_boolean_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces explicit boolean values for boolean attributes.",
			[Symbol.for("rule_features")]: RULE_FEATURES$56
		},
		fixable: "code",
		messages: { avoidShorthandBoolean: "Avoid using shorthand boolean attribute '{{propName}}'. Use '{{propName}}={true}' instead." },
		schema: []
	},
	name: RULE_NAME$57,
	create: create$57,
	defaultOptions: []
});
function create$57(context) {
	return { JSXAttribute(node) {
		if (node.value == null) context.report({
			messageId: "avoidShorthandBoolean",
			node,
			data: { propName: ER.getAttributeName(context, node) },
			fix: (fixer) => fixer.insertTextAfter(node.name, `={true}`)
		});
	} };
}

//#endregion
//#region src/rules/avoid-shorthand-fragment.ts
const RULE_NAME$56 = "avoid-shorthand-fragment";
const RULE_FEATURES$55 = [];
var avoid_shorthand_fragment_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces explicit `<Fragment>` components instead of the shorthand `<>` or `</>` syntax.",
			[Symbol.for("rule_features")]: RULE_FEATURES$55
		},
		messages: { avoidShorthandFragment: "Avoid using shorthand fragment syntax. Use '{{jsxFragmentFactory}}' component instead." },
		schema: []
	},
	name: RULE_NAME$56,
	create: create$56,
	defaultOptions: []
});
function create$56(context) {
	const jsxConfigFromContext = JsxConfig.getFromContext(context);
	const jsxConfigFromAnnotation = JsxConfig.getFromAnnotation(context);
	const jsxConfig = {
		...jsxConfigFromContext,
		...jsxConfigFromAnnotation
	};
	return { JSXFragment(node) {
		context.report({
			messageId: "avoidShorthandFragment",
			node,
			data: { jsxFragmentFactory: jsxConfig.jsxFragmentFactory }
		});
	} };
}

//#endregion
//#region src/rules/jsx-key-before-spread.ts
const RULE_NAME$55 = "jsx-key-before-spread";
const RULE_FEATURES$54 = ["EXP"];
var jsx_key_before_spread_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces that the 'key' attribute is placed before the spread attribute in JSX elements.",
			[Symbol.for("rule_features")]: RULE_FEATURES$54
		},
		messages: { jsxKeyBeforeSpread: "The 'key' attribute must be placed before the spread attribute." },
		schema: []
	},
	name: RULE_NAME$55,
	create: create$55,
	defaultOptions: []
});
function create$55(context) {
	return { JSXOpeningElement(node) {
		let firstSpreadAttributeIndex = null;
		for (const [index, attr] of node.attributes.entries()) {
			if (attr.type === AST_NODE_TYPES.JSXSpreadAttribute) {
				firstSpreadAttributeIndex ??= index;
				continue;
			}
			if (attr.name.name === "key" && firstSpreadAttributeIndex != null && index > firstSpreadAttributeIndex) context.report({
				messageId: "jsxKeyBeforeSpread",
				node: attr
			});
		}
	} };
}

//#endregion
//#region src/rules/jsx-no-duplicate-props.ts
const RULE_NAME$54 = "jsx-no-duplicate-props";
const RULE_FEATURES$53 = [];
var jsx_no_duplicate_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow duplicate props in JSX elements.",
			[Symbol.for("rule_features")]: RULE_FEATURES$53
		},
		messages: { jsxNoDuplicateProps: "This JSX property is assigned multiple times." },
		schema: []
	},
	name: RULE_NAME$54,
	create: create$54,
	defaultOptions: []
});
function create$54(context) {
	return { JSXOpeningElement(node) {
		const props = [];
		for (const attr of node.attributes) {
			if (attr.type === AST_NODE_TYPES.JSXSpreadAttribute) continue;
			const name$4 = attr.name.name;
			if (typeof name$4 !== "string") continue;
			if (!props.includes(name$4)) {
				props.push(name$4);
				continue;
			}
			context.report({
				messageId: "jsxNoDuplicateProps",
				node: attr
			});
		}
	} };
}

//#endregion
//#region src/rules/jsx-no-iife.ts
const RULE_NAME$53 = "jsx-no-iife";
const RULE_FEATURES$52 = ["EXP"];
var jsx_no_iife_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallows 'IIFE' in JSX elements.",
			[Symbol.for("rule_features")]: RULE_FEATURES$52
		},
		messages: { jsxNoIife: "Avoid using IIFE in JSX elements." },
		schema: []
	},
	name: RULE_NAME$53,
	create: create$53,
	defaultOptions: []
});
function create$53(context) {
	return {
		"JSXElement :function"(node) {
			if (node.parent.type === AST_NODE_TYPES.CallExpression && node.parent.callee === node) context.report({
				messageId: "jsxNoIife",
				node: node.parent
			});
		},
		"JSXFragment :function"(node) {
			if (node.parent.type === AST_NODE_TYPES.CallExpression && node.parent.callee === node) context.report({
				messageId: "jsxNoIife",
				node: node.parent
			});
		}
	};
}

//#endregion
//#region src/rules/jsx-no-undef.ts
const RULE_NAME$52 = "jsx-no-undef";
const RULE_FEATURES$51 = [];
var jsx_no_undef_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow undefined variables in JSX.",
			[Symbol.for("rule_features")]: RULE_FEATURES$51
		},
		messages: { jsxNoUndef: "JSX variable '{{name}}' is not defined." },
		schema: []
	},
	name: RULE_NAME$52,
	create: create$52,
	defaultOptions: []
});
function create$52(context) {
	return { JSXOpeningElement(node) {
		const name$4 = match(node.name).with({ type: AST_NODE_TYPES.JSXIdentifier }, (n) => n.name).with({
			type: AST_NODE_TYPES.JSXMemberExpression,
			object: { type: AST_NODE_TYPES.JSXIdentifier }
		}, (n) => n.object.name).otherwise(() => null);
		if (name$4 == null) return;
		if (name$4 === "this") return;
		if (/^[a-z]/u.test(name$4)) return;
		if (VAR.findVariable(name$4, context.sourceCode.getScope(node)) == null) context.report({
			messageId: "jsxNoUndef",
			node,
			data: { name: name$4 }
		});
	} };
}

//#endregion
//#region src/rules/jsx-uses-react.ts
const { JsxEmit } = JsxConfig;
const RULE_NAME$51 = "jsx-uses-react";
const RULE_FEATURES$50 = [];
var jsx_uses_react_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Marks React variables as used when JSX is used.",
			[Symbol.for("rule_features")]: RULE_FEATURES$50
		},
		messages: { jsxUsesReact: "Marked {{name}} as used." },
		schema: []
	},
	name: RULE_NAME$51,
	create: create$51,
	defaultOptions: []
});
function create$51(context) {
	const { jsx, jsxFactory, jsxFragmentFactory } = {
		...JsxConfig.getFromContext(context),
		...JsxConfig.getFromAnnotation(context)
	};
	if (jsx === JsxEmit.ReactJSX || jsx === JsxEmit.ReactJSXDev) return {};
	function handleJsxElement(node) {
		context.sourceCode.markVariableAsUsed(jsxFactory, node);
		debugReport(context, node, jsxFactory);
	}
	function handleJsxFragment(node) {
		context.sourceCode.markVariableAsUsed(jsxFragmentFactory, node);
		debugReport(context, node, jsxFragmentFactory);
	}
	return {
		JSXFragment: handleJsxFragment,
		JSXOpeningElement: handleJsxElement,
		JSXOpeningFragment: handleJsxElement
	};
}
function debugReport(context, node, name$4) {
	if (process.env["ESLINT_REACT_DEBUG"] !== "1") return;
	context.report({
		messageId: "jsxUsesReact",
		node,
		data: { name: name$4 }
	});
}

//#endregion
//#region src/rules/jsx-uses-vars.ts
const RULE_NAME$50 = "jsx-uses-vars";
const RULE_FEATURES$49 = [];
var jsx_uses_vars_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Marks variables used in JSX elements as used.",
			[Symbol.for("rule_features")]: RULE_FEATURES$49
		},
		messages: { jsxUsesVars: "An identifier in JSX is marked as used." },
		schema: []
	},
	name: RULE_NAME$50,
	create: create$50,
	defaultOptions: []
});
function create$50(context) {
	return { JSXOpeningElement(node) {
		switch (node.name.type) {
			case AST_NODE_TYPES.JSXIdentifier:
				if (/^[a-z]/u.test(node.name.name)) return;
				context.sourceCode.markVariableAsUsed(node.name.name, node);
				break;
			case AST_NODE_TYPES.JSXMemberExpression: {
				const { object } = node.name;
				if (object.type === AST_NODE_TYPES.JSXIdentifier) context.sourceCode.markVariableAsUsed(object.name, node);
				break;
			}
		}
	} };
}

//#endregion
//#region src/rules/no-access-state-in-setstate.ts
const RULE_NAME$49 = "no-access-state-in-setstate";
const RULE_FEATURES$48 = [];
function isKeyLiteral$2(node, key) {
	return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({
		type: AST_NODE_TYPES.TemplateLiteral,
		expressions: []
	}, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_access_state_in_setstate_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow accessing `this.state` inside `setState` calls.",
			[Symbol.for("rule_features")]: RULE_FEATURES$48
		},
		messages: { noAccessStateInSetstate: "Do not access 'this.state' within 'setState'. Use the update function instead." },
		schema: []
	},
	name: RULE_NAME$49,
	create: create$49,
	defaultOptions: []
});
function create$49(context) {
	if (!context.sourceCode.text.includes("setState")) return {};
	const classEntries = [];
	const methodEntries = [];
	const setStateEntries = [];
	return {
		CallExpression(node) {
			if (!ER.isThisSetState(node)) return;
			setStateEntries.push([node, false]);
		},
		"CallExpression:exit"(node) {
			if (!ER.isThisSetState(node)) return;
			setStateEntries.pop();
		},
		ClassDeclaration(node) {
			classEntries.push([node, ER.isClassComponent(node)]);
		},
		"ClassDeclaration:exit"() {
			classEntries.pop();
		},
		ClassExpression(node) {
			classEntries.push([node, ER.isClassComponent(node)]);
		},
		"ClassExpression:exit"() {
			classEntries.pop();
		},
		MemberExpression(node) {
			if (!AST.isThisExpression(node.object)) return;
			const [currClass, isComponent = false] = classEntries.at(-1) ?? [];
			if (currClass == null || !isComponent) return;
			const [currMethod, isStatic = false] = methodEntries.at(-1) ?? [];
			if (currMethod == null || isStatic) return;
			const [setState, hasThisState = false] = setStateEntries.at(-1) ?? [];
			if (setState == null || hasThisState) return;
			if (AST.getPropertyName(node.property) !== "state") return;
			context.report({
				messageId: "noAccessStateInSetstate",
				node
			});
		},
		MethodDefinition(node) {
			methodEntries.push([node, node.static]);
		},
		"MethodDefinition:exit"() {
			methodEntries.pop();
		},
		PropertyDefinition(node) {
			methodEntries.push([node, node.static]);
		},
		"PropertyDefinition:exit"() {
			methodEntries.pop();
		},
		VariableDeclarator(node) {
			const [currClass, isComponent = false] = classEntries.at(-1) ?? [];
			if (currClass == null || !isComponent) return;
			const [currMethod, isStatic = false] = methodEntries.at(-1) ?? [];
			if (currMethod == null || isStatic) return;
			const [setState, hasThisState = false] = setStateEntries.at(-1) ?? [];
			if (setState == null || hasThisState) return;
			if (node.init == null || !AST.isThisExpression(node.init) || node.id.type !== AST_NODE_TYPES.ObjectPattern) return;
			if (!node.id.properties.some((prop) => prop.type === AST_NODE_TYPES.Property && isKeyLiteral$2(prop, prop.key) && AST.getPropertyName(prop.key) === "state")) return;
			context.report({
				messageId: "noAccessStateInSetstate",
				node
			});
		}
	};
}

//#endregion
//#region src/rules/no-array-index-key.ts
const RULE_NAME$48 = "no-array-index-key";
const RULE_FEATURES$47 = [];
const reactChildrenMethod = ["forEach", "map"];
function isReactChildrenMethod(name$4) {
	return reactChildrenMethod.some((method) => method === name$4);
}
function isUsingReactChildren(context, node) {
	const { importSource = "react" } = coerceSettings(context.settings);
	const { callee } = node;
	if (!("property" in callee) || !("object" in callee) || !("name" in callee.property)) return false;
	if (!isReactChildrenMethod(callee.property.name)) return false;
	const initialScope = context.sourceCode.getScope(node);
	if (callee.object.type === AST_NODE_TYPES.Identifier && callee.object.name === "Children") return true;
	if (callee.object.type === AST_NODE_TYPES.MemberExpression && "name" in callee.object.object) return ER.isInitializedFromReact(callee.object.object.name, importSource, initialScope);
	return false;
}
function getMapIndexParamName(context, node) {
	const { callee } = node;
	if (callee.type !== AST_NODE_TYPES.MemberExpression) return unit;
	if (callee.property.type !== AST_NODE_TYPES.Identifier) return unit;
	const { name: name$4 } = callee.property;
	const indexPosition = AST.getArrayMethodCallbackIndexParamPosition(name$4);
	if (indexPosition === -1) return unit;
	const callbackArg = node.arguments[isUsingReactChildren(context, node) ? 1 : 0];
	if (callbackArg == null) return unit;
	if (!AST.isOneOf([AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression])(callbackArg)) return unit;
	const { params } = callbackArg;
	if (params.length < indexPosition + 1) return unit;
	const param = params.at(indexPosition);
	return param != null && "name" in param ? param.name : unit;
}
function getIdentifiersFromBinaryExpression(side) {
	if (side.type === AST_NODE_TYPES.Identifier) return [side];
	if (side.type === AST_NODE_TYPES.BinaryExpression) return [...getIdentifiersFromBinaryExpression(side.left), ...getIdentifiersFromBinaryExpression(side.right)];
	return [];
}
var no_array_index_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow an item's index in the array as its key.",
			[Symbol.for("rule_features")]: RULE_FEATURES$47
		},
		messages: { noArrayIndexKey: "Do not use item index in the array as its key." },
		schema: []
	},
	name: RULE_NAME$48,
	create: create$48,
	defaultOptions: []
});
function create$48(context) {
	const report = Reporter.make(context);
	const indexParamNames = [];
	function isArrayIndex(node) {
		return node.type === AST_NODE_TYPES.Identifier && indexParamNames.some((name$4) => name$4 != null && name$4 === node.name);
	}
	function isCreateOrCloneElementCall(node) {
		return ER.isCreateElementCall(context, node) || ER.isCloneElementCall(context, node);
	}
	function getReportDescriptors(node) {
		switch (node.type) {
			case AST_NODE_TYPES.Identifier:
				if (indexParamNames.some((name$4) => name$4 != null && name$4 === node.name)) return [{
					messageId: "noArrayIndexKey",
					node
				}];
				return [];
			case AST_NODE_TYPES.TemplateLiteral:
			case AST_NODE_TYPES.BinaryExpression: {
				const descriptors = [];
				const expressions = node.type === AST_NODE_TYPES.TemplateLiteral ? node.expressions : getIdentifiersFromBinaryExpression(node);
				for (const expression of expressions) if (isArrayIndex(expression)) descriptors.push({
					messageId: "noArrayIndexKey",
					node: expression
				});
				return descriptors;
			}
			case AST_NODE_TYPES.CallExpression: switch (true) {
				case node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === "toString" && isArrayIndex(node.callee.object): return [{
					messageId: "noArrayIndexKey",
					node: node.callee.object
				}];
				case node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === "String" && node.arguments[0] != null && isArrayIndex(node.arguments[0]): return [{
					messageId: "noArrayIndexKey",
					node: node.arguments[0]
				}];
			}
		}
		return [];
	}
	return {
		CallExpression(node) {
			indexParamNames.push(getMapIndexParamName(context, node));
			if (node.arguments.length === 0) return;
			if (!isCreateOrCloneElementCall(node)) return;
			const [, props] = node.arguments;
			if (props?.type !== AST_NODE_TYPES.ObjectExpression) return;
			for (const prop of props.properties) {
				if (!isMatching({ key: { name: "key" } })(prop)) continue;
				if (!("value" in prop)) continue;
				for (const descriptor of getReportDescriptors(prop.value)) report.send(descriptor);
			}
		},
		"CallExpression:exit"() {
			indexParamNames.pop();
		},
		JSXAttribute(node) {
			if (node.name.name !== "key") return;
			if (indexParamNames.length === 0) return;
			if (node.value?.type !== AST_NODE_TYPES.JSXExpressionContainer) return;
			for (const descriptor of getReportDescriptors(node.value.expression)) report.send(descriptor);
		}
	};
}

//#endregion
//#region src/rules/no-children-count.ts
const RULE_NAME$47 = "no-children-count";
const RULE_FEATURES$46 = [];
var no_children_count_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.count`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$46
		},
		messages: { noChildrenCount: "Using 'Children.count' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$47,
	create: create$47,
	defaultOptions: []
});
function create$47(context) {
	return { MemberExpression(node) {
		if (ER.isChildrenCount(context, node)) context.report({
			messageId: "noChildrenCount",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-for-each.ts
const RULE_NAME$46 = "no-children-for-each";
const RULE_FEATURES$45 = [];
var no_children_for_each_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow 'Children.forEach'.",
			[Symbol.for("rule_features")]: RULE_FEATURES$45
		},
		messages: { noChildrenForEach: "Using 'Children.forEach' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$46,
	create: create$46,
	defaultOptions: []
});
function create$46(context) {
	return { MemberExpression(node) {
		if (ER.isChildrenForEach(context, node)) context.report({
			messageId: "noChildrenForEach",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-map.ts
const RULE_NAME$45 = "no-children-map";
const RULE_FEATURES$44 = [];
var no_children_map_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.map`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$44
		},
		messages: { noChildrenMap: "Using 'Children.map' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$45,
	create: create$45,
	defaultOptions: []
});
function create$45(context) {
	return { MemberExpression(node) {
		if (ER.isChildrenMap(context, node)) context.report({
			messageId: "noChildrenMap",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-only.ts
const RULE_NAME$44 = "no-children-only";
const RULE_FEATURES$43 = [];
var no_children_only_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.only`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$43
		},
		messages: { noChildrenOnly: "Using 'Children.only' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$44,
	create: create$44,
	defaultOptions: []
});
function create$44(context) {
	return { MemberExpression(node) {
		if (ER.isChildrenOnly(context, node)) context.report({
			messageId: "noChildrenOnly",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-children-prop.ts
const RULE_NAME$43 = "no-children-prop";
const RULE_FEATURES$42 = [];
var no_children_prop_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow passing `children` as a prop.",
			[Symbol.for("rule_features")]: RULE_FEATURES$42
		},
		messages: { noChildrenProp: "Do not pass 'children' as props." },
		schema: []
	},
	name: RULE_NAME$43,
	create: create$43,
	defaultOptions: []
});
function create$43(context) {
	return { JSXElement(node) {
		const attributes = node.openingElement.attributes;
		const childrenProp = ER.getAttribute(context, "children", attributes, context.sourceCode.getScope(node));
		if (childrenProp != null) context.report({
			messageId: "noChildrenProp",
			node: childrenProp
		});
	} };
}

//#endregion
//#region src/rules/no-children-to-array.ts
const RULE_NAME$42 = "no-children-to-array";
const RULE_FEATURES$41 = [];
var no_children_to_array_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `Children.toArray`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$41
		},
		messages: { noChildrenToArray: "Using 'Children.toArray' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$42,
	create: create$42,
	defaultOptions: []
});
function create$42(context) {
	return { MemberExpression(node) {
		if (ER.isChildrenToArray(context, node)) context.report({
			messageId: "noChildrenToArray",
			node: node.property
		});
	} };
}

//#endregion
//#region src/rules/no-class-component.ts
const RULE_NAME$41 = "no-class-component";
const RULE_FEATURES$40 = [];
var no_class_component_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow class components except for error boundaries.",
			[Symbol.for("rule_features")]: RULE_FEATURES$40
		},
		messages: { noClassComponent: "Avoid using class components. Use function components instead." },
		schema: []
	},
	name: RULE_NAME$41,
	create: create$41,
	defaultOptions: []
});
function create$41(context) {
	if (!context.sourceCode.text.includes("Component")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { name: name$4 = "anonymous", node: component } of components.values()) {
				if (component.body.body.some((m) => ER.isComponentDidCatch(m) || ER.isGetDerivedStateFromError(m))) continue;
				context.report({
					messageId: "noClassComponent",
					node: component,
					data: { name: name$4 }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-clone-element.ts
const RULE_NAME$40 = "no-clone-element";
const RULE_FEATURES$39 = [];
var no_clone_element_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `cloneElement`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$39
		},
		messages: { noCloneElement: "Using 'cloneElement' is uncommon and can lead to fragile code. Use alternatives instead." },
		schema: []
	},
	name: RULE_NAME$40,
	create: create$40,
	defaultOptions: []
});
function create$40(context) {
	return { CallExpression(node) {
		if (ER.isCloneElementCall(context, node)) context.report({
			messageId: "noCloneElement",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-comment-textnodes.ts
const RULE_NAME$39 = "no-comment-textnodes";
const RULE_FEATURES$38 = [];
var no_comment_textnodes_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents comments from being inserted as text nodes.",
			[Symbol.for("rule_features")]: RULE_FEATURES$38
		},
		messages: { noCommentTextnodes: "Possible misused comment in text node. Comments inside children section of tag should be placed inside braces." },
		schema: []
	},
	name: RULE_NAME$39,
	create: create$39,
	defaultOptions: []
});
function create$39(context) {
	function hasCommentLike(node) {
		if (AST.isOneOf([AST_NODE_TYPES.JSXAttribute, AST_NODE_TYPES.JSXExpressionContainer])(node.parent)) return false;
		const rawValue = context.sourceCode.getText(node);
		return /^\s*\/(?:\/|\*)/mu.test(rawValue);
	}
	const visitorFunction = (node) => {
		if (!AST.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent)) return;
		if (!hasCommentLike(node)) return;
		if (!node.parent.type.includes("JSX")) return;
		context.report({
			messageId: "noCommentTextnodes",
			node
		});
	};
	return {
		JSXText: visitorFunction,
		Literal: visitorFunction
	};
}

//#endregion
//#region src/rules/no-complex-conditional-rendering.ts
const RULE_NAME$38 = "no-complex-conditional-rendering";
const RULE_FEATURES$37 = ["EXP"];
var no_complex_conditional_rendering_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow complex conditional rendering in JSX expressions.",
			[Symbol.for("rule_features")]: RULE_FEATURES$37
		},
		messages: { noComplexConditionalRendering: "Avoid complex conditional rendering. Extract the logic into separate elements or components." },
		schema: []
	},
	name: RULE_NAME$38,
	create: create$38,
	defaultOptions: []
});
function create$38(context) {
	const visitorFunction = (node) => {
		const jsxExpContainer = node.parent?.parent;
		if (!AST.is(AST_NODE_TYPES.JSXExpressionContainer)(jsxExpContainer)) return;
		if (!AST.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(jsxExpContainer.parent)) return;
		if (!jsxExpContainer.parent.children.includes(jsxExpContainer)) return;
		context.report({
			messageId: "noComplexConditionalRendering",
			node: jsxExpContainer
		});
	};
	return {
		"JSXExpressionContainer > ConditionalExpression > ConditionalExpression": visitorFunction,
		"JSXExpressionContainer > ConditionalExpression > LogicalExpression": visitorFunction,
		"JSXExpressionContainer > LogicalExpression > ConditionalExpression": visitorFunction,
		"JSXExpressionContainer > LogicalExpression[operator='&&'] > LogicalExpression[operator='||']": visitorFunction,
		"JSXExpressionContainer > LogicalExpression[operator='||'] > LogicalExpression[operator='&&']": visitorFunction
	};
}

//#endregion
//#region src/rules/no-component-will-mount.ts
const RULE_NAME$37 = "no-component-will-mount";
const RULE_FEATURES$36 = ["MOD"];
var no_component_will_mount_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `componentWillMount` with `UNSAFE_componentWillMount`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$36
		},
		fixable: "code",
		messages: { noComponentWillMount: "[Deprecated] Use 'UNSAFE_componentWillMount' instead." },
		schema: []
	},
	name: RULE_NAME$37,
	create: create$37,
	defaultOptions: []
});
function create$37(context) {
	if (!context.sourceCode.text.includes("componentWillMount")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (ER.isComponentWillMount(member)) context.report({
					messageId: "noComponentWillMount",
					node: member,
					fix(fixer) {
						if (!("key" in member)) return null;
						return fixer.replaceText(member.key, "UNSAFE_componentWillMount");
					}
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-component-will-receive-props.ts
const RULE_NAME$36 = "no-component-will-receive-props";
const RULE_FEATURES$35 = ["MOD"];
var no_component_will_receive_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `componentWillReceiveProps` with `UNSAFE_componentWillReceiveProps`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$35
		},
		fixable: "code",
		messages: { noComponentWillReceiveProps: "[Deprecated] Use 'UNSAFE_componentWillReceiveProps' instead." },
		schema: []
	},
	name: RULE_NAME$36,
	create: create$36,
	defaultOptions: []
});
function create$36(context) {
	if (!context.sourceCode.text.includes("componentWillReceiveProps")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (ER.isComponentWillReceiveProps(member)) context.report({
					messageId: "noComponentWillReceiveProps",
					node: member,
					fix(fixer) {
						if (!("key" in member)) return null;
						return fixer.replaceText(member.key, "UNSAFE_componentWillReceiveProps");
					}
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-component-will-update.ts
const RULE_NAME$35 = "no-component-will-update";
const RULE_FEATURES$34 = ["MOD"];
var no_component_will_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `componentWillUpdate` with `UNSAFE_componentWillUpdate`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$34
		},
		fixable: "code",
		messages: { noComponentWillUpdate: "[Deprecated] Use 'UNSAFE_componentWillUpdate' instead." },
		schema: []
	},
	name: RULE_NAME$35,
	create: create$35,
	defaultOptions: []
});
function create$35(context) {
	if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (ER.isComponentWillUpdate(member)) context.report({
					messageId: "noComponentWillUpdate",
					node: member,
					fix(fixer) {
						if (!("key" in member)) return null;
						return fixer.replaceText(member.key, "UNSAFE_componentWillUpdate");
					}
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-context-provider.ts
const RULE_NAME$34 = "no-context-provider";
const RULE_FEATURES$33 = ["MOD"];
var no_context_provider_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replace usages of `<Context.Provider>` with `<Context>`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$33
		},
		fixable: "code",
		messages: { noContextProvider: "In React 19, you can render '<Context>' as a provider instead of '<Context.Provider>'." },
		schema: []
	},
	name: RULE_NAME$34,
	create: create$34,
	defaultOptions: []
});
function create$34(context) {
	if (!context.sourceCode.text.includes("Provider")) return {};
	const { version: version$1 } = getSettingsFromContext(context);
	if (compare(version$1, "19.0.0", "<")) return {};
	return { JSXElement(node) {
		const parts = ER.getElementType(context, node).split(".");
		const selfName = parts.pop();
		const contextFullName = parts.join(".");
		const contextSelfName = parts.pop();
		if (selfName !== "Provider") return;
		if (contextSelfName == null) return;
		context.report({
			messageId: "noContextProvider",
			node,
			fix(fixer) {
				if (!ER.isComponentNameLoose(contextSelfName)) return null;
				const openingElement = node.openingElement;
				const closingElement = node.closingElement;
				if (closingElement == null) return fixer.replaceText(openingElement.name, contextFullName);
				return [fixer.replaceText(openingElement.name, contextFullName), fixer.replaceText(closingElement.name, contextFullName)];
			}
		});
	} };
}

//#endregion
//#region src/rules/no-create-ref.ts
const RULE_NAME$33 = "no-create-ref";
const RULE_FEATURES$32 = [];
var no_create_ref_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `createRef` in function components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$32
		},
		messages: { noCreateRef: "[Deprecated] Use 'useRef' instead." },
		schema: []
	},
	name: RULE_NAME$33,
	create: create$33,
	defaultOptions: []
});
function create$33(context) {
	return { CallExpression(node) {
		if (ER.isCreateRefCall(context, node) && AST.findParentNode(node, ER.isClassComponent) == null) context.report({
			messageId: "noCreateRef",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-default-props.ts
const RULE_NAME$32 = "no-default-props";
const RULE_FEATURES$31 = [];
var no_default_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `defaultProps` property in favor of ES6 default parameters.",
			[Symbol.for("rule_features")]: RULE_FEATURES$31
		},
		messages: { noDefaultProps: "[Deprecated] Use ES6 default parameters instead." },
		schema: []
	},
	name: RULE_NAME$32,
	create: create$32,
	defaultOptions: []
});
function create$32(context) {
	if (!context.sourceCode.text.includes("defaultProps")) return {};
	return { AssignmentExpression(node) {
		if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) return;
		const { object, property } = node.left;
		if (object.type !== AST_NODE_TYPES.Identifier) return;
		if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "defaultProps") return;
		if (!ER.isComponentNameLoose(object.name)) return;
		const variable = VAR.findVariable(object.name, context.sourceCode.getScope(node));
		const variableNode = VAR.getVariableInitNode(variable, 0);
		if (variableNode == null) return;
		if (!AST.isFunction(variableNode)) return;
		context.report({
			messageId: "noDefaultProps",
			node: property
		});
	} };
}

//#endregion
//#region src/rules/no-direct-mutation-state.ts
const RULE_NAME$31 = "no-direct-mutation-state";
const RULE_FEATURES$30 = [];
function isConstructorFunction(node) {
	return AST.isOneOf([AST_NODE_TYPES.FunctionDeclaration, AST_NODE_TYPES.FunctionExpression])(node) && AST.isMethodOrProperty(node.parent) && node.parent.key.type === AST_NODE_TYPES.Identifier && node.parent.key.name === "constructor";
}
var no_direct_mutation_state_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow direct mutation of `this.state`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$30
		},
		messages: { noDirectMutationState: "Do not mutate state directly. Use 'setState()' instead." },
		schema: []
	},
	name: RULE_NAME$31,
	create: create$31,
	defaultOptions: []
});
function create$31(context) {
	return { AssignmentExpression(node) {
		if (!ER.isAssignmentToThisState(node)) return;
		const parentClass = AST.findParentNode(node, AST.isOneOf([AST_NODE_TYPES.ClassDeclaration, AST_NODE_TYPES.ClassExpression]));
		if (parentClass == null) return;
		if (ER.isClassComponent(parentClass) && context.sourceCode.getScope(node).block !== AST.findParentNode(node, isConstructorFunction)) context.report({
			messageId: "noDirectMutationState",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-duplicate-key.ts
const RULE_NAME$30 = "no-duplicate-key";
const RULE_FEATURES$29 = [];
var no_duplicate_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow duplicate `key` on elements in the same array or a list of `children`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$29
		},
		messages: { noDuplicateKey: "A key must be unique. '{{value}}' is duplicated." },
		schema: []
	},
	name: RULE_NAME$30,
	create: create$30,
	defaultOptions: []
});
function create$30(context) {
	if (!context.sourceCode.getText().includes("key=")) return {};
	const keyedEntries = /* @__PURE__ */ new Map();
	function isKeyValueEqual(a, b) {
		const aValue = a.value;
		const bValue = b.value;
		if (aValue == null || bValue == null) return false;
		return AST.isNodeEqual(aValue, bValue);
	}
	return {
		"JSXAttribute[name.name='key']"(node) {
			const jsxElement = node.parent.parent;
			switch (jsxElement.parent.type) {
				case AST_NODE_TYPES.ArrayExpression:
				case AST_NODE_TYPES.JSXElement:
				case AST_NODE_TYPES.JSXFragment: {
					const root = jsxElement.parent;
					const prevKeys = keyedEntries.get(root)?.keys ?? [];
					keyedEntries.set(root, {
						hasDuplicate: prevKeys.some((prevKey) => isKeyValueEqual(prevKey, node)),
						keys: [...prevKeys, node],
						root: jsxElement.parent
					});
					break;
				}
				default: {
					const call = AST.findParentNode(jsxElement, AST.isArrayMapCall);
					const iter = AST.findParentNode(jsxElement, (n) => n === call || AST.isFunction(n));
					if (!AST.isFunction(iter)) return;
					const arg0 = call?.arguments[0];
					if (call == null || arg0 == null) return;
					if (AST.getJSExpression(arg0) !== iter) return;
					keyedEntries.set(call, {
						hasDuplicate: node.value?.type === AST_NODE_TYPES.Literal,
						keys: [node],
						root: call
					});
				}
			}
		},
		"Program:exit"() {
			for (const { hasDuplicate, keys } of keyedEntries.values()) {
				if (!hasDuplicate) continue;
				for (const key of keys) context.report({
					messageId: "noDuplicateKey",
					node: key,
					data: { value: context.sourceCode.getText(key) }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-forward-ref.ts
const RULE_NAME$29 = "no-forward-ref";
const RULE_FEATURES$28 = ["MOD"];
var no_forward_ref_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replaces usages of `forwardRef` with passing `ref` as a prop.",
			[Symbol.for("rule_features")]: RULE_FEATURES$28
		},
		fixable: "code",
		messages: { noForwardRef: "In React 19, 'forwardRef' is no longer necessary. Pass 'ref' as a prop instead." },
		schema: []
	},
	name: RULE_NAME$29,
	create: create$29,
	defaultOptions: []
});
function create$29(context) {
	if (!context.sourceCode.text.includes("forwardRef")) return {};
	const { version: version$1 } = getSettingsFromContext(context);
	if (compare(version$1, "19.0.0", "<")) return {};
	return { CallExpression(node) {
		if (!ER.isForwardRefCall(context, node)) return;
		const id = AST.getFunctionId(node);
		const fix = canFix$1(context, node) ? getFix$1(context, node) : null;
		context.report({
			messageId: "noForwardRef",
			node: id ?? node,
			fix
		});
	} };
}
/**
* Determines whether the given CallExpression can be safely auto-fixed by replacing
* the usage of `forwardRef` with passing `ref` as a prop.
*
* @param context - The rule context object.
* @param node - The CallExpression node to check.
* @returns True if the call can be auto-fixed, false otherwise.
*/
function canFix$1(context, node) {
	const { importSource } = getSettingsFromContext(context);
	const initialScope = context.sourceCode.getScope(node);
	switch (node.callee.type) {
		case AST_NODE_TYPES.Identifier: return ER.isInitializedFromReact(node.callee.name, importSource, initialScope);
		case AST_NODE_TYPES.MemberExpression: return node.callee.object.type === AST_NODE_TYPES.Identifier && ER.isInitializedFromReact(node.callee.object.name, importSource, initialScope);
		default: return false;
	}
}
function getFix$1(context, node) {
	return (fixer) => {
		const [componentNode] = node.arguments;
		if (componentNode == null || !AST.isFunction(componentNode)) return [];
		return [
			fixer.removeRange([node.range[0], componentNode.range[0]]),
			fixer.removeRange([componentNode.range[1], node.range[1]]),
			...getComponentPropsFixes(context, fixer, componentNode, node.typeArguments?.params ?? [])
		];
	};
}
function getComponentPropsFixes(context, fixer, node, typeArguments) {
	const getText = (node$1) => context.sourceCode.getText(node$1);
	const [arg0, arg1] = node.params;
	const [typeArg0, typeArg1] = typeArguments;
	if (arg0 == null) return [];
	const fixedArg0Text = match(arg0).with({ type: AST_NODE_TYPES.Identifier }, (n) => `...${n.name}`).with({ type: AST_NODE_TYPES.ObjectPattern }, (n) => n.properties.map(getText).join(", ")).otherwise(() => null);
	const fixedArg1Text = match(arg1).with(P.nullish, () => "ref").with({
		type: AST_NODE_TYPES.Identifier,
		name: "ref"
	}, () => "ref").with({
		type: AST_NODE_TYPES.Identifier,
		name: P.string
	}, (n) => `ref: ${n.name}`).otherwise(() => null);
	if (fixedArg0Text == null || fixedArg1Text == null) return [];
	if (typeArg0 == null || typeArg1 == null) return [fixer.replaceText(arg0, [
		"{",
		fixedArg1Text + ",",
		fixedArg0Text,
		"}"
	].join(" ")), ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]];
	const typeArg0Text = getText(typeArg0);
	const typeArg1Text = getText(typeArg1);
	return [fixer.replaceText(arg0, [
		"{",
		fixedArg1Text + ",",
		fixedArg0Text,
		"}:",
		typeArg1Text,
		"&",
		"{",
		`ref?:`,
		`React.RefObject<${typeArg0Text} | null>`,
		"}"
	].join(" ")), ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]];
}

//#endregion
//#region src/rules/no-implicit-key.ts
const RULE_NAME$28 = "no-implicit-key";
const RULE_FEATURES$27 = ["EXP"];
var no_implicit_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents `key` from not being explicitly specified (e.g. spreading `key` from objects).",
			[Symbol.for("rule_features")]: RULE_FEATURES$27
		},
		messages: { noImplicitKey: "Do not use implicit 'key' props." },
		schema: []
	},
	name: RULE_NAME$28,
	create: create$28,
	defaultOptions: []
});
function create$28(context) {
	return { JSXOpeningElement(node) {
		const initialScope = context.sourceCode.getScope(node);
		const keyProp = ER.getAttribute(context, "key", node.attributes, initialScope);
		const isKeyPropOnElement = node.attributes.some((n) => n.type === AST_NODE_TYPES.JSXAttribute && n.name.type === AST_NODE_TYPES.JSXIdentifier && n.name.name === "key");
		if (keyProp != null && !isKeyPropOnElement) context.report({
			messageId: "noImplicitKey",
			node: keyProp
		});
	} };
}

//#endregion
//#region src/rules/no-leaked-conditional-rendering.ts
const RULE_NAME$27 = "no-leaked-conditional-rendering";
const RULE_FEATURES$26 = ["TSC"];
const tsHelpers = {
	isAnyType: (type) => isTypeFlagSet(type, ts.TypeFlags.TypeParameter | ts.TypeFlags.Any),
	isBigIntType: (type) => isTypeFlagSet(type, ts.TypeFlags.BigIntLike),
	isBooleanType: (type) => isTypeFlagSet(type, ts.TypeFlags.BooleanLike),
	isEnumType: (type) => isTypeFlagSet(type, ts.TypeFlags.EnumLike),
	isFalsyBigIntType: (type) => type.isLiteral() && isMatching({ value: { base10Value: "0" } }, type),
	isFalsyNumberType: (type) => type.isNumberLiteral() && type.value === 0,
	isFalsyStringType: (type) => type.isStringLiteral() && type.value === "",
	isNeverType: (type) => isTypeFlagSet(type, ts.TypeFlags.Never),
	isNullishType: (type) => isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike),
	isNumberType: (type) => isTypeFlagSet(type, ts.TypeFlags.NumberLike),
	isObjectType: (type) => !isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike | ts.TypeFlags.BooleanLike | ts.TypeFlags.StringLike | ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike | ts.TypeFlags.TypeParameter | ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.Never),
	isStringType: (type) => isTypeFlagSet(type, ts.TypeFlags.StringLike),
	isTruthyBigIntType: (type) => type.isLiteral() && isMatching({ value: { base10Value: P.not("0") } }, type),
	isTruthyNumberType: (type) => type.isNumberLiteral() && type.value !== 0,
	isTruthyStringType: (type) => type.isStringLiteral() && type.value !== "",
	isUnknownType: (type) => isTypeFlagSet(type, ts.TypeFlags.Unknown)
};
/**
* Ported from https://github.com/typescript-eslint/typescript-eslint/blob/eb736bbfc22554694400e6a4f97051d845d32e0b/packages/eslint-plugin/src/rules/strict-boolean-expressions.ts#L826 with some enhancements
* Check union variants for the types we care about
* @param types The types to inspect
* @returns The variant types found
*/
function inspectVariantTypes(types) {
	const variantTypes = /* @__PURE__ */ new Set();
	if (types.some(tsHelpers.isUnknownType)) {
		variantTypes.add("unknown");
		return variantTypes;
	}
	if (types.some(tsHelpers.isNullishType)) variantTypes.add("nullish");
	const booleans = types.filter(tsHelpers.isBooleanType);
	const boolean0 = booleans[0];
	if (booleans.length === 1 && boolean0 != null) {
		if (isFalseLiteralType(boolean0)) variantTypes.add("falsy boolean");
		else if (isTrueLiteralType(boolean0)) variantTypes.add("truthy boolean");
	} else if (booleans.length === 2) variantTypes.add("boolean");
	const strings = types.filter(tsHelpers.isStringType);
	if (strings.length > 0) {
		const evaluated = match(strings).when((types$1) => types$1.every(tsHelpers.isTruthyStringType), () => "truthy string").when((types$1) => types$1.every(tsHelpers.isFalsyStringType), () => "falsy string").otherwise(() => "string");
		variantTypes.add(evaluated);
	}
	const bigints = types.filter(tsHelpers.isBigIntType);
	if (bigints.length > 0) {
		const evaluated = match(bigints).when((types$1) => types$1.every(tsHelpers.isTruthyBigIntType), () => "truthy bigint").when((types$1) => types$1.every(tsHelpers.isFalsyBigIntType), () => "falsy bigint").otherwise(() => "bigint");
		variantTypes.add(evaluated);
	}
	const numbers = types.filter(tsHelpers.isNumberType);
	if (numbers.length > 0) {
		const evaluated = match(numbers).when((types$1) => types$1.every(tsHelpers.isTruthyNumberType), () => "truthy number").when((types$1) => types$1.every(tsHelpers.isFalsyNumberType), () => "falsy number").otherwise(() => "number");
		variantTypes.add(evaluated);
	}
	if (types.some(tsHelpers.isEnumType)) variantTypes.add("enum");
	if (types.some(tsHelpers.isObjectType)) variantTypes.add("object");
	if (types.some(tsHelpers.isAnyType)) variantTypes.add("any");
	if (types.some(tsHelpers.isNeverType)) variantTypes.add("never");
	return variantTypes;
}
var no_leaked_conditional_rendering_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents problematic leaked values from being rendered.",
			[Symbol.for("rule_features")]: RULE_FEATURES$26
		},
		messages: { noLeakedConditionalRendering: "Potential leaked value {{value}} that might cause unintentionally rendered values or rendering crashes." },
		schema: []
	},
	name: RULE_NAME$27,
	create: create$27,
	defaultOptions: []
});
function create$27(context) {
	if (!context.sourceCode.text.includes("&&")) return {};
	const { version: version$1 } = getSettingsFromContext(context);
	const allowedVariants = [
		"any",
		"boolean",
		"nullish",
		"object",
		"falsy boolean",
		"truthy bigint",
		"truthy boolean",
		"truthy number",
		"truthy string",
		...compare(version$1, "18.0.0", "<") ? [] : ["string", "falsy string"]
	];
	const services = ESLintUtils.getParserServices(context, false);
	function getReportDescriptor(node) {
		if (node == null) return unit;
		if (AST.is(AST_NODE_TYPES.JSXExpressionContainer)(node)) return getReportDescriptor(node.expression);
		if (AST.isJSX(node)) return unit;
		if (AST.isTypeExpression(node)) return getReportDescriptor(node.expression);
		return match(node).with({
			type: AST_NODE_TYPES.LogicalExpression,
			operator: "&&"
		}, ({ left, right }) => {
			if (left.type === AST_NODE_TYPES.UnaryExpression && left.operator === "!") return getReportDescriptor(right);
			const initialScope = context.sourceCode.getScope(left);
			if (left.type === AST_NODE_TYPES.Identifier && left.name === "NaN" || VAR.toStaticValue({
				kind: "lazy",
				node: left,
				initialScope
			}).value === "NaN") return {
				messageId: "noLeakedConditionalRendering",
				node: left,
				data: { value: context.sourceCode.getText(left) }
			};
			const leftType = getConstrainedTypeAtLocation(services, left);
			const leftTypeVariants = inspectVariantTypes(unionTypeParts(leftType));
			if (Array.from(leftTypeVariants.values()).every((type) => allowedVariants.some((allowed) => allowed === type))) return getReportDescriptor(right);
			return {
				messageId: "noLeakedConditionalRendering",
				node: left,
				data: { value: context.sourceCode.getText(left) }
			};
		}).with({ type: AST_NODE_TYPES.ConditionalExpression }, ({ alternate, consequent }) => {
			return getReportDescriptor(consequent) ?? getReportDescriptor(alternate);
		}).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
			const variableDefNode = VAR.findVariable(n.name, context.sourceCode.getScope(n))?.defs.at(0)?.node;
			return match(variableDefNode).with({ init: P.select({ type: P.not(AST_NODE_TYPES.VariableDeclaration) }) }, getReportDescriptor).otherwise(() => unit);
		}).otherwise(() => unit);
	}
	return { JSXExpressionContainer: flow(getReportDescriptor, Reporter.make(context).send) };
}

//#endregion
//#region src/rules/no-missing-component-display-name.ts
const RULE_NAME$26 = "no-missing-component-display-name";
const RULE_FEATURES$25 = [];
var no_missing_component_display_name_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces that all components have a `displayName` which can be used in devtools.",
			[Symbol.for("rule_features")]: RULE_FEATURES$25
		},
		messages: { noMissingComponentDisplayName: "Add missing 'displayName' for component." },
		schema: []
	},
	name: RULE_NAME$26,
	create: create$26,
	defaultOptions: []
});
function create$26(context) {
	if (!context.sourceCode.text.includes("memo") && !context.sourceCode.text.includes("forwardRef")) return {};
	const { ctx, listeners } = ER.useComponentCollector(context, {
		collectDisplayName: true,
		collectHookCalls: false,
		hint: ER.DEFAULT_COMPONENT_DETECTION_HINT
	});
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node, displayName, flag } of components.values()) {
				const isMemoOrForwardRef = (flag & (ER.ComponentFlag.ForwardRef | ER.ComponentFlag.Memo)) > 0n;
				if (AST.getFunctionId(node) != null) continue;
				if (!isMemoOrForwardRef) continue;
				if (displayName == null) {
					const id = AST.getFunctionId(node);
					context.report({
						messageId: "noMissingComponentDisplayName",
						node: id ?? node
					});
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-missing-context-display-name.ts
const RULE_NAME$25 = "no-missing-context-display-name";
const RULE_FEATURES$24 = ["FIX"];
var no_missing_context_display_name_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces that all contexts have a `displayName` which can be used in devtools.",
			[Symbol.for("rule_features")]: RULE_FEATURES$24
		},
		fixable: "code",
		messages: { noMissingContextDisplayName: "Add missing 'displayName' for context." },
		schema: []
	},
	name: RULE_NAME$25,
	create: create$25,
	defaultOptions: []
});
function create$25(context) {
	if (!context.sourceCode.text.includes("createContext")) return {};
	const createCalls = [];
	const displayNameAssignments = [];
	return {
		CallExpression(node) {
			if (!ER.isCreateContextCall(context, node)) return;
			createCalls.push(node);
		},
		"Program:exit"() {
			for (const call of createCalls) {
				const id = ER.getInstanceId(call);
				if (id == null) {
					context.report({
						messageId: "noMissingContextDisplayName",
						node: call
					});
					continue;
				}
				if (!displayNameAssignments.some((node) => {
					const left = node.left;
					if (left.type !== AST_NODE_TYPES.MemberExpression) return false;
					const object = left.object;
					return ER.isInstanceIdEqual(context, id, object);
				})) {
					const semi = LanguagePreference.defaultLanguagePreference.semicolons === "always" ? ";" : "";
					context.report({
						messageId: "noMissingContextDisplayName",
						node: id,
						fix(fixer) {
							if (id.type !== AST_NODE_TYPES.Identifier || id.parent !== call.parent) return [];
							return fixer.insertTextAfter(context.sourceCode.getTokenAfter(call) ?? call, [
								"\n",
								id.name,
								".",
								"displayName",
								" ",
								"=",
								" ",
								JSON.stringify(id.name),
								semi
							].join(""));
						}
					});
				}
			}
		},
		[Selector.DISPLAY_NAME_ASSIGNMENT_EXPRESSION](node) {
			displayNameAssignments.push(node);
		}
	};
}

//#endregion
//#region src/rules/no-missing-key.ts
const RULE_NAME$24 = "no-missing-key";
const RULE_FEATURES$23 = [];
var no_missing_key_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow missing `key` on items in list rendering.",
			[Symbol.for("rule_features")]: RULE_FEATURES$23
		},
		messages: {
			missingKey: "Missing 'key' for element when rendering list.",
			unexpectedFragmentSyntax: "Use fragment component instead of '<>' because it does not support `key`."
		},
		schema: []
	},
	name: RULE_NAME$24,
	create: create$24,
	defaultOptions: []
});
function create$24(context) {
	const report = Reporter.make(context);
	const state = { isWithinChildrenToArray: false };
	function checkIteratorElement(node) {
		switch (node.type) {
			case AST_NODE_TYPES.JSXElement: {
				const initialScope = context.sourceCode.getScope(node);
				if (!ER.hasAttribute(context, "key", node.openingElement.attributes, initialScope)) return {
					messageId: "missingKey",
					node
				};
				return null;
			}
			case AST_NODE_TYPES.JSXFragment: return {
				messageId: "unexpectedFragmentSyntax",
				node
			};
			default: return null;
		}
	}
	function checkExpression(node) {
		switch (node.type) {
			case AST_NODE_TYPES.ConditionalExpression:
				if ("consequent" in node) return checkIteratorElement(node.consequent) ?? checkIteratorElement(node.alternate);
				return null;
			case AST_NODE_TYPES.JSXElement:
			case AST_NODE_TYPES.JSXFragment: return checkIteratorElement(node);
			case AST_NODE_TYPES.LogicalExpression:
				if ("left" in node) return checkIteratorElement(node.left) ?? checkIteratorElement(node.right);
				return null;
			default: return null;
		}
	}
	function checkBlockStatement(node) {
		const descriptors = [];
		for (const statement of AST.getNestedReturnStatements(node)) {
			if (statement.argument == null) continue;
			const descriptor = checkIteratorElement(statement.argument);
			if (descriptor != null) descriptors.push(descriptor);
		}
		return descriptors;
	}
	return {
		ArrayExpression(node) {
			if (state.isWithinChildrenToArray) return;
			const elements = node.elements.filter(AST.is(AST_NODE_TYPES.JSXElement));
			if (elements.length === 0) return;
			const initialScope = context.sourceCode.getScope(node);
			for (const element of elements) if (!ER.hasAttribute(context, "key", element.openingElement.attributes, initialScope)) report.send({
				messageId: "missingKey",
				node: element
			});
		},
		CallExpression(node) {
			state.isWithinChildrenToArray ||= ER.isChildrenToArrayCall(context, node);
			if (state.isWithinChildrenToArray) return;
			const callback = match(node).when(AST.isArrayMapCall, (n) => n.arguments[0]).when(AST.isArrayFromCall, (n) => n.arguments[1]).otherwise(() => null);
			if (!AST.isFunction(callback)) return;
			const body = callback.body;
			if (body.type === AST_NODE_TYPES.BlockStatement) {
				checkBlockStatement(body).forEach(report.send);
				return;
			}
			report.send(checkExpression(body));
		},
		"CallExpression:exit"(node) {
			if (!ER.isChildrenToArrayCall(context, node)) return;
			state.isWithinChildrenToArray = false;
		},
		JSXFragment(node) {
			if (state.isWithinChildrenToArray) return;
			if (node.parent.type === AST_NODE_TYPES.ArrayExpression) report.send({
				messageId: "unexpectedFragmentSyntax",
				node
			});
		}
	};
}

//#endregion
//#region src/rules/no-misused-capture-owner-stack.ts
const RULE_NAME$23 = "no-misused-capture-owner-stack";
const RULE_FEATURES$22 = ["EXP"];
var no_misused_capture_owner_stack_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents incorrect usage of `captureOwnerStack`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$22
		},
		fixable: "code",
		messages: {
			useNamespaceImport: "Don't use named imports of 'captureOwnerStack' in files that are bundled for development and production. Use a namespace import instead.",
			missingDevelopmentOnlyCheck: `Don't call 'captureOwnerStack' directly. Use 'if (process.env.NODE_ENV !== "production") {...}' to conditionally access it.`
		},
		schema: []
	},
	name: RULE_NAME$23,
	create: create$23,
	defaultOptions: []
});
function create$23(context) {
	if (!context.sourceCode.text.includes("captureOwnerStack")) return {};
	const { importSource } = getSettingsFromContext(context);
	return {
		CallExpression(node) {
			if (!ER.isCaptureOwnerStackCall(context, node)) return;
			if (AST.findParentNode(node, isDevelopmentOnlyCheck) == null) context.report({
				messageId: "missingDevelopmentOnlyCheck",
				node
			});
		},
		ImportDeclaration(node) {
			if (node.source.value !== importSource) return;
			for (const specifier of node.specifiers) {
				if (specifier.type !== AST_NODE_TYPES.ImportSpecifier) continue;
				if (specifier.imported.type !== AST_NODE_TYPES.Identifier) continue;
				if (specifier.imported.name === "captureOwnerStack") context.report({
					messageId: "useNamespaceImport",
					node: specifier
				});
			}
		}
	};
}
function isDevelopmentOnlyCheck(node) {
	if (node.type !== AST_NODE_TYPES.IfStatement) return false;
	if (AST.isProcessEnvNodeEnvCompare(node.test, "!==", "production")) return true;
	return false;
}

//#endregion
//#region src/rules/no-nested-component-definitions.ts
const RULE_NAME$22 = "no-nested-component-definitions";
const RULE_FEATURES$21 = [];
var no_nested_component_definitions_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow nesting component definitions inside other components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$21
		},
		messages: { noNestedComponentDefinitions: "Do not nest component definitions inside other components or props. {{suggestion}}" },
		schema: []
	},
	name: RULE_NAME$22,
	create: create$22,
	defaultOptions: []
});
function create$22(context) {
	const hint = ER.ComponentDetectionHint.SkipArrayMapArgument | ER.ComponentDetectionHint.SkipNullLiteral | ER.ComponentDetectionHint.SkipUndefined | ER.ComponentDetectionHint.SkipBooleanLiteral | ER.ComponentDetectionHint.SkipStringLiteral | ER.ComponentDetectionHint.SkipNumberLiteral | ER.ComponentDetectionHint.StrictLogical | ER.ComponentDetectionHint.StrictConditional;
	const collector = ER.useComponentCollector(context, { hint });
	const collectorLegacy = ER.useComponentCollectorLegacy();
	return {
		...collector.listeners,
		...collectorLegacy.listeners,
		"Program:exit"(program) {
			const functionComponents = [...collector.ctx.getAllComponents(program).values()];
			const classComponents = [...collectorLegacy.ctx.getAllComponents(program).values()];
			const isFunctionComponent = (node) => {
				return AST.isFunction(node) && functionComponents.some((component) => component.node === node);
			};
			const isClassComponent = (node) => {
				return AST.isClass(node) && classComponents.some((component) => component.node === node);
			};
			for (const { name: name$4, node: component } of functionComponents) {
				if (name$4 == null) continue;
				if (ER.isDirectValueOfRenderPropertyLoose(component)) continue;
				if (isInsideJSXAttributeValue(component)) {
					if (!ER.isDeclaredInRenderPropLoose(component)) context.report({
						messageId: "noNestedComponentDefinitions",
						node: component,
						data: {
							name: name$4,
							suggestion: "Move it to the top level or pass it as a prop."
						}
					});
					continue;
				}
				if (isInsideCreateElementProps(context, component)) {
					context.report({
						messageId: "noNestedComponentDefinitions",
						node: component,
						data: {
							name: name$4,
							suggestion: "Move it to the top level or pass it as a prop."
						}
					});
					continue;
				}
				const parentComponent = AST.findParentNode(component, isFunctionComponent);
				if (parentComponent != null && !ER.isDirectValueOfRenderPropertyLoose(parentComponent)) {
					context.report({
						messageId: "noNestedComponentDefinitions",
						node: component,
						data: {
							name: name$4,
							suggestion: component.parent.type === AST_NODE_TYPES.Property ? "Move it to the top level or pass it as a prop." : "Move it to the top level."
						}
					});
					continue;
				}
				if (ER.isInsideRenderMethod(component)) context.report({
					messageId: "noNestedComponentDefinitions",
					node: component,
					data: {
						name: name$4,
						suggestion: "Move it to the top level."
					}
				});
			}
			for (const { name: name$4 = "unknown", node: component } of classComponents) {
				if (AST.findParentNode(component, (n) => isClassComponent(n) || isFunctionComponent(n)) == null) continue;
				context.report({
					messageId: "noNestedComponentDefinitions",
					node: component,
					data: {
						name: name$4,
						suggestion: component.parent.type === AST_NODE_TYPES.Property ? "Move it to the top level or pass it as a prop." : "Move it to the top level."
					}
				});
			}
		}
	};
}
/**
* Determines whether the node is inside JSX attribute value
* @param node The AST node to check
* @returns `true` if the node is inside JSX attribute value
*/
function isInsideJSXAttributeValue(node) {
	return node.parent.type === AST_NODE_TYPES.JSXAttribute || ER.findParentAttribute(node, (n) => n.value?.type === AST_NODE_TYPES.JSXExpressionContainer) != null;
}
/**
* Determines whether inside `createElement`'s props.
* @param context The rule context
* @param node The AST node to check
* @returns `true` if the node is inside createElement's props
*/
function isInsideCreateElementProps(context, node) {
	const call = AST.findParentNode(node, ER.isCreateElementCall(context));
	if (call == null) return false;
	const prop = AST.findParentNode(node, AST.is(AST_NODE_TYPES.ObjectExpression));
	if (prop == null) return false;
	return prop === call.arguments[1];
}

//#endregion
//#region src/rules/no-nested-lazy-component-declarations.ts
const RULE_NAME$21 = "no-nested-lazy-component-declarations";
const RULE_FEATURES$20 = [];
var no_nested_lazy_component_declarations_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow nesting lazy component declarations inside other components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$20
		},
		messages: { noNestedLazyComponentDeclarations: "Do not declare lazy components inside other components. Instead, always declare them at the top level of your module." },
		schema: []
	},
	name: RULE_NAME$21,
	create: create$21,
	defaultOptions: []
});
function create$21(context) {
	const hint = ER.ComponentDetectionHint.None;
	const collector = ER.useComponentCollector(context, { hint });
	const collectorLegacy = ER.useComponentCollectorLegacy();
	const lazyComponentDeclarations = /* @__PURE__ */ new Set();
	return {
		...collector.listeners,
		...collectorLegacy.listeners,
		ImportExpression(node) {
			const lazyCall = AST.findParentNode(node, (n) => ER.isLazyCall(context, n));
			if (lazyCall != null) lazyComponentDeclarations.add(lazyCall);
		},
		"Program:exit"(program) {
			const functionComponents = [...collector.ctx.getAllComponents(program).values()];
			const classComponents = [...collectorLegacy.ctx.getAllComponents(program).values()];
			for (const lazy of lazyComponentDeclarations) if (AST.findParentNode(lazy, (n) => {
				if (AST.isJSX(n)) return true;
				if (n.type === AST_NODE_TYPES.CallExpression) return ER.isReactHookCall(n) || ER.isCreateElementCall(context, n) || ER.isCreateContextCall(context, n);
				if (AST.isFunction(n)) return functionComponents.some((c) => c.node === n);
				if (AST.isClass(n)) return classComponents.some((c) => c.node === n);
				return false;
			}) != null) context.report({
				messageId: "noNestedLazyComponentDeclarations",
				node: lazy
			});
		}
	};
}

//#endregion
//#region src/rules/no-prop-types.ts
const RULE_NAME$20 = "no-prop-types";
const RULE_FEATURES$19 = [];
var no_prop_types_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `propTypes` in favor of TypeScript or another type-checking solution.",
			[Symbol.for("rule_features")]: RULE_FEATURES$19
		},
		messages: { noPropTypes: "[Deprecated] Use TypeScript or another type-checking solution instead." },
		schema: []
	},
	name: RULE_NAME$20,
	create: create$20,
	defaultOptions: []
});
function create$20(context) {
	if (!context.sourceCode.text.includes("propTypes")) return {};
	return {
		AssignmentExpression(node) {
			if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) return;
			const { object, property } = node.left;
			if (object.type !== AST_NODE_TYPES.Identifier) return;
			if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "propTypes") return;
			if (!ER.isComponentNameLoose(object.name)) return;
			const variable = VAR.findVariable(object.name, context.sourceCode.getScope(node));
			const variableNode = VAR.getVariableInitNode(variable, 0);
			if (variableNode != null && (AST.isFunction(variableNode) || ER.isClassComponent(variableNode))) context.report({
				messageId: "noPropTypes",
				node: property
			});
		},
		PropertyDefinition(node) {
			if (!ER.isClassComponent(node.parent.parent)) return;
			if (!node.static || node.key.type !== AST_NODE_TYPES.Identifier || node.key.name !== "propTypes") return;
			context.report({
				messageId: "noPropTypes",
				node
			});
		}
	};
}

//#endregion
//#region src/rules/no-redundant-should-component-update.ts
const RULE_NAME$19 = "no-redundant-should-component-update";
const RULE_FEATURES$18 = [];
function isShouldComponentUpdate(node) {
	return AST.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
var no_redundant_should_component_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow `shouldComponentUpdate` when extending `React.PureComponent`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$18
		},
		messages: { noRedundantShouldComponentUpdate: "'{{componentName}}' does not need 'shouldComponentUpdate' when extending 'React.PureComponent'." },
		schema: []
	},
	name: RULE_NAME$19,
	create: create$19,
	defaultOptions: []
});
function create$19(context) {
	if (!context.sourceCode.text.includes("shouldComponentUpdate")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { name: name$4 = "PureComponent", node: component, flag } of components.values()) {
				if ((flag & ER.ComponentFlag.PureComponent) === 0n) continue;
				const { body } = component.body;
				for (const member of body) if (isShouldComponentUpdate(member)) context.report({
					messageId: "noRedundantShouldComponentUpdate",
					node: member,
					data: { componentName: name$4 }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-set-state-in-component-did-mount.ts
const RULE_NAME$18 = "no-set-state-in-component-did-mount";
const RULE_FEATURES$17 = [];
var no_set_state_in_component_did_mount_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow calling `this.setState` in `componentDidMount` outside of functions, such as callbacks.",
			[Symbol.for("rule_features")]: RULE_FEATURES$17
		},
		messages: { noSetStateInComponentDidMount: "Do not call `this.setState` in `componentDidMount` outside of functions, such as callbacks." },
		schema: []
	},
	name: RULE_NAME$18,
	create: create$18,
	defaultOptions: []
});
function create$18(context) {
	if (!context.sourceCode.text.includes("componentDidMount")) return {};
	return { CallExpression(node) {
		if (!ER.isThisSetState(node)) return;
		const clazz = AST.findParentNode(node, ER.isClassComponent);
		const method = AST.findParentNode(node, (n) => n === clazz || ER.isComponentDidMount(n));
		if (clazz == null || method == null || method === clazz) return;
		const methodScope = context.sourceCode.getScope(method);
		const upperScope = context.sourceCode.getScope(node).upper;
		if (method.parent === clazz.body && upperScope === methodScope) context.report({
			messageId: "noSetStateInComponentDidMount",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-set-state-in-component-did-update.ts
const RULE_NAME$17 = "no-set-state-in-component-did-update";
const RULE_FEATURES$16 = [];
var no_set_state_in_component_did_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow calling `this.setState` in `componentDidUpdate` outside of functions, such as callbacks.",
			[Symbol.for("rule_features")]: RULE_FEATURES$16
		},
		messages: { noSetStateInComponentDidUpdate: "Do not call `this.setState` in `componentDidUpdate` outside of functions, such as callbacks." },
		schema: []
	},
	name: RULE_NAME$17,
	create: create$17,
	defaultOptions: []
});
function create$17(context) {
	if (!context.sourceCode.text.includes("componentDidUpdate")) return {};
	return { CallExpression(node) {
		if (!ER.isThisSetState(node)) return;
		const clazz = AST.findParentNode(node, ER.isClassComponent);
		const method = AST.findParentNode(node, (n) => n === clazz || ER.isComponentDidUpdate(n));
		if (clazz == null || method == null || method === clazz) return;
		const methodScope = context.sourceCode.getScope(method);
		const upperScope = context.sourceCode.getScope(node).upper;
		if (method.parent === clazz.body && upperScope === methodScope) context.report({
			messageId: "noSetStateInComponentDidUpdate",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-set-state-in-component-will-update.ts
const RULE_NAME$16 = "no-set-state-in-component-will-update";
const RULE_FEATURES$15 = [];
var no_set_state_in_component_will_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallows calling `this.setState` in `componentWillUpdate` outside of functions, such as callbacks.",
			[Symbol.for("rule_features")]: RULE_FEATURES$15
		},
		messages: { noSetStateInComponentWillUpdate: "Do not call `this.setState` in `componentWillUpdate` outside of functions, such as callbacks." },
		schema: []
	},
	name: RULE_NAME$16,
	create: create$16,
	defaultOptions: []
});
function create$16(context) {
	if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
	return { CallExpression(node) {
		if (!ER.isThisSetState(node)) return;
		const clazz = AST.findParentNode(node, ER.isClassComponent);
		const method = AST.findParentNode(node, (n) => n === clazz || ER.isComponentWillUpdate(n));
		if (clazz == null || method == null || method === clazz) return;
		const methodScope = context.sourceCode.getScope(method);
		const upperScope = context.sourceCode.getScope(node).upper;
		if (method.parent === clazz.body && upperScope === methodScope) context.report({
			messageId: "noSetStateInComponentWillUpdate",
			node
		});
	} };
}

//#endregion
//#region src/rules/no-string-refs.ts
const RULE_NAME$15 = "no-string-refs";
const RULE_FEATURES$14 = ["MOD"];
var no_string_refs_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replaces string refs with callback refs.",
			[Symbol.for("rule_features")]: RULE_FEATURES$14
		},
		fixable: "code",
		messages: { noStringRefs: "[Deprecated] Use callback refs instead." },
		schema: []
	},
	name: RULE_NAME$15,
	create: create$15,
	defaultOptions: []
});
function create$15(context) {
	const state = { isWithinClassComponent: false };
	function onClassBodyEnter(node) {
		if (ER.isClassComponent(node.parent)) state.isWithinClassComponent = true;
	}
	function onClassBodyExit() {
		state.isWithinClassComponent = false;
	}
	return {
		ClassBody: onClassBodyEnter,
		"ClassBody:exit": onClassBodyExit,
		JSXAttribute(node) {
			if (node.name.name !== "ref") return;
			const refNameText = getAttributeValueText(context, node.value);
			if (refNameText == null) return;
			context.report({
				messageId: "noStringRefs",
				node,
				fix(fixer) {
					if (node.value == null) return null;
					if (!state.isWithinClassComponent) return null;
					return fixer.replaceText(node.value, `{(ref) => { this.refs[${refNameText}] = ref; }}`);
				}
			});
		}
	};
}
function getAttributeValueText(context, node) {
	if (node == null) return null;
	switch (true) {
		case node.type === AST_NODE_TYPES.Literal && typeof node.value === "string": return context.sourceCode.getText(node);
		case node.type === AST_NODE_TYPES.JSXExpressionContainer && node.expression.type === AST_NODE_TYPES.Literal && typeof node.expression.value === "string": return context.sourceCode.getText(node.expression);
		case node.type === AST_NODE_TYPES.JSXExpressionContainer && node.expression.type === AST_NODE_TYPES.TemplateLiteral: return context.sourceCode.getText(node.expression);
		default: return null;
	}
}

//#endregion
//#region src/rules/no-unsafe-component-will-mount.ts
const RULE_NAME$14 = "no-unsafe-component-will-mount";
const RULE_FEATURES$13 = [];
function isUnsafeComponentWillMount(node) {
	return AST.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
var no_unsafe_component_will_mount_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns the usage of `UNSAFE_componentWillMount` in class components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$13
		},
		messages: { noUnsafeComponentWillMount: "Do not use 'UNSAFE_componentWillMount'." },
		schema: []
	},
	name: RULE_NAME$14,
	create: create$14,
	defaultOptions: []
});
function create$14(context) {
	if (!context.sourceCode.text.includes("UNSAFE_componentWillMount")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isUnsafeComponentWillMount(member)) context.report({
					messageId: "noUnsafeComponentWillMount",
					node: member
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-unsafe-component-will-receive-props.ts
const RULE_NAME$13 = "no-unsafe-component-will-receive-props";
const RULE_FEATURES$12 = [];
function isUnsafeComponentWillReceiveProps(node) {
	return AST.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
var no_unsafe_component_will_receive_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns the usage of `UNSAFE_componentWillReceiveProps` in class components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$12
		},
		messages: { noUnsafeComponentWillReceiveProps: "Do not use 'UNSAFE_componentWillReceiveProps'." },
		schema: []
	},
	name: RULE_NAME$13,
	create: create$13,
	defaultOptions: []
});
function create$13(context) {
	if (!context.sourceCode.text.includes("UNSAFE_componentWillReceiveProps")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isUnsafeComponentWillReceiveProps(member)) context.report({
					messageId: "noUnsafeComponentWillReceiveProps",
					node: member
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-unsafe-component-will-update.ts
const RULE_NAME$12 = "no-unsafe-component-will-update";
const RULE_FEATURES$11 = [];
function isUnsafeComponentWillUpdate(node) {
	return AST.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
var no_unsafe_component_will_update_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns the usage of `UNSAFE_componentWillUpdate` in class components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$11
		},
		messages: { noUnsafeComponentWillUpdate: "Do not use 'UNSAFE_componentWillUpdate'." },
		schema: []
	},
	name: RULE_NAME$12,
	create: create$12,
	defaultOptions: []
});
function create$12(context) {
	if (!context.sourceCode.text.includes("UNSAFE_componentWillUpdate")) return {};
	const { ctx, listeners } = ER.useComponentCollectorLegacy();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { body } = component.body;
				for (const member of body) if (isUnsafeComponentWillUpdate(member)) context.report({
					messageId: "noUnsafeComponentWillUpdate",
					node: member
				});
			}
		}
	};
}

//#endregion
//#region src/rules/no-unstable-context-value.ts
const RULE_NAME$11 = "no-unstable-context-value";
const RULE_FEATURES$10 = [];
var no_unstable_context_value_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents non-stable values (i.e. object literals) from being used as a value for `Context.Provider`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$10
		},
		messages: { unstableContextValue: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. {{suggestion}}" },
		schema: []
	},
	name: RULE_NAME$11,
	create: create$11,
	defaultOptions: []
});
function create$11(context) {
	const { version: version$1 } = getSettingsFromContext(context);
	const isReact18OrBelow = compare(version$1, "19.0.0", "<");
	const { ctx, listeners } = ER.useComponentCollector(context);
	const constructions = /* @__PURE__ */ new WeakMap();
	return {
		...listeners,
		JSXOpeningElement(node) {
			const selfName = ER.getElementType(context, node.parent).split(".").at(-1);
			if (selfName == null) return;
			if (!isContextName(selfName, isReact18OrBelow)) return;
			const functionEntry = ctx.getCurrentEntry();
			if (functionEntry == null) return;
			const attribute = node.attributes.find((attribute$1) => attribute$1.type === AST_NODE_TYPES.JSXAttribute && attribute$1.name.name === "value");
			if (attribute == null || !("value" in attribute)) return;
			const value = attribute.value;
			if (value?.type !== AST_NODE_TYPES.JSXExpressionContainer) return;
			const valueExpression = value.expression;
			const initialScope = context.sourceCode.getScope(valueExpression);
			const construction = VAR.getConstruction(valueExpression, initialScope);
			if (construction == null) return;
			if (ER.isReactHookCall(construction.node)) return;
			getOrElseUpdate(constructions, functionEntry.node, () => []).push(construction);
		},
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program).values();
			for (const { node: component } of components) for (const construction of constructions.get(component) ?? []) {
				const { kind, node: constructionNode } = construction;
				const suggestion = kind.startsWith("Function") ? "Consider wrapping it in a useCallback hook." : "Consider wrapping it in a useMemo hook.";
				context.report({
					messageId: "unstableContextValue",
					node: constructionNode,
					data: {
						type: AST.toDelimiterCaseType(constructionNode),
						suggestion
					}
				});
			}
		}
	};
}
function isContextName(name$4, isReact18OrBelow) {
	if (name$4 === "Provider") return true;
	if (!isReact18OrBelow) return name$4.endsWith("Context") || name$4.endsWith("CONTEXT");
	return false;
}

//#endregion
//#region src/rules/no-unstable-default-props.ts
const RULE_NAME$10 = "no-unstable-default-props";
const RULE_FEATURES$9 = [];
var no_unstable_default_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Prevents using referential-type values as default props in object destructuring.",
			[Symbol.for("rule_features")]: RULE_FEATURES$9
		},
		messages: { noUnstableDefaultProps: "A/an '{{forbiddenType}}' as default prop. This could lead to potential infinite render loop in React. Use a variable instead of '{{forbiddenType}}'." },
		schema: []
	},
	name: RULE_NAME$10,
	create: create$10,
	defaultOptions: []
});
function create$10(context) {
	const { ctx, listeners } = ER.useComponentCollector(context);
	const declarators = /* @__PURE__ */ new WeakMap();
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const { node: component } of components.values()) {
				const { params } = component;
				const [props] = params;
				if (props == null) continue;
				const properties = match(props).with({ type: AST_NODE_TYPES.ObjectPattern }, ({ properties: properties$1 }) => properties$1).with({ type: AST_NODE_TYPES.Identifier }, ({ name: name$4 }) => {
					return declarators.get(component)?.filter((d) => d.init.name === name$4).flatMap((d) => d.id.properties) ?? [];
				}).otherwise(() => []);
				for (const prop of properties) {
					if (prop.type !== AST_NODE_TYPES.Property || prop.value.type !== AST_NODE_TYPES.AssignmentPattern) continue;
					const { value } = prop;
					const { right } = value;
					const initialScope = context.sourceCode.getScope(value);
					const construction = VAR.getConstruction(value, initialScope, VAR.ConstructionDetectionHint.StrictCallExpression);
					if (construction == null) continue;
					if (ER.isReactHookCall(construction.node)) continue;
					const forbiddenType = AST.toDelimiterCaseType(right);
					context.report({
						messageId: "noUnstableDefaultProps",
						node: right,
						data: { forbiddenType }
					});
				}
			}
		},
		[Selector.OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR](node) {
			const functionEntry = ctx.getCurrentEntry();
			if (functionEntry == null) return;
			getOrElseUpdate(declarators, functionEntry.node, () => []).push(node);
		}
	};
}

//#endregion
//#region src/rules/no-unused-class-component-members.ts
const RULE_NAME$9 = "no-unused-class-component-members";
const RULE_FEATURES$8 = [];
const LIFECYCLE_METHODS = new Set([
	"componentDidCatch",
	"componentDidMount",
	"componentDidUpdate",
	"componentWillMount",
	"componentWillReceiveProps",
	"componentWillUnmount",
	"componentWillUpdate",
	"constructor",
	"getSnapshotBeforeUpdate",
	"render",
	"shouldComponentUpdate",
	"state",
	"UNSAFE_componentWillMount",
	"UNSAFE_componentWillReceiveProps",
	"UNSAFE_componentWillUpdate"
]);
function isKeyLiteral$1(node, key) {
	return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({
		type: AST_NODE_TYPES.TemplateLiteral,
		expressions: []
	}, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_unused_class_component_members_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns unused class component methods and properties.",
			[Symbol.for("rule_features")]: RULE_FEATURES$8
		},
		messages: { noUnusedClassComponentMembers: "Unused method or property '{{methodName}}'' of class '{{className}}'." },
		schema: []
	},
	name: RULE_NAME$9,
	create: create$9,
	defaultOptions: []
});
function create$9(context) {
	const classEntries = [];
	const methodEntries = [];
	const propertyDefs = /* @__PURE__ */ new WeakMap();
	const propertyUsages = /* @__PURE__ */ new WeakMap();
	function classEnter(node) {
		classEntries.push(node);
		if (!ER.isClassComponent(node)) return;
		propertyDefs.set(node, /* @__PURE__ */ new Set());
		propertyUsages.set(node, /* @__PURE__ */ new Set());
	}
	function classExit() {
		const currentClass = classEntries.pop();
		if (currentClass == null || !ER.isClassComponent(currentClass)) return;
		const className = AST.getClassId(currentClass)?.name;
		const defs = propertyDefs.get(currentClass);
		const usages = propertyUsages.get(currentClass);
		if (defs == null) return;
		for (const def of defs) {
			const methodName = AST.getPropertyName(def);
			if (methodName == null) continue;
			if (usages?.has(methodName) || LIFECYCLE_METHODS.has(methodName)) continue;
			context.report({
				messageId: "noUnusedClassComponentMembers",
				node: def,
				data: {
					className: className ?? "Component",
					methodName
				}
			});
		}
	}
	function methodEnter(node) {
		methodEntries.push(node);
		const currentClass = classEntries.at(-1);
		if (currentClass == null || !ER.isClassComponent(currentClass)) return;
		if (node.static) return;
		if (isKeyLiteral$1(node, node.key)) propertyDefs.get(currentClass)?.add(node.key);
	}
	function methodExit() {
		methodEntries.pop();
	}
	return {
		ClassDeclaration: classEnter,
		"ClassDeclaration:exit": classExit,
		ClassExpression: classEnter,
		"ClassExpression:exit": classExit,
		MemberExpression(node) {
			const currentClass = classEntries.at(-1);
			const currentMethod = methodEntries.at(-1);
			if (currentClass == null || currentMethod == null) return;
			if (!ER.isClassComponent(currentClass) || currentMethod.static) return;
			if (!AST.isThisExpression(node.object) || !isKeyLiteral$1(node, node.property)) return;
			if (node.parent.type === AST_NODE_TYPES.AssignmentExpression && node.parent.left === node) {
				propertyDefs.get(currentClass)?.add(node.property);
				return;
			}
			const propertyName = AST.getPropertyName(node.property);
			if (propertyName != null) propertyUsages.get(currentClass)?.add(propertyName);
		},
		MethodDefinition: methodEnter,
		"MethodDefinition:exit": methodExit,
		PropertyDefinition: methodEnter,
		"PropertyDefinition:exit": methodExit,
		VariableDeclarator(node) {
			const currentClass = classEntries.at(-1);
			const currentMethod = methodEntries.at(-1);
			if (currentClass == null || currentMethod == null) return;
			if (!ER.isClassComponent(currentClass) || currentMethod.static) return;
			if (node.init != null && AST.isThisExpression(node.init) && node.id.type === AST_NODE_TYPES.ObjectPattern) {
				for (const prop of node.id.properties) if (prop.type === AST_NODE_TYPES.Property && isKeyLiteral$1(prop, prop.key)) {
					const keyName = AST.getPropertyName(prop.key);
					if (keyName != null) propertyUsages.get(currentClass)?.add(keyName);
				}
			}
		}
	};
}

//#endregion
//#region src/rules/no-unused-state.ts
const RULE_NAME$8 = "no-unused-state";
const RULE_FEATURES$7 = [];
function isKeyLiteral(node, key) {
	return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({
		type: AST_NODE_TYPES.TemplateLiteral,
		expressions: []
	}, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_unused_state_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Warns unused class component state.",
			[Symbol.for("rule_features")]: RULE_FEATURES$7
		},
		messages: { noUnusedState: "Unused class component state in '{{className}}'" },
		schema: []
	},
	name: RULE_NAME$8,
	create: create$8,
	defaultOptions: []
});
function create$8(context) {
	const classEntries = [];
	const methodEntries = [];
	const constructorEntries = [];
	const stateDefs = /* @__PURE__ */ new WeakMap();
	function classEnter(node) {
		classEntries.push(node);
	}
	function classExit() {
		const currentClass = classEntries.pop();
		if (currentClass == null || !ER.isClassComponent(currentClass)) return;
		const className = AST.getClassId(currentClass)?.name;
		const { node: defNode, isUsed = false } = stateDefs.get(currentClass) ?? {};
		if (defNode == null || isUsed) return;
		context.report({
			messageId: "noUnusedState",
			node: defNode,
			data: { className: className ?? "Component" }
		});
	}
	function methodEnter(node) {
		methodEntries.push(node);
		const currentClass = classEntries.at(-1);
		if (currentClass == null || !ER.isClassComponent(currentClass)) return;
		if (node.static) {
			if (ER.isGetDerivedStateFromProps(node) && isMatching({ params: [P.nonNullable, ...P.array()] })(node.value)) {
				const defNode = stateDefs.get(currentClass)?.node;
				stateDefs.set(currentClass, {
					node: defNode,
					isUsed: true
				});
			}
			return;
		}
		if (AST.getPropertyName(node.key) === "state") stateDefs.set(currentClass, {
			node: node.key,
			isUsed: false
		});
	}
	function methodExit() {
		methodEntries.pop();
	}
	function constructorEnter(node) {
		constructorEntries.push(node);
	}
	function constructorExit() {
		constructorEntries.pop();
	}
	return {
		AssignmentExpression(node) {
			if (!ER.isAssignmentToThisState(node)) return;
			const currentClass = classEntries.at(-1);
			if (currentClass == null || !ER.isClassComponent(currentClass)) return;
			const currentConstructor = constructorEntries.at(-1);
			if (currentConstructor == null || !currentClass.body.body.includes(currentConstructor)) return;
			const isUsed = stateDefs.get(currentClass)?.isUsed ?? false;
			stateDefs.set(currentClass, {
				node: node.left,
				isUsed
			});
		},
		ClassDeclaration: classEnter,
		"ClassDeclaration:exit": classExit,
		ClassExpression: classEnter,
		"ClassExpression:exit": classExit,
		MemberExpression(node) {
			if (!AST.isThisExpression(node.object)) return;
			if (AST.getPropertyName(node.property) !== "state") return;
			const currentClass = classEntries.at(-1);
			if (currentClass == null || !ER.isClassComponent(currentClass)) return;
			const currentMethod = methodEntries.at(-1);
			if (currentMethod == null || currentMethod.static) return;
			if (currentMethod === constructorEntries.at(-1)) return;
			if (!currentClass.body.body.includes(currentMethod)) return;
			const defNode = stateDefs.get(currentClass)?.node;
			stateDefs.set(currentClass, {
				node: defNode,
				isUsed: true
			});
		},
		MethodDefinition: methodEnter,
		"MethodDefinition:exit": methodExit,
		"MethodDefinition[key.name='constructor']": constructorEnter,
		"MethodDefinition[key.name='constructor']:exit": constructorExit,
		PropertyDefinition: methodEnter,
		"PropertyDefinition:exit": methodExit,
		VariableDeclarator(node) {
			const currentClass = classEntries.at(-1);
			if (currentClass == null || !ER.isClassComponent(currentClass)) return;
			const currentMethod = methodEntries.at(-1);
			if (currentMethod == null || currentMethod.static) return;
			if (currentMethod === constructorEntries.at(-1)) return;
			if (!currentClass.body.body.includes(currentMethod)) return;
			if (node.init == null || !AST.isThisExpression(node.init) || node.id.type !== AST_NODE_TYPES.ObjectPattern) return;
			if (!node.id.properties.some((prop) => {
				if (prop.type === AST_NODE_TYPES.Property && isKeyLiteral(prop, prop.key)) return AST.getPropertyName(prop.key) === "state";
				return false;
			})) return;
			const defNode = stateDefs.get(currentClass)?.node;
			stateDefs.set(currentClass, {
				node: defNode,
				isUsed: true
			});
		}
	};
}

//#endregion
//#region src/rules/no-use-context.ts
const RULE_NAME$7 = "no-use-context";
const RULE_FEATURES$6 = ["MOD"];
var no_use_context_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Replaces usages of `useContext` with `use`.",
			[Symbol.for("rule_features")]: RULE_FEATURES$6
		},
		fixable: "code",
		messages: { noUseContext: "In React 19, 'use' is preferred over 'useContext' because it is more flexible." },
		schema: []
	},
	name: RULE_NAME$7,
	create: create$7,
	defaultOptions: []
});
function create$7(context) {
	if (!context.sourceCode.text.includes("useContext")) return {};
	const settings$3 = getSettingsFromContext(context);
	if (compare(settings$3.version, "19.0.0", "<")) return {};
	const useContextNames = /* @__PURE__ */ new Set();
	const hookCalls = /* @__PURE__ */ new Set();
	return {
		CallExpression(node) {
			if (!ER.isReactHookCall(node)) return;
			hookCalls.add(node);
		},
		ImportDeclaration(node) {
			if (node.source.value !== settings$3.importSource) return;
			const isUseImported = node.specifiers.some(isMatching({ local: {
				type: AST_NODE_TYPES.Identifier,
				name: "use"
			} }));
			for (const specifier of node.specifiers) {
				if (specifier.type !== AST_NODE_TYPES.ImportSpecifier) continue;
				if (specifier.imported.type !== AST_NODE_TYPES.Identifier) continue;
				if (specifier.imported.name === "useContext") {
					if (specifier.local.name !== "useContext") useContextNames.add(specifier.local.name);
					context.report({
						messageId: "noUseContext",
						node: specifier,
						fix(fixer) {
							if (isUseImported) {
								const tokenBefore = context.sourceCode.getTokenBefore(specifier);
								return [
									fixer.remove(specifier),
									...tokenBefore?.value === "," ? [fixer.replaceTextRange([tokenBefore.range[1], specifier.range[0]], "")] : [],
									...getCorrelativeTokens(context, specifier).map((token) => fixer.remove(token))
								];
							}
							return fixer.replaceText(specifier.imported, "use");
						}
					});
				}
			}
		},
		"Program:exit"() {
			const isUseContextCall = ER.isReactHookCallWithNameAlias(context, "useContext", [...useContextNames]);
			for (const node of hookCalls) {
				if (!isUseContextCall(node)) continue;
				context.report({
					messageId: "noUseContext",
					node: node.callee,
					fix(fixer) {
						switch (node.callee.type) {
							case AST_NODE_TYPES.Identifier: return fixer.replaceText(node.callee, "use");
							case AST_NODE_TYPES.MemberExpression: return fixer.replaceText(node.callee.property, "use");
						}
						return null;
					}
				});
			}
		}
	};
}
function getCorrelativeTokens(context, node) {
	const tokenBefore = context.sourceCode.getTokenBefore(node);
	const tokenAfter = context.sourceCode.getTokenAfter(node);
	const tokens = [];
	if (tokenAfter?.value !== "," && tokenBefore?.value === ",") tokens.push(tokenBefore);
	if (tokenAfter?.value === ",") tokens.push(tokenAfter);
	return tokens;
}

//#endregion
//#region src/rules/no-useless-forward-ref.ts
const RULE_NAME$6 = "no-useless-forward-ref";
const RULE_FEATURES$5 = [];
var no_useless_forward_ref_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Disallow useless `forwardRef` calls on components that don't use `ref`s.",
			[Symbol.for("rule_features")]: RULE_FEATURES$5
		},
		messages: { noUselessForwardRef: "A 'forwardRef' is used with this component but no 'ref' parameter is set." },
		schema: []
	},
	name: RULE_NAME$6,
	create: create$6,
	defaultOptions: []
});
function create$6(context) {
	return { CallExpression(node) {
		if (!ER.isForwardRefCall(context, node)) return;
		const [component] = node.arguments;
		if (component == null || !AST.isFunction(component)) return;
		if (component.params[1] != null) return;
		context.report({
			messageId: "noUselessForwardRef",
			node: node.callee
		});
	} };
}

//#endregion
//#region src/rules/no-useless-fragment.ts
const RULE_NAME$5 = "no-useless-fragment";
const defaultOptions = [{ allowExpressions: true }];
var no_useless_fragment_default = createRule({
	meta: {
		type: "problem",
		defaultOptions: [...defaultOptions],
		docs: { description: "Disallow useless fragment elements." },
		fixable: "code",
		messages: { uselessFragment: "A fragment {{reason}} is useless." },
		schema: [{
			type: "object",
			additionalProperties: false,
			properties: { allowExpressions: {
				type: "boolean",
				description: "Allow fragments with a single expression child"
			} }
		}]
	},
	name: RULE_NAME$5,
	create: create$5,
	defaultOptions
});
function create$5(context, [option]) {
	const { allowExpressions = true } = option;
	return {
		JSXElement(node) {
			if (!ER.isFragmentElement(context, node)) return;
			checkNode(context, node, allowExpressions);
		},
		JSXFragment(node) {
			checkNode(context, node, allowExpressions);
		}
	};
}
/**
* Check if a Literal or JSXText node is whitespace
* @param node The AST node to check
* @returns boolean `true` if the node is whitespace
*/
function isWhiteSpace(node) {
	return typeof node.value === "string" && node.raw.trim() === "";
}
/**
* Check if a Literal or JSXText node is padding spaces
* @param node The AST node to check
* @returns boolean
*/
function isPaddingSpaces(node) {
	return ER.isJsxText(node) && isWhiteSpace(node) && node.raw.includes("\n");
}
function trimLikeReact(text) {
	const leadingSpaces = /^\s*/.exec(text)?.[0] ?? "";
	const trailingSpaces = /\s*$/.exec(text)?.[0] ?? "";
	const start = leadingSpaces.includes("\n") ? leadingSpaces.length : 0;
	const end = trailingSpaces.includes("\n") ? text.length - trailingSpaces.length : text.length;
	return text.slice(start, end);
}
function checkNode(context, node, allowExpressions) {
	const initialScope = context.sourceCode.getScope(node);
	if (ER.isKeyedElement(context, node, initialScope)) return;
	if (ER.isHostElement(context, node.parent)) context.report({
		messageId: "uselessFragment",
		node,
		data: { reason: "placed inside a host component" },
		fix: getFix(context, node)
	});
	if (node.children.length === 0) {
		context.report({
			messageId: "uselessFragment",
			node,
			data: { reason: "contains less than two children" },
			fix: getFix(context, node)
		});
		return;
	}
	const isChildElement = AST.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent);
	switch (true) {
		case allowExpressions && !isChildElement && node.children.length === 1 && ER.isJsxText(node.children.at(0)): return;
		case !allowExpressions && isChildElement:
			context.report({
				messageId: "uselessFragment",
				node,
				data: { reason: "contains less than two children" },
				fix: getFix(context, node)
			});
			return;
		case !allowExpressions && !isChildElement && node.children.length === 1:
			context.report({
				messageId: "uselessFragment",
				node,
				data: { reason: "contains less than two children" },
				fix: getFix(context, node)
			});
			return;
	}
	const nonPaddingChildren = node.children.filter((child) => !isPaddingSpaces(child));
	const firstNonPaddingChild = nonPaddingChildren.at(0);
	switch (true) {
		case nonPaddingChildren.length === 0:
		case nonPaddingChildren.length === 1 && firstNonPaddingChild?.type !== AST_NODE_TYPES.JSXExpressionContainer:
			context.report({
				messageId: "uselessFragment",
				node,
				data: { reason: "contains less than two children" },
				fix: getFix(context, node)
			});
			return;
	}
}
function getFix(context, node) {
	if (!canFix(context, node)) return null;
	return (fixer) => {
		const opener = node.type === AST_NODE_TYPES.JSXFragment ? node.openingFragment : node.openingElement;
		const closer = node.type === AST_NODE_TYPES.JSXFragment ? node.closingFragment : node.closingElement;
		const childrenText = opener.type === AST_NODE_TYPES.JSXOpeningElement && opener.selfClosing ? "" : context.sourceCode.getText().slice(opener.range[1], closer?.range[0]);
		return fixer.replaceText(node, trimLikeReact(childrenText));
	};
}
function canFix(context, node) {
	if (node.parent.type === AST_NODE_TYPES.JSXElement || node.parent.type === AST_NODE_TYPES.JSXFragment) return ER.isHostElement(context, node.parent);
	if (node.children.length === 0) return false;
	if (node.children.some((child) => ER.isJsxText(child) && !isWhiteSpace(child) || AST.is(AST_NODE_TYPES.JSXExpressionContainer)(child))) return false;
	return true;
}

//#endregion
//#region src/rules/prefer-destructuring-assignment.ts
const RULE_NAME$4 = "prefer-destructuring-assignment";
const RULE_FEATURES$4 = [];
function isMemberExpressionWithObjectName(node) {
	return node.object.type === AST_NODE_TYPES.Identifier && "name" in node.object;
}
var prefer_destructuring_assignment_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces destructuring assignment for component props and context.",
			[Symbol.for("rule_features")]: RULE_FEATURES$4
		},
		messages: { preferDestructuringAssignment: "Use destructuring assignment for {{name}}." },
		schema: []
	},
	name: RULE_NAME$4,
	create: create$4,
	defaultOptions: []
});
function create$4(context) {
	const { ctx, listeners } = ER.useComponentCollector(context);
	const memberExpressionWithNames = [];
	return {
		...listeners,
		MemberExpression(node) {
			if (isMemberExpressionWithObjectName(node)) {
				const scope = context.sourceCode.getScope(node);
				memberExpressionWithNames.push([scope, node]);
			}
		},
		"Program:exit"(program) {
			const components = [...ctx.getAllComponents(program).values()];
			function isFunctionComponent(block) {
				if (!AST.isFunction(block)) return false;
				const id = AST.getFunctionId(block);
				return id != null && ER.isComponentNameLoose(id.name) && components.some((component) => component.node === block);
			}
			for (const [initialScope, memberExpression] of memberExpressionWithNames) {
				let scope = initialScope;
				let isComponent = isFunctionComponent(scope.block);
				while (!isComponent && scope.upper != null && scope.upper !== scope) {
					scope = scope.upper;
					isComponent = isFunctionComponent(scope.block);
				}
				if (!isComponent) continue;
				const component = scope.block;
				if (!("params" in component)) continue;
				const [props, ctx$1] = component.params;
				const isMatch = (node) => node != null && node.type === AST_NODE_TYPES.Identifier && node.name === memberExpression.object.name;
				if (isMatch(props)) context.report({
					messageId: "preferDestructuringAssignment",
					node: memberExpression,
					data: { name: "props" }
				});
				if (isMatch(ctx$1)) context.report({
					messageId: "preferDestructuringAssignment",
					node: memberExpression,
					data: { name: "context" }
				});
			}
		}
	};
}

//#endregion
//#region src/rules/prefer-react-namespace-import.ts
const RULE_NAME$3 = "prefer-react-namespace-import";
const RULE_FEATURES$3 = ["FIX"];
var prefer_react_namespace_import_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces React is imported via a namespace import.",
			[Symbol.for("rule_features")]: RULE_FEATURES$3
		},
		fixable: "code",
		messages: { preferReactNamespaceImport: "Prefer importing React as 'import * as React from \"{{importSource}}\"';" },
		schema: []
	},
	name: RULE_NAME$3,
	create: create$3,
	defaultOptions: []
});
function create$3(context) {
	const { importSource } = getSettingsFromContext(context);
	return { [`ImportDeclaration[source.value="${importSource}"] ImportDefaultSpecifier`](node) {
		const hasOtherSpecifiers = node.parent.specifiers.length > 1;
		context.report({
			messageId: "preferReactNamespaceImport",
			node: hasOtherSpecifiers ? node : node.parent,
			data: { importSource },
			fix(fixer) {
				const importDeclarationText = context.sourceCode.getText(node.parent);
				const semi = importDeclarationText.endsWith(";") ? ";" : "";
				const quote = node.parent.source.raw.at(0) ?? "'";
				const importStringPrefix = `import${node.parent.importKind === "type" ? " type" : ""}`;
				const importSourceQuoted = `${quote}${importSource}${quote}`;
				if (!hasOtherSpecifiers) return fixer.replaceText(node.parent, `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semi}`);
				const specifiers = importDeclarationText.slice(importDeclarationText.indexOf("{"), importDeclarationText.indexOf("}") + 1);
				return fixer.replaceText(node.parent, [`${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semi}`, `${importStringPrefix} ${specifiers} from ${importSourceQuoted}${semi}`].join("\n"));
			}
		});
	} };
}

//#endregion
//#region src/rules/prefer-read-only-props.ts
const RULE_NAME$2 = "prefer-read-only-props";
const RULE_FEATURES$2 = ["TSC", "EXP"];
var prefer_read_only_props_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces read-only props in components.",
			[Symbol.for("rule_features")]: RULE_FEATURES$2
		},
		messages: { preferReadOnlyProps: "A function component's props should be read-only." },
		schema: []
	},
	name: RULE_NAME$2,
	create: create$2,
	defaultOptions: []
});
function create$2(context) {
	const services = ESLintUtils.getParserServices(context, false);
	const { ctx, listeners } = ER.useComponentCollector(context);
	return {
		...listeners,
		"Program:exit"(program) {
			const components = ctx.getAllComponents(program);
			for (const [, component] of components) {
				if (component.id == null) continue;
				if (component.name == null) continue;
				const [props] = component.node.params;
				if (props == null) continue;
				const propsType = getConstrainedTypeAtLocation(services, props);
				if (isTypeReadonlyLoose(services, propsType)) continue;
				context.report({
					messageId: "preferReadOnlyProps",
					node: props
				});
			}
		}
	};
}
function isTypeReadonlyLoose(services, type) {
	if (isTypeReadonly(services.program, type)) return true;
	try {
		const im = getTypeImmutability(services.program, type);
		return isUnknown(im) || isImmutable(im) || isReadonlyShallow(im) || isReadonlyDeep(im);
	} catch {
		return true;
	}
}

//#endregion
//#region src/rules/prefer-shorthand-boolean.ts
const RULE_NAME$1 = "prefer-shorthand-boolean";
const RULE_FEATURES$1 = ["FIX"];
var prefer_shorthand_boolean_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces shorthand syntax for boolean attributes.",
			[Symbol.for("rule_features")]: RULE_FEATURES$1
		},
		fixable: "code",
		messages: { preferShorthandBoolean: "Use shorthand boolean attribute '{{propName}}'." },
		schema: []
	},
	name: RULE_NAME$1,
	create: create$1,
	defaultOptions: []
});
function create$1(context) {
	return { JSXAttribute(node) {
		const { value } = node;
		const propName = ER.getAttributeName(context, node);
		if (!(value?.type === AST_NODE_TYPES.JSXExpressionContainer && value.expression.type === AST_NODE_TYPES.Literal && value.expression.value === true)) return;
		context.report({
			messageId: "preferShorthandBoolean",
			node: node.value ?? node,
			data: { propName },
			fix: (fixer) => fixer.removeRange([node.name.range[1], value.range[1]])
		});
	} };
}

//#endregion
//#region src/rules/prefer-shorthand-fragment.ts
const RULE_NAME = "prefer-shorthand-fragment";
const RULE_FEATURES = ["FIX"];
var prefer_shorthand_fragment_default = createRule({
	meta: {
		type: "problem",
		docs: {
			description: "Enforces shorthand syntax for fragments.",
			[Symbol.for("rule_features")]: RULE_FEATURES
		},
		fixable: "code",
		messages: { preferShorthandFragment: "Use fragment shorthand syntax instead of 'Fragment' component." },
		schema: []
	},
	name: RULE_NAME,
	create,
	defaultOptions: []
});
function create(context) {
	return { JSXElement(node) {
		if (!ER.isFragmentElement(context, node)) return;
		if (node.openingElement.attributes.length > 0) return;
		context.report({
			messageId: "preferShorthandFragment",
			node,
			fix: (fixer) => {
				const { closingElement, openingElement } = node;
				if (closingElement == null) return [];
				return [fixer.replaceTextRange([openingElement.range[0], openingElement.range[1]], "<>"), fixer.replaceTextRange([closingElement.range[0], closingElement.range[1]], "</>")];
			}
		});
	} };
}

//#endregion
//#region src/plugin.ts
const plugin = {
	meta: {
		name,
		version
	},
	rules: {
		"avoid-shorthand-boolean": avoid_shorthand_boolean_default,
		"avoid-shorthand-fragment": avoid_shorthand_fragment_default,
		"no-access-state-in-setstate": no_access_state_in_setstate_default,
		"no-array-index-key": no_array_index_key_default,
		"no-children-count": no_children_count_default,
		"no-children-for-each": no_children_for_each_default,
		"no-children-map": no_children_map_default,
		"no-children-only": no_children_only_default,
		"no-children-prop": no_children_prop_default,
		"no-children-to-array": no_children_to_array_default,
		"no-class-component": no_class_component_default,
		"no-clone-element": no_clone_element_default,
		"no-comment-textnodes": no_comment_textnodes_default,
		"no-complex-conditional-rendering": no_complex_conditional_rendering_default,
		"no-component-will-mount": no_component_will_mount_default,
		"no-component-will-receive-props": no_component_will_receive_props_default,
		"no-component-will-update": no_component_will_update_default,
		"no-context-provider": no_context_provider_default,
		"no-create-ref": no_create_ref_default,
		"no-default-props": no_default_props_default,
		"no-direct-mutation-state": no_direct_mutation_state_default,
		"no-duplicate-key": no_duplicate_key_default,
		"no-forward-ref": no_forward_ref_default,
		"no-implicit-key": no_implicit_key_default,
		"no-leaked-conditional-rendering": no_leaked_conditional_rendering_default,
		"no-missing-component-display-name": no_missing_component_display_name_default,
		"no-missing-context-display-name": no_missing_context_display_name_default,
		"no-missing-key": no_missing_key_default,
		"no-misused-capture-owner-stack": no_misused_capture_owner_stack_default,
		"no-nested-component-definitions": no_nested_component_definitions_default,
		"no-nested-lazy-component-declarations": no_nested_lazy_component_declarations_default,
		"no-prop-types": no_prop_types_default,
		"no-redundant-should-component-update": no_redundant_should_component_update_default,
		"no-set-state-in-component-did-mount": no_set_state_in_component_did_mount_default,
		"no-set-state-in-component-did-update": no_set_state_in_component_did_update_default,
		"no-set-state-in-component-will-update": no_set_state_in_component_will_update_default,
		"no-string-refs": no_string_refs_default,
		"no-unsafe-component-will-mount": no_unsafe_component_will_mount_default,
		"no-unsafe-component-will-receive-props": no_unsafe_component_will_receive_props_default,
		"no-unsafe-component-will-update": no_unsafe_component_will_update_default,
		"no-unstable-context-value": no_unstable_context_value_default,
		"no-unstable-default-props": no_unstable_default_props_default,
		"no-unused-class-component-members": no_unused_class_component_members_default,
		"no-unused-state": no_unused_state_default,
		"no-use-context": no_use_context_default,
		"no-useless-forward-ref": no_useless_forward_ref_default,
		"no-useless-fragment": no_useless_fragment_default,
		"prefer-destructuring-assignment": prefer_destructuring_assignment_default,
		"prefer-react-namespace-import": prefer_react_namespace_import_default,
		"prefer-read-only-props": prefer_read_only_props_default,
		"prefer-shorthand-boolean": prefer_shorthand_boolean_default,
		"prefer-shorthand-fragment": prefer_shorthand_fragment_default,
		"jsx-key-before-spread": jsx_key_before_spread_default,
		"jsx-no-duplicate-props": jsx_no_duplicate_props_default,
		"jsx-no-iife": jsx_no_iife_default,
		"jsx-no-undef": jsx_no_undef_default,
		"jsx-uses-react": jsx_uses_react_default,
		"jsx-uses-vars": jsx_uses_vars_default,
		"ensure-forward-ref-using-ref": no_useless_forward_ref_default,
		"no-complicated-conditional-rendering": no_complex_conditional_rendering_default,
		"no-duplicate-jsx-props": jsx_no_duplicate_props_default,
		"no-nested-components": no_nested_component_definitions_default,
		"use-jsx-vars": jsx_uses_vars_default
	}
};

//#endregion
//#region src/index.ts
const { toFlatConfig, toLegacyConfig } = getConfigAdapters("react-x", plugin);
var src_default = {
	...plugin,
	configs: {
		["recommended"]: toFlatConfig(recommended_exports),
		["recommended-legacy"]: toLegacyConfig(recommended_exports),
		["recommended-type-checked"]: toFlatConfig(recommended_type_checked_exports),
		["recommended-type-checked-legacy"]: toLegacyConfig(recommended_type_checked_exports),
		["recommended-typescript"]: toFlatConfig(recommended_typescript_exports),
		["recommended-typescript-legacy"]: toLegacyConfig(recommended_typescript_exports)
	}
};

//#endregion
export { src_default as default };