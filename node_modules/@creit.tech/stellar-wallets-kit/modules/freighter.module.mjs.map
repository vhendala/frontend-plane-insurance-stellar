{"version":3,"file":"freighter.module.mjs","sources":["../../src/modules/freighter.module.ts"],"sourcesContent":["import {\n  isConnected,\n  signTransaction,\n  signAuthEntry,\n  requestAccess,\n  signMessage,\n  getNetwork,\n  getAddress,\n} from '@stellar/freighter-api';\nimport { ModuleInterface, ModuleType } from '../types';\nimport { parseError } from '../utils';\nimport { Buffer } from 'buffer';\n\ndeclare const window: Window &\n  typeof globalThis & {\n  stellar?: {\n    provider: string;\n    platform: string;\n    version: string;\n  };\n};\n\nexport const FREIGHTER_ID = 'freighter';\n\nexport class FreighterModule implements ModuleInterface {\n  moduleType: ModuleType = ModuleType.HOT_WALLET;\n\n  productId: string = FREIGHTER_ID;\n  productName: string = 'Freighter';\n  productUrl: string = 'https://freighter.app';\n  productIcon: string = 'https://stellar.creit.tech/wallet-icons/freighter.png';\n\n  async runChecks(): Promise<void> {\n    if (!(await this.isAvailable())) {\n      throw new Error('Freighter is not connected');\n    }\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // If these values are set it means we are loading the module from the Freighter's mobile version and so we need to\n    // use WalletConnect instead.\n    if (window.stellar?.provider === 'freighter' && window.stellar?.platform === 'mobile') return false;\n\n    return isConnected()\n      .then(({ isConnected, error }) => !error && isConnected)\n      .catch((): boolean => false);\n  }\n\n  async getAddress(params: { skipRequestAccess?: boolean }): Promise<{ address: string }> {\n    return this.runChecks()\n      .then(async () => {\n        if (params?.skipRequestAccess) return true;\n        return requestAccess();\n      })\n      .then(() => getAddress())\n      .then(({ address, error }) => {\n        if (error) throw error;\n        if (!address) throw {\n          code: -3,\n          message: 'Getting the address is not allowed, please request access first.',\n        };\n\n        return { address };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signTransaction(\n    xdr: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n      submit?: boolean;\n      submitUrl?: string;\n    }\n  ): Promise<{ signedTxXdr: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedTxXdr, signerAddress, error } = await signTransaction(xdr, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error) throw error;\n\n        return { signedTxXdr, signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signAuthEntry(\n    authEntry: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n    }\n  ): Promise<{ signedAuthEntry: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedAuthEntry, signerAddress, error } = await signAuthEntry(authEntry, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error || !signedAuthEntry) throw error;\n\n        return { signedAuthEntry: Buffer.from(signedAuthEntry).toString('base64'), signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signMessage(\n    message: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n    }\n  ): Promise<{ signedMessage: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedMessage, signerAddress, error } = await signMessage(message, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error || !signedMessage) throw error;\n\n        return {\n          signedMessage: typeof signedMessage === 'string'\n            ? signedMessage\n            : Buffer.from(signedMessage).toString('base64'),\n          signerAddress: signerAddress\n        };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async getNetwork(): Promise<{ network: string; networkPassphrase: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { network, networkPassphrase, error } = await getNetwork();\n\n        if (error) throw error;\n\n        return { network, networkPassphrase };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n}\n"],"names":["isConnected"],"mappings":"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"}