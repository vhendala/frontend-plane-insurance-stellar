import{box as e,randomBytes as s}from"tweetnacl";import{encodeBase64 as t,decodeUTF8 as i,decodeBase64 as r,encodeUTF8 as n}from"tweetnacl-util";import{isResponseError as o,EventType as a}from"./interfaces.js";import{Subject as c,timer as l,takeUntil as p,take as h,firstValueFrom as d,switchMap as u,throwError as g,of as b}from"rxjs";import{xBullSDK as m}from"./mobile-sdk.js";class w{constructor(o){this.closeCurrentPromises$=new c,this.closeObservables$=new c,this.initialResponse$=new c,this.initialResponseCompleted$=new c,this.connectResponse$=new c,this.connectResult$=new c,this.signResponse$=new c,this.signResult$=new c,this.signMessageResponse$=new c,this.signMessageResult$=new c,this.closeCurrentPromisesSubscription=l(1e3,1e3).pipe(p(this.closeObservables$)).subscribe((()=>{this.target?.closed&&this.closeCurrentPromises$.next()})),this.onInititalResponseSubscription=this.initialResponse$.pipe(p(this.closeObservables$)).subscribe((e=>{const s=this.decryptFromReceiver({oneTimeCode:e.data.oneTimeCode,payload:e.data.message,senderPublicKey:e.data.publicKey});JSON.parse(s).providedSession===this.session()&&(this.targetPublicKey=e.data.publicKey,this.initialResponseCompleted$.next())})),this.onConnectResponseSubscription=this.connectResponse$.pipe(p(this.closeObservables$)).subscribe((e=>{if(!this.targetPublicKey)return void this.connectResult$.next({success:!1,message:"Wallet encryption public key is not provided, request rejected."});if(!e.data.success)return void this.connectResult$.next({success:!1,message:"Request rejected from the wallet"});const s=this.decryptFromReceiver({oneTimeCode:e.data.oneTimeCode,payload:e.data.message,senderPublicKey:this.targetPublicKey}),t=JSON.parse(s);this.connectResult$.next({success:!0,publicKey:t.publicKey})})),this.onSignResponseSubscription=this.signResponse$.pipe(p(this.closeObservables$)).subscribe((e=>{if(!this.targetPublicKey)return void this.signResult$.next({success:!1,message:"Wallet encryption public key is not provided, request rejected."});if(!e.data.success)return void this.signResult$.next({success:!1,message:"Request rejected from the wallet"});const s=this.decryptFromReceiver({oneTimeCode:e.data.oneTimeCode,payload:e.data.message,senderPublicKey:this.targetPublicKey}),t=JSON.parse(s);this.signResult$.next({success:!0,xdr:t.xdr})})),this.onSignMessageResponseSubscription=this.signMessageResponse$.pipe(p(this.closeObservables$)).subscribe((e=>{if(!this.targetPublicKey)return void this.signMessageResult$.next({success:!1,message:"Wallet encryption public key is not provided, request rejected."});if(!e.data.success)return void this.signMessageResult$.next({success:!1,message:"Request rejected from the wallet"});const s=this.decryptFromReceiver({oneTimeCode:e.data.oneTimeCode,payload:e.data.message,senderPublicKey:this.targetPublicKey}),t=JSON.parse(s);this.signMessageResult$.next({success:!0,...t})})),this.preferredTarget=o?.preferredTarget||"extension",this.walletUrl=o?.url||"https://wallet.xbull.app/connect";const d=e.keyPair(),u=t(s(24));this.encryptForReceiver=r=>{const n=s(24),o=e(i(r.data),n,r.receiverPublicKey,d.secretKey);return{message:t(o),oneTimeCode:t(n)}},this.decryptFromReceiver=s=>{const t=e.open(r(s.payload),r(s.oneTimeCode),r(s.senderPublicKey),d.secretKey);if(!t)throw new Error("Decrypted message is null");return n(t)},this.publicKey=()=>d.publicKey,this.session=()=>u.slice();const g=e=>{switch(e.data.type){case a.XBULL_INITIAL_RESPONSE:this.initialResponse$.next(e);break;case a.XBULL_CONNECT_RESPONSE:this.connectResponse$.next(e);break;case a.XBULL_SIGN_RESPONSE:this.signResponse$.next(e);break;case a.XBULL_SIGN_MESSAGE_RESPONSE:this.signMessageResponse$.next(e)}};window.addEventListener("message",g),this.closeObservables$.asObservable().pipe(h(1)).subscribe((()=>{window.removeEventListener("message",g)}))}openWallet(){return this.target&&!this.target.closed&&(this.target.close(),this.target=null,this.closeCurrentPromises$.next()),this.target=window.open(`${this.walletUrl}?public=${encodeURIComponent(t(this.publicKey()))}&session=${encodeURIComponent(this.session())}`,"xBull_Wallet_app","width=380,height=640,left=100,top=100"),d(this.initialResponseCompleted$.pipe(p(this.closeCurrentPromises$)).pipe(p(this.closeObservables$)))}closeWallet(){this.target&&(this.target?.close(),this.target=null)}async connect(e={canRequestPublicKey:!0,canRequestSign:!0}){const s=window?.webkit?.messageHandlers?.cordova_iab?new m:window.xBullSDK;if(s&&"extension"===this.preferredTarget){const e=await s.getAddress();if(o(e))throw e.error;return e.address}{if(await this.openWallet(),!this.target||!this.targetPublicKey)throw new Error("xBull Wallet is not open, we can't connect with it");const{message:s,oneTimeCode:t}=this.encryptForReceiver({data:JSON.stringify(e),receiverPublicKey:r(this.targetPublicKey)}),i={type:a.XBULL_CONNECT,message:s,oneTimeCode:t};this.target.postMessage(i,"*");const n=this.connectResult$.asObservable().pipe(u((e=>e.success?(this.closeWallet(),b(e.publicKey)):(this.closeWallet(),g((()=>new Error(e.message))))))).pipe(h(1)).pipe(p(this.closeCurrentPromises$)).pipe(p(this.closeObservables$));return d(n)}}async sign(e){const s=window?.webkit?.messageHandlers?.cordova_iab?new m:window.xBullSDK;if(s&&"extension"===this.preferredTarget){const t=await s.signTransaction({xdr:e.xdr,opts:{networkPassphrase:e.network,address:e.publicKey}});if(o(t))throw t.error;return t.signedTxXdr}{if(await this.openWallet(),!this.target||!this.targetPublicKey)throw new Error("xBull Wallet is not open, we can't connect with it");if("string"!=typeof e.xdr)throw new Error("XDR provided needs to be a string value");const{message:s,oneTimeCode:t}=this.encryptForReceiver({data:JSON.stringify(e),receiverPublicKey:r(this.targetPublicKey)}),i={type:a.XBULL_SIGN,message:s,oneTimeCode:t};this.target.postMessage(i,"*");const n=this.signResult$.asObservable().pipe(u((e=>e.success?(this.closeWallet(),b(e.xdr)):(this.closeWallet(),g((()=>new Error(e.message))))))).pipe(h(1)).pipe(p(this.closeCurrentPromises$)).pipe(p(this.closeObservables$));return d(n)}}async signMessage(e,s){const t=window?.webkit?.messageHandlers?.cordova_iab?new m:window.xBullSDK;if(t&&"extension"===this.preferredTarget){const i=await t.signMessage(e,s);if(o(i))throw i.error;return i}{if(await this.openWallet(),!this.target||!this.targetPublicKey)throw new Error("xBull Wallet is not open, we can't connect with it");if("string"!=typeof e)throw new Error("XDR provided needs to be a string value");const t=this.encryptForReceiver({data:JSON.stringify({message:e,opts:s}),receiverPublicKey:r(this.targetPublicKey)}),i={type:a.XBULL_SIGN_MESSAGE,message:t.message,oneTimeCode:t.oneTimeCode};this.target.postMessage(i,"*");const n=this.signMessageResult$.asObservable().pipe(u((e=>e.success?(this.closeWallet(),b({signedMessage:e.signedMessage,signerAddress:e.signerAddress})):(this.closeWallet(),g((()=>new Error(e.message))))))).pipe(h(1)).pipe(p(this.closeCurrentPromises$)).pipe(p(this.closeObservables$));return d(n)}}closeConnections(){this.closeObservables$.next(),this.closeCurrentPromises$.next(),this.closeObservables$.complete(),this.closeCurrentPromises$.complete()}}export{w as xBullWalletConnect};
//# sourceMappingURL=index.js.map
