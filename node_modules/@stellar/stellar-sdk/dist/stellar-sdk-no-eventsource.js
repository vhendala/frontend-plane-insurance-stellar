(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("StellarSdk", [], factory);
	else if(typeof exports === 'object')
		exports["StellarSdk"] = factory();
	else
		root["StellarSdk"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 76:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ Api)
/* harmony export */ });
var Api;
(function (_Api) {
  var GetTransactionStatus = function (GetTransactionStatus) {
    GetTransactionStatus["SUCCESS"] = "SUCCESS";
    GetTransactionStatus["NOT_FOUND"] = "NOT_FOUND";
    GetTransactionStatus["FAILED"] = "FAILED";
    return GetTransactionStatus;
  }({});
  _Api.GetTransactionStatus = GetTransactionStatus;
  function isSimulationError(sim) {
    return 'error' in sim;
  }
  _Api.isSimulationError = isSimulationError;
  function isSimulationSuccess(sim) {
    return 'transactionData' in sim;
  }
  _Api.isSimulationSuccess = isSimulationSuccess;
  function isSimulationRestore(sim) {
    return isSimulationSuccess(sim) && 'restorePreamble' in sim && !!sim.restorePreamble.transactionData;
  }
  _Api.isSimulationRestore = isSimulationRestore;
  function isSimulationRaw(sim) {
    return !sim._parsed;
  }
  _Api.isSimulationRaw = isSimulationRaw;
})(Api || (Api = {}));

/***/ }),

/***/ 121:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  axiosClient: () => (/* binding */ axiosClient),
  create: () => (/* binding */ create)
});

// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js
var common_utils_namespaceObject = {};
__webpack_require__.r(common_utils_namespaceObject);
__webpack_require__.d(common_utils_namespaceObject, {
  hasBrowserEnv: () => (hasBrowserEnv),
  hasStandardBrowserEnv: () => (hasStandardBrowserEnv),
  hasStandardBrowserWebWorkerEnv: () => (hasStandardBrowserWebWorkerEnv),
  navigator: () => (_navigator),
  origin: () => (origin)
});

;// ./node_modules/axios/lib/helpers/bind.js


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

;// ./node_modules/axios/lib/utils.js




// utils is a library of generic helper functions non-specific to axios

const {toString: utils_toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = utils_toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
}

/**
 * Determine if a value is an empty object (safely handles Buffers)
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an empty object, otherwise false
 */
const isEmptyObject = (val) => {
  // Early return for non-objects or Buffers to prevent RangeError
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    // Fallback for any other objects that might cause RangeError with Object.keys()
    return false;
  }
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Buffer check
    if (isBuffer(obj)) {
      return;
    }

    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  if (isBuffer(obj)){
    return null;
  }

  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      //Buffer check
      if (isBuffer(source)) {
        return source;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


/* harmony default export */ const utils = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: utils_hasOwnProperty,
  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
});

;// ./node_modules/axios/lib/core/AxiosError.js




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const AxiosError_prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(AxiosError_prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const core_AxiosError = (AxiosError);

;// ./node_modules/axios/lib/helpers/null.js
// eslint-disable-next-line strict
/* harmony default export */ const helpers_null = (null);

;// ./node_modules/axios/lib/helpers/toFormData.js
/* provided dependency */ var Buffer = __webpack_require__(287)["Buffer"];




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (helpers_null || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isBoolean(value)) {
      return value.toString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const helpers_toFormData = (toFormData);

;// ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && helpers_toFormData(params, this, options);
}

const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

AxiosURLSearchParams_prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

AxiosURLSearchParams_prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

;// ./node_modules/axios/lib/helpers/buildURL.js





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function buildURL_encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || buildURL_encode;

  if (utils.isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new helpers_AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

;// ./node_modules/axios/lib/core/InterceptorManager.js




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const core_InterceptorManager = (InterceptorManager);

;// ./node_modules/axios/lib/defaults/transitional.js


/* harmony default export */ const defaults_transitional = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});

;// ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js



/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);

;// ./node_modules/axios/lib/platform/browser/classes/FormData.js


/* harmony default export */ const classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);

;// ./node_modules/axios/lib/platform/browser/classes/Blob.js


/* harmony default export */ const classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);

;// ./node_modules/axios/lib/platform/browser/index.js




/* harmony default export */ const browser = ({
  isBrowser: true,
  classes: {
    URLSearchParams: classes_URLSearchParams,
    FormData: classes_FormData,
    Blob: classes_Blob
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});

;// ./node_modules/axios/lib/platform/common/utils.js
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';



;// ./node_modules/axios/lib/platform/index.js



/* harmony default export */ const platform = ({
  ...common_utils_namespaceObject,
  ...browser
});

;// ./node_modules/axios/lib/helpers/toURLEncodedForm.js






function toURLEncodedForm(data, options) {
  return helpers_toFormData(data, new platform.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

;// ./node_modules/axios/lib/helpers/formDataToJSON.js




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);

;// ./node_modules/axios/lib/defaults/index.js










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: defaults_transitional,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data) ||
      utils.isReadableStream(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return helpers_toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils.isResponse(data) || utils.isReadableStream(data)) {
      return data;
    }

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

/* harmony default export */ const lib_defaults = (defaults);

;// ./node_modules/axios/lib/helpers/parseHeaders.js




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const parseHeaders = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});

;// ./node_modules/axios/lib/core/AxiosHeaders.js





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils.isObject(header) && utils.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils.isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite)
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils.freezeMethods(AxiosHeaders);

/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);

;// ./node_modules/axios/lib/core/transformData.js






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || lib_defaults;
  const context = response || config;
  const headers = core_AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

;// ./node_modules/axios/lib/cancel/isCancel.js


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

;// ./node_modules/axios/lib/cancel/CanceledError.js





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, core_AxiosError, {
  __CANCEL__: true
});

/* harmony default export */ const cancel_CanceledError = (CanceledError);

;// ./node_modules/axios/lib/core/settle.js




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new core_AxiosError(
      'Request failed with status code ' + response.status,
      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

;// ./node_modules/axios/lib/helpers/parseProtocol.js


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

;// ./node_modules/axios/lib/helpers/speedometer.js


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const helpers_speedometer = (speedometer);

;// ./node_modules/axios/lib/helpers/throttle.js
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  }

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs)
        }, threshold - passed);
      }
    }
  }

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

/* harmony default export */ const helpers_throttle = (throttle);

;// ./node_modules/axios/lib/helpers/progressEventReducer.js




const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = helpers_speedometer(50, 250);

  return helpers_throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
}

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}

const asyncDecorator = (fn) => (...args) => utils.asap(() => fn(...args));

;// ./node_modules/axios/lib/helpers/isURLSameOrigin.js


/* harmony default export */ const isURLSameOrigin = (platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, platform.origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true);

;// ./node_modules/axios/lib/helpers/cookies.js



/* harmony default export */ const cookies = (platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils.isString(path) && cookie.push('path=' + path);

      utils.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });


;// ./node_modules/axios/lib/helpers/isAbsoluteURL.js


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

;// ./node_modules/axios/lib/helpers/combineURLs.js


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

;// ./node_modules/axios/lib/core/buildFullPath.js





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

;// ./node_modules/axios/lib/core/mergeConfig.js





const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  utils.forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

;// ./node_modules/axios/lib/helpers/resolveConfig.js









/* harmony default export */ const resolveConfig = ((config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = core_AxiosHeaders.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
});


;// ./node_modules/axios/lib/adapters/xhr.js











const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = core_AxiosHeaders.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = core_AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || defaults_transitional;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new core_AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});

;// ./node_modules/axios/lib/helpers/composeSignals.js




const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof core_AxiosError ? err : new cancel_CanceledError(err instanceof Error ? err.message : err));
      }
    }

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new core_AxiosError(`timeout ${timeout} of ms exceeded`, core_AxiosError.ETIMEDOUT))
    }, timeout)

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    }

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils.asap(unsubscribe);

    return signal;
  }
}

/* harmony default export */ const helpers_composeSignals = (composeSignals);

;// ./node_modules/axios/lib/helpers/trackStream.js

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
}

;// ./node_modules/axios/lib/adapters/fetch.js










const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
}

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new core_AxiosError(`Response type '${type}' is not supported`, core_AxiosError.ERR_NOT_SUPPORT, config);
      })
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils.isBlob(body)) {
    return body.size;
  }

  if(utils.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}

const resolveBodyLength = async (headers, body) => {
  const length = utils.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
}

/* harmony default export */ const adapters_fetch = (isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = helpers_composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader)
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request, fetchOptions);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: core_AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      })
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw core_AxiosError.from(err, err && err.code, config, request);
  }
}));



;// ./node_modules/axios/lib/adapters/adapters.js






const knownAdapters = {
  http: helpers_null,
  xhr: xhr,
  fetch: adapters_fetch
}

utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;

/* harmony default export */ const adapters = ({
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new core_AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new core_AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
});

;// ./node_modules/axios/lib/core/dispatchRequest.js









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new cancel_CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = core_AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = core_AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

;// ./node_modules/axios/lib/env/data.js
const VERSION = "1.11.0";
;// ./node_modules/axios/lib/helpers/validator.js





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new core_AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        core_AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const validator = ({
  assertOptions,
  validators
});

;// ./node_modules/axios/lib/core/Axios.js











const Axios_validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new core_InterceptorManager(),
      response: new core_InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: Axios_validators.function,
          serialize: Axios_validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) {
      // do nothing
    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    validator.assertOptions(config, {
      baseUrl: Axios_validators.spelling('baseURL'),
      withXsrfToken: Axios_validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const core_Axios = (Axios);

;// ./node_modules/axios/lib/cancel/CancelToken.js




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new cancel_CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const cancel_CancelToken = (CancelToken);

;// ./node_modules/axios/lib/helpers/spread.js


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

;// ./node_modules/axios/lib/helpers/isAxiosError.js




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

;// ./node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);

;// ./node_modules/axios/lib/axios.js




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new core_Axios(defaultConfig);
  const instance = bind(core_Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(lib_defaults);

// Expose Axios class to allow class inheritance
axios.Axios = core_Axios;

// Expose Cancel & CancelToken
axios.CanceledError = cancel_CanceledError;
axios.CancelToken = cancel_CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = helpers_toFormData;

// Expose AxiosError class
axios.AxiosError = core_AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = core_AxiosHeaders;

axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = helpers_HttpStatusCode;

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const lib_axios = (axios);

;// ./src/http-client/axios-client.ts

var axiosClient = lib_axios;
var create = lib_axios.create;

/***/ }),

/***/ 127:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * URI.js - Mutating URLs
 * URI Template Support - http://tools.ietf.org/html/rfc6570
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if ( true && module.exports) {
    // Node
    module.exports = factory(__webpack_require__(193));
  } else if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(193)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else // removed by dead control flow
{}
}(this, function (URI, root) {
  'use strict';
  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
  /*jshint camelcase: false */

  // save current URITemplate variable, if any
  var _URITemplate = root && root.URITemplate;

  var hasOwn = Object.prototype.hasOwnProperty;
  function URITemplate(expression) {
    // serve from cache where possible
    if (URITemplate._cache[expression]) {
      return URITemplate._cache[expression];
    }

    // Allow instantiation without the 'new' keyword
    if (!(this instanceof URITemplate)) {
      return new URITemplate(expression);
    }

    this.expression = expression;
    URITemplate._cache[expression] = this;
    return this;
  }

  function Data(data) {
    this.data = data;
    this.cache = {};
  }

  var p = URITemplate.prototype;
  // list of operators and their defined options
  var operators = {
    // Simple string expansion
    '' : {
      prefix: '',
      separator: ',',
      named: false,
      empty_name_separator: false,
      encode : 'encode'
    },
    // Reserved character strings
    '+' : {
      prefix: '',
      separator: ',',
      named: false,
      empty_name_separator: false,
      encode : 'encodeReserved'
    },
    // Fragment identifiers prefixed by '#'
    '#' : {
      prefix: '#',
      separator: ',',
      named: false,
      empty_name_separator: false,
      encode : 'encodeReserved'
    },
    // Name labels or extensions prefixed by '.'
    '.' : {
      prefix: '.',
      separator: '.',
      named: false,
      empty_name_separator: false,
      encode : 'encode'
    },
    // Path segments prefixed by '/'
    '/' : {
      prefix: '/',
      separator: '/',
      named: false,
      empty_name_separator: false,
      encode : 'encode'
    },
    // Path parameter name or name=value pairs prefixed by ';'
    ';' : {
      prefix: ';',
      separator: ';',
      named: true,
      empty_name_separator: false,
      encode : 'encode'
    },
    // Query component beginning with '?' and consisting
    // of name=value pairs separated by '&'; an
    '?' : {
      prefix: '?',
      separator: '&',
      named: true,
      empty_name_separator: true,
      encode : 'encode'
    },
    // Continuation of query-style &name=value pairs
    // within a literal query component.
    '&' : {
      prefix: '&',
      separator: '&',
      named: true,
      empty_name_separator: true,
      encode : 'encode'
    }

    // The operator characters equals ("="), comma (","), exclamation ("!"),
    // at sign ("@"), and pipe ("|") are reserved for future extensions.
  };

  // storage for already parsed templates
  URITemplate._cache = {};
  // pattern to identify expressions [operator, variable-list] in template
  URITemplate.EXPRESSION_PATTERN = /\{([^a-zA-Z0-9%_]?)([^\}]+)(\}|$)/g;
  // pattern to identify variables [name, explode, maxlength] in variable-list
  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\.?[^*:.])*)((\*)|:(\d+))?$/;
  // pattern to verify variable name integrity
  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/;
  // pattern to verify literal integrity
  URITemplate.LITERAL_PATTERN = /[<>{}"`^| \\]/;

  // expand parsed expression (expression, not template!)
  URITemplate.expand = function(expression, data, opts) {
    // container for defined options for the given operator
    var options = operators[expression.operator];
    // expansion type (include keys or not)
    var type = options.named ? 'Named' : 'Unnamed';
    // list of variables within the expression
    var variables = expression.variables;
    // result buffer for evaluating the expression
    var buffer = [];
    var d, variable, i;

    for (i = 0; (variable = variables[i]); i++) {
      // fetch simplified data source
      d = data.get(variable.name);
      if (d.type === 0 && opts && opts.strict) {
          throw new Error('Missing expansion value for variable "' + variable.name + '"');
      }
      if (!d.val.length) {
        if (d.type) {
          // empty variables (empty string)
          // still lead to a separator being appended!
          buffer.push('');
        }
        // no data, no action
        continue;
      }

      if (d.type > 1 && variable.maxlength) {
        // composite variable cannot specify maxlength
        throw new Error('Invalid expression: Prefix modifier not applicable to variable "' + variable.name + '"');
      }

      // expand the given variable
      buffer.push(URITemplate['expand' + type](
        d,
        options,
        variable.explode,
        variable.explode && options.separator || ',',
        variable.maxlength,
        variable.name
      ));
    }

    if (buffer.length) {
      return options.prefix + buffer.join(options.separator);
    } else {
      // prefix is not prepended for empty expressions
      return '';
    }
  };
  // expand a named variable
  URITemplate.expandNamed = function(d, options, explode, separator, length, name) {
    // variable result buffer
    var result = '';
    // peformance crap
    var encode = options.encode;
    var empty_name_separator = options.empty_name_separator;
    // flag noting if values are already encoded
    var _encode = !d[encode].length;
    // key for named expansion
    var _name = d.type === 2 ? '': URI[encode](name);
    var _value, i, l;

    // for each found value
    for (i = 0, l = d.val.length; i < l; i++) {
      if (length) {
        // maxlength must be determined before encoding can happen
        _value = URI[encode](d.val[i][1].substring(0, length));
        if (d.type === 2) {
          // apply maxlength to keys of objects as well
          _name = URI[encode](d.val[i][0].substring(0, length));
        }
      } else if (_encode) {
        // encode value
        _value = URI[encode](d.val[i][1]);
        if (d.type === 2) {
          // encode name and cache encoded value
          _name = URI[encode](d.val[i][0]);
          d[encode].push([_name, _value]);
        } else {
          // cache encoded value
          d[encode].push([undefined, _value]);
        }
      } else {
        // values are already encoded and can be pulled from cache
        _value = d[encode][i][1];
        if (d.type === 2) {
          _name = d[encode][i][0];
        }
      }

      if (result) {
        // unless we're the first value, prepend the separator
        result += separator;
      }

      if (!explode) {
        if (!i) {
          // first element, so prepend variable name
          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');
        }

        if (d.type === 2) {
          // without explode-modifier, keys of objects are returned comma-separated
          result += _name + ',';
        }

        result += _value;
      } else {
        // only add the = if it is either default (?&) or there actually is a value (;)
        result += _name + (empty_name_separator || _value ? '=' : '') + _value;
      }
    }

    return result;
  };
  // expand an unnamed variable
  URITemplate.expandUnnamed = function(d, options, explode, separator, length) {
    // variable result buffer
    var result = '';
    // performance crap
    var encode = options.encode;
    var empty_name_separator = options.empty_name_separator;
    // flag noting if values are already encoded
    var _encode = !d[encode].length;
    var _name, _value, i, l;

    // for each found value
    for (i = 0, l = d.val.length; i < l; i++) {
      if (length) {
        // maxlength must be determined before encoding can happen
        _value = URI[encode](d.val[i][1].substring(0, length));
      } else if (_encode) {
        // encode and cache value
        _value = URI[encode](d.val[i][1]);
        d[encode].push([
          d.type === 2 ? URI[encode](d.val[i][0]) : undefined,
          _value
        ]);
      } else {
        // value already encoded, pull from cache
        _value = d[encode][i][1];
      }

      if (result) {
        // unless we're the first value, prepend the separator
        result += separator;
      }

      if (d.type === 2) {
        if (length) {
          // maxlength also applies to keys of objects
          _name = URI[encode](d.val[i][0].substring(0, length));
        } else {
          // at this point the name must already be encoded
          _name = d[encode][i][0];
        }

        result += _name;
        if (explode) {
          // explode-modifier separates name and value by "="
          result += (empty_name_separator || _value ? '=' : '');
        } else {
          // no explode-modifier separates name and value by ","
          result += ',';
        }
      }

      result += _value;
    }

    return result;
  };

  URITemplate.noConflict = function() {
    if (root.URITemplate === URITemplate) {
      root.URITemplate = _URITemplate;
    }

    return URITemplate;
  };

  // expand template through given data map
  p.expand = function(data, opts) {
    var result = '';

    if (!this.parts || !this.parts.length) {
      // lazilyy parse the template
      this.parse();
    }

    if (!(data instanceof Data)) {
      // make given data available through the
      // optimized data handling thingie
      data = new Data(data);
    }

    for (var i = 0, l = this.parts.length; i < l; i++) {
      /*jshint laxbreak: true */
      result += typeof this.parts[i] === 'string'
        // literal string
        ? this.parts[i]
        // expression
        : URITemplate.expand(this.parts[i], data, opts);
      /*jshint laxbreak: false */
    }

    return result;
  };
  // parse template into action tokens
  p.parse = function() {
    // performance crap
    var expression = this.expression;
    var ePattern = URITemplate.EXPRESSION_PATTERN;
    var vPattern = URITemplate.VARIABLE_PATTERN;
    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;
    var lPattern = URITemplate.LITERAL_PATTERN;
    // token result buffer
    var parts = [];
      // position within source template
    var pos = 0;
    var variables, eMatch, vMatch;

    var checkLiteral = function(literal) {
      if (literal.match(lPattern)) {
        throw new Error('Invalid Literal "' + literal + '"');
      }
      return literal;
    };

    // RegExp is shared accross all templates,
    // which requires a manual reset
    ePattern.lastIndex = 0;
    // I don't like while(foo = bar()) loops,
    // to make things simpler I go while(true) and break when required
    while (true) {
      eMatch = ePattern.exec(expression);
      if (eMatch === null) {
        // push trailing literal
        parts.push(checkLiteral(expression.substring(pos)));
        break;
      } else {
        // push leading literal
        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));
        pos = eMatch.index + eMatch[0].length;
      }

      if (!operators[eMatch[1]]) {
        throw new Error('Unknown Operator "' + eMatch[1]  + '" in "' + eMatch[0] + '"');
      } else if (!eMatch[3]) {
        throw new Error('Unclosed Expression "' + eMatch[0]  + '"');
      }

      // parse variable-list
      variables = eMatch[2].split(',');
      for (var i = 0, l = variables.length; i < l; i++) {
        vMatch = variables[i].match(vPattern);
        if (vMatch === null) {
          throw new Error('Invalid Variable "' + variables[i] + '" in "' + eMatch[0] + '"');
        } else if (vMatch[1].match(nPattern)) {
          throw new Error('Invalid Variable Name "' + vMatch[1] + '" in "' + eMatch[0] + '"');
        }

        variables[i] = {
          name: vMatch[1],
          explode: !!vMatch[3],
          maxlength: vMatch[4] && parseInt(vMatch[4], 10)
        };
      }

      if (!variables.length) {
        throw new Error('Expression Missing Variable(s) "' + eMatch[0] + '"');
      }

      parts.push({
        expression: eMatch[0],
        operator: eMatch[1],
        variables: variables
      });
    }

    if (!parts.length) {
      // template doesn't contain any expressions
      // so it is a simple literal string
      // this probably should fire a warning or something?
      parts.push(checkLiteral(expression));
    }

    this.parts = parts;
    return this;
  };

  // simplify data structures
  Data.prototype.get = function(key) {
    // performance crap
    var data = this.data;
    // cache for processed data-point
    var d = {
      // type of data 0: undefined/null, 1: string, 2: object, 3: array
      type: 0,
      // original values (except undefined/null)
      val: [],
      // cache for encoded values (only for non-maxlength expansion)
      encode: [],
      encodeReserved: []
    };
    var i, l, value;

    if (this.cache[key] !== undefined) {
      // we've already processed this key
      return this.cache[key];
    }

    this.cache[key] = d;

    if (String(Object.prototype.toString.call(data)) === '[object Function]') {
      // data itself is a callback (global callback)
      value = data(key);
    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {
      // data is a map of callbacks (local callback)
      value = data[key](key);
    } else {
      // data is a map of data
      value = data[key];
    }

    // generalize input into [ [name1, value1], [name2, value2], … ]
    // so expansion has to deal with a single data structure only
    if (value === undefined || value === null) {
      // undefined and null values are to be ignored completely
      return d;
    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {
      for (i = 0, l = value.length; i < l; i++) {
        if (value[i] !== undefined && value[i] !== null) {
          // arrays don't have names
          d.val.push([undefined, String(value[i])]);
        }
      }

      if (d.val.length) {
        // only treat non-empty arrays as arrays
        d.type = 3; // array
      }
    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {
      for (i in value) {
        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {
          // objects have keys, remember them for named expansion
          d.val.push([i, String(value[i])]);
        }
      }

      if (d.val.length) {
        // only treat non-empty objects as objects
        d.type = 2; // object
      }
    } else {
      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())
      // arrays don't have names
      d.val.push([undefined, String(value)]);
    }

    return d;
  };

  // hook into URI for fluid access
  URI.expand = function(expression, data) {
    var template = new URITemplate(expression);
    var expansion = template.expand(data);

    return new URI(expansion);
  };

  return URITemplate;
}));


/***/ }),

/***/ 193:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if ( true && module.exports) {
    // Node
    module.exports = factory(__webpack_require__(340), __webpack_require__(430), __webpack_require__(704));
  } else if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(340), __webpack_require__(430), __webpack_require__(704)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else // removed by dead control flow
{}
}(this, function (punycode, IPv6, SLD, root) {
  'use strict';
  /*global location, escape, unescape */
  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
  /*jshint camelcase: false */

  // save current URI variable, if any
  var _URI = root && root.URI;

  function URI(url, base) {
    var _urlSupplied = arguments.length >= 1;
    var _baseSupplied = arguments.length >= 2;

    // Allow instantiation without the 'new' keyword
    if (!(this instanceof URI)) {
      if (_urlSupplied) {
        if (_baseSupplied) {
          return new URI(url, base);
        }

        return new URI(url);
      }

      return new URI();
    }

    if (url === undefined) {
      if (_urlSupplied) {
        throw new TypeError('undefined is not a valid argument for URI');
      }

      if (typeof location !== 'undefined') {
        url = location.href + '';
      } else {
        url = '';
      }
    }

    if (url === null) {
      if (_urlSupplied) {
        throw new TypeError('null is not a valid argument for URI');
      }
    }

    this.href(url);

    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
    if (base !== undefined) {
      return this.absoluteTo(base);
    }

    return this;
  }

  function isInteger(value) {
    return /^[0-9]+$/.test(value);
  }

  URI.version = '1.19.11';

  var p = URI.prototype;
  var hasOwn = Object.prototype.hasOwnProperty;

  function escapeRegEx(string) {
    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  function getType(value) {
    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
    if (value === undefined) {
      return 'Undefined';
    }

    return String(Object.prototype.toString.call(value)).slice(8, -1);
  }

  function isArray(obj) {
    return getType(obj) === 'Array';
  }

  function filterArrayValues(data, value) {
    var lookup = {};
    var i, length;

    if (getType(value) === 'RegExp') {
      lookup = null;
    } else if (isArray(value)) {
      for (i = 0, length = value.length; i < length; i++) {
        lookup[value[i]] = true;
      }
    } else {
      lookup[value] = true;
    }

    for (i = 0, length = data.length; i < length; i++) {
      /*jshint laxbreak: true */
      var _match = lookup && lookup[data[i]] !== undefined
        || !lookup && value.test(data[i]);
      /*jshint laxbreak: false */
      if (_match) {
        data.splice(i, 1);
        length--;
        i--;
      }
    }

    return data;
  }

  function arrayContains(list, value) {
    var i, length;

    // value may be string, number, array, regexp
    if (isArray(value)) {
      // Note: this can be optimized to O(n) (instead of current O(m * n))
      for (i = 0, length = value.length; i < length; i++) {
        if (!arrayContains(list, value[i])) {
          return false;
        }
      }

      return true;
    }

    var _type = getType(value);
    for (i = 0, length = list.length; i < length; i++) {
      if (_type === 'RegExp') {
        if (typeof list[i] === 'string' && list[i].match(value)) {
          return true;
        }
      } else if (list[i] === value) {
        return true;
      }
    }

    return false;
  }

  function arraysEqual(one, two) {
    if (!isArray(one) || !isArray(two)) {
      return false;
    }

    // arrays can't be equal if they have different amount of content
    if (one.length !== two.length) {
      return false;
    }

    one.sort();
    two.sort();

    for (var i = 0, l = one.length; i < l; i++) {
      if (one[i] !== two[i]) {
        return false;
      }
    }

    return true;
  }

  function trimSlashes(text) {
    var trim_expression = /^\/+|\/+$/g;
    return text.replace(trim_expression, '');
  }

  URI._parts = function() {
    return {
      protocol: null,
      username: null,
      password: null,
      hostname: null,
      urn: null,
      port: null,
      path: null,
      query: null,
      fragment: null,
      // state
      preventInvalidHostname: URI.preventInvalidHostname,
      duplicateQueryParameters: URI.duplicateQueryParameters,
      escapeQuerySpace: URI.escapeQuerySpace
    };
  };
  // state: throw on invalid hostname
  // see https://github.com/medialize/URI.js/pull/345
  // and https://github.com/medialize/URI.js/issues/354
  URI.preventInvalidHostname = false;
  // state: allow duplicate query parameters (a=1&a=1)
  URI.duplicateQueryParameters = false;
  // state: replaces + with %20 (space in query strings)
  URI.escapeQuerySpace = true;
  // static properties
  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
  URI.idn_expression = /[^a-z0-9\._-]/i;
  URI.punycode_expression = /(xn--)/i;
  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  // credits to Rich Brown
  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
  // specification: http://www.ietf.org/rfc/rfc4291.txt
  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  // expression used is "gruber revised" (@gruber v2) determined to be the
  // best solution in a regex-golf we did a couple of ages ago at
  // * http://mathiasbynens.be/demo/url-regex
  // * http://rodneyrehm.de/t/url-regex.html
  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
  URI.findUri = {
    // valid "scheme://" or "www."
    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
    // everything up to the next whitespace
    end: /[\s\r\n]|$/,
    // trim trailing punctuation captured by end RegExp
    trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
    // balanced parens inclusion (), [], {}, <>
    parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g,
  };
  URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  // https://infra.spec.whatwg.org/#ascii-tab-or-newline
  URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g
  // http://www.iana.org/assignments/uri-schemes.html
  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
  URI.defaultPorts = {
    http: '80',
    https: '443',
    ftp: '21',
    gopher: '70',
    ws: '80',
    wss: '443'
  };
  // list of protocols which always require a hostname
  URI.hostProtocols = [
    'http',
    'https'
  ];

  // allowed hostname characters according to RFC 3986
  // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . - _
  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
  // map DOM Elements to their URI attribute
  URI.domAttributes = {
    'a': 'href',
    'blockquote': 'cite',
    'link': 'href',
    'base': 'href',
    'script': 'src',
    'form': 'action',
    'img': 'src',
    'area': 'href',
    'iframe': 'src',
    'embed': 'src',
    'source': 'src',
    'track': 'src',
    'input': 'src', // but only if type="image"
    'audio': 'src',
    'video': 'src'
  };
  URI.getDomAttribute = function(node) {
    if (!node || !node.nodeName) {
      return undefined;
    }

    var nodeName = node.nodeName.toLowerCase();
    // <input> should only expose src for type="image"
    if (nodeName === 'input' && node.type !== 'image') {
      return undefined;
    }

    return URI.domAttributes[nodeName];
  };

  function escapeForDumbFirefox36(value) {
    // https://github.com/medialize/URI.js/issues/91
    return escape(value);
  }

  // encoding / decoding according to RFC3986
  function strictEncodeURIComponent(string) {
    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
    return encodeURIComponent(string)
      .replace(/[!'()*]/g, escapeForDumbFirefox36)
      .replace(/\*/g, '%2A');
  }
  URI.encode = strictEncodeURIComponent;
  URI.decode = decodeURIComponent;
  URI.iso8859 = function() {
    URI.encode = escape;
    URI.decode = unescape;
  };
  URI.unicode = function() {
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
  };
  URI.characters = {
    pathname: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
        map: {
          // -._~!'()*
          '%24': '$',
          '%26': '&',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%3A': ':',
          '%40': '@'
        }
      },
      decode: {
        expression: /[\/\?#]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23'
        }
      }
    },
    reserved: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
        map: {
          // gen-delims
          '%3A': ':',
          '%2F': '/',
          '%3F': '?',
          '%23': '#',
          '%5B': '[',
          '%5D': ']',
          '%40': '@',
          // sub-delims
          '%21': '!',
          '%24': '$',
          '%26': '&',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '='
        }
      }
    },
    urnpath: {
      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
      // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
      // note that the colon character is not featured in the encoding map; this is because URI.js
      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
      // should not appear unencoded in a segment itself.
      // See also the note above about RFC3986 and capitalalized hex digits.
      encode: {
        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
        map: {
          '%21': '!',
          '%24': '$',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%40': '@'
        }
      },
      // These characters are the characters called out by RFC2141 as "reserved" characters that
      // should never appear in a URN, plus the colon character (see note above).
      decode: {
        expression: /[\/\?#:]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23',
          ':': '%3A'
        }
      }
    }
  };
  URI.encodeQuery = function(string, escapeQuerySpace) {
    var escaped = URI.encode(string + '');
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
  };
  URI.decodeQuery = function(string, escapeQuerySpace) {
    string += '';
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    try {
      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
    } catch(e) {
      // we're not going to mess with weird encodings,
      // give up and return the undecoded original string
      // see https://github.com/medialize/URI.js/issues/87
      // see https://github.com/medialize/URI.js/issues/92
      return string;
    }
  };
  // generate encode/decode path functions
  var _parts = {'encode':'encode', 'decode':'decode'};
  var _part;
  var generateAccessor = function(_group, _part) {
    return function(string) {
      try {
        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
          return URI.characters[_group][_part].map[c];
        });
      } catch (e) {
        // we're not going to mess with weird encodings,
        // give up and return the undecoded original string
        // see https://github.com/medialize/URI.js/issues/87
        // see https://github.com/medialize/URI.js/issues/92
        return string;
      }
    };
  };

  for (_part in _parts) {
    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
  }

  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
    return function(string) {
      // Why pass in names of functions, rather than the function objects themselves? The
      // definitions of some functions (but in particular, URI.decode) will occasionally change due
      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure
      // that the functions we use here are "fresh".
      var actualCodingFunc;
      if (!_innerCodingFuncName) {
        actualCodingFunc = URI[_codingFuncName];
      } else {
        actualCodingFunc = function(string) {
          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
        };
      }

      var segments = (string + '').split(_sep);

      for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = actualCodingFunc(segments[i]);
      }

      return segments.join(_sep);
    };
  };

  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.
  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');

  URI.encodeReserved = generateAccessor('reserved', 'encode');

  URI.parse = function(string, parts) {
    var pos;
    if (!parts) {
      parts = {
        preventInvalidHostname: URI.preventInvalidHostname
      };
    }

    string = string.replace(URI.leading_whitespace_expression, '')
    // https://infra.spec.whatwg.org/#ascii-tab-or-newline
    string = string.replace(URI.ascii_tab_whitespace, '')

    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

    // extract fragment
    pos = string.indexOf('#');
    if (pos > -1) {
      // escaping?
      parts.fragment = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract query
    pos = string.indexOf('?');
    if (pos > -1) {
      // escaping?
      parts.query = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // slashes and backslashes have lost all meaning for the web protocols (https, http, wss, ws)
    string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, '$1://');
    // slashes and backslashes have lost all meaning for scheme relative URLs
    string = string.replace(/^[/\\]{2,}/i, '//');

    // extract protocol
    if (string.substring(0, 2) === '//') {
      // relative-scheme
      parts.protocol = null;
      string = string.substring(2);
      // extract "user:pass@host:port"
      string = URI.parseAuthority(string, parts);
    } else {
      pos = string.indexOf(':');
      if (pos > -1) {
        parts.protocol = string.substring(0, pos) || null;
        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
          // : may be within the path
          parts.protocol = undefined;
        } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, '/') === '//') {
          string = string.substring(pos + 3);

          // extract "user:pass@host:port"
          string = URI.parseAuthority(string, parts);
        } else {
          string = string.substring(pos + 1);
          parts.urn = true;
        }
      }
    }

    // what's left must be the path
    parts.path = string;

    // and we're done
    return parts;
  };
  URI.parseHost = function(string, parts) {
    if (!string) {
      string = '';
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    // https://github.com/medialize/URI.js/pull/233
    string = string.replace(/\\/g, '/');

    // extract host:port
    var pos = string.indexOf('/');
    var bracketPos;
    var t;

    if (pos === -1) {
      pos = string.length;
    }

    if (string.charAt(0) === '[') {
      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
      // IPv6+port in the format [2001:db8::1]:80 (for the time being)
      bracketPos = string.indexOf(']');
      parts.hostname = string.substring(1, bracketPos) || null;
      parts.port = string.substring(bracketPos + 2, pos) || null;
      if (parts.port === '/') {
        parts.port = null;
      }
    } else {
      var firstColon = string.indexOf(':');
      var firstSlash = string.indexOf('/');
      var nextColon = string.indexOf(':', firstColon + 1);
      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
        // IPv6 host contains multiple colons - but no port
        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
        parts.hostname = string.substring(0, pos) || null;
        parts.port = null;
      } else {
        t = string.substring(0, pos).split(':');
        parts.hostname = t[0] || null;
        parts.port = t[1] || null;
      }
    }

    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
      pos++;
      string = '/' + string;
    }

    if (parts.preventInvalidHostname) {
      URI.ensureValidHostname(parts.hostname, parts.protocol);
    }

    if (parts.port) {
      URI.ensureValidPort(parts.port);
    }

    return string.substring(pos) || '/';
  };
  URI.parseAuthority = function(string, parts) {
    string = URI.parseUserinfo(string, parts);
    return URI.parseHost(string, parts);
  };
  URI.parseUserinfo = function(string, parts) {
    // extract username:password
    var _string = string
    var firstBackSlash = string.indexOf('\\');
    if (firstBackSlash !== -1) {
      string = string.replace(/\\/g, '/')
    }
    var firstSlash = string.indexOf('/');
    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
    var t;

    // authority@ must come before /path or \path
    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
      t = string.substring(0, pos).split(':');
      parts.username = t[0] ? URI.decode(t[0]) : null;
      t.shift();
      parts.password = t[0] ? URI.decode(t.join(':')) : null;
      string = _string.substring(pos + 1);
    } else {
      parts.username = null;
      parts.password = null;
    }

    return string;
  };
  URI.parseQuery = function(string, escapeQuerySpace) {
    if (!string) {
      return {};
    }

    // throw out the funky business - "?"[name"="value"&"]+
    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

    if (!string) {
      return {};
    }

    var items = {};
    var splits = string.split('&');
    var length = splits.length;
    var v, name, value;

    for (var i = 0; i < length; i++) {
      v = splits[i].split('=');
      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
      // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

      if (name === '__proto__') {
        // ignore attempt at exploiting JavaScript internals
        continue;
      } else if (hasOwn.call(items, name)) {
        if (typeof items[name] === 'string' || items[name] === null) {
          items[name] = [items[name]];
        }

        items[name].push(value);
      } else {
        items[name] = value;
      }
    }

    return items;
  };

  URI.build = function(parts) {
    var t = '';
    var requireAbsolutePath = false

    if (parts.protocol) {
      t += parts.protocol + ':';
    }

    if (!parts.urn && (t || parts.hostname)) {
      t += '//';
      requireAbsolutePath = true
    }

    t += (URI.buildAuthority(parts) || '');

    if (typeof parts.path === 'string') {
      if (parts.path.charAt(0) !== '/' && requireAbsolutePath) {
        t += '/';
      }

      t += parts.path;
    }

    if (typeof parts.query === 'string' && parts.query) {
      t += '?' + parts.query;
    }

    if (typeof parts.fragment === 'string' && parts.fragment) {
      t += '#' + parts.fragment;
    }
    return t;
  };
  URI.buildHost = function(parts) {
    var t = '';

    if (!parts.hostname) {
      return '';
    } else if (URI.ip6_expression.test(parts.hostname)) {
      t += '[' + parts.hostname + ']';
    } else {
      t += parts.hostname;
    }

    if (parts.port) {
      t += ':' + parts.port;
    }

    return t;
  };
  URI.buildAuthority = function(parts) {
    return URI.buildUserinfo(parts) + URI.buildHost(parts);
  };
  URI.buildUserinfo = function(parts) {
    var t = '';

    if (parts.username) {
      t += URI.encode(parts.username);
    }

    if (parts.password) {
      t += ':' + URI.encode(parts.password);
    }

    if (t) {
      t += '@';
    }

    return t;
  };
  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
    // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed
    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
    // URI.js treats the query string as being application/x-www-form-urlencoded
    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

    var t = '';
    var unique, key, i, length;
    for (key in data) {
      if (key === '__proto__') {
        // ignore attempt at exploiting JavaScript internals
        continue;
      } else if (hasOwn.call(data, key)) {
        if (isArray(data[key])) {
          unique = {};
          for (i = 0, length = data[key].length; i < length; i++) {
            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
              if (duplicateQueryParameters !== true) {
                unique[data[key][i] + ''] = true;
              }
            }
          }
        } else if (data[key] !== undefined) {
          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
        }
      }
    }

    return t.substring(1);
  };
  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
  };

  URI.addQuery = function(data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.addQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (data[name] === undefined) {
        data[name] = value;
        return;
      } else if (typeof data[name] === 'string') {
        data[name] = [data[name]];
      }

      if (!isArray(value)) {
        value = [value];
      }

      data[name] = (data[name] || []).concat(value);
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }
  };

  URI.setQuery = function(data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.setQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      data[name] = value === undefined ? null : value;
    } else {
      throw new TypeError('URI.setQuery() accepts an object, string as the name parameter');
    }
  };

  URI.removeQuery = function(data, name, value) {
    var i, length, key;

    if (isArray(name)) {
      for (i = 0, length = name.length; i < length; i++) {
        data[name[i]] = undefined;
      }
    } else if (getType(name) === 'RegExp') {
      for (key in data) {
        if (name.test(key)) {
          data[key] = undefined;
        }
      }
    } else if (typeof name === 'object') {
      for (key in name) {
        if (hasOwn.call(name, key)) {
          URI.removeQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (value !== undefined) {
        if (getType(value) === 'RegExp') {
          if (!isArray(data[name]) && value.test(data[name])) {
            data[name] = undefined;
          } else {
            data[name] = filterArrayValues(data[name], value);
          }
        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
          data[name] = undefined;
        } else if (isArray(data[name])) {
          data[name] = filterArrayValues(data[name], value);
        }
      } else {
        data[name] = undefined;
      }
    } else {
      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
    }
  };
  URI.hasQuery = function(data, name, value, withinArray) {
    switch (getType(name)) {
      case 'String':
        // Nothing to do here
        break;

      case 'RegExp':
        for (var key in data) {
          if (hasOwn.call(data, key)) {
            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
              return true;
            }
          }
        }

        return false;

      case 'Object':
        for (var _key in name) {
          if (hasOwn.call(name, _key)) {
            if (!URI.hasQuery(data, _key, name[_key])) {
              return false;
            }
          }
        }

        return true;

      default:
        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
    }

    switch (getType(value)) {
      case 'Undefined':
        // true if exists (but may be empty)
        return name in data; // data[name] !== undefined;

      case 'Boolean':
        // true if exists and non-empty
        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
        return value === _booly;

      case 'Function':
        // allow complex comparison
        return !!value(data[name], name, data);

      case 'Array':
        if (!isArray(data[name])) {
          return false;
        }

        var op = withinArray ? arrayContains : arraysEqual;
        return op(data[name], value);

      case 'RegExp':
        if (!isArray(data[name])) {
          return Boolean(data[name] && data[name].match(value));
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      case 'Number':
        value = String(value);
        /* falls through */
      case 'String':
        if (!isArray(data[name])) {
          return data[name] === value;
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      default:
        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
    }
  };


  URI.joinPaths = function() {
    var input = [];
    var segments = [];
    var nonEmptySegments = 0;

    for (var i = 0; i < arguments.length; i++) {
      var url = new URI(arguments[i]);
      input.push(url);
      var _segments = url.segment();
      for (var s = 0; s < _segments.length; s++) {
        if (typeof _segments[s] === 'string') {
          segments.push(_segments[s]);
        }

        if (_segments[s]) {
          nonEmptySegments++;
        }
      }
    }

    if (!segments.length || !nonEmptySegments) {
      return new URI('');
    }

    var uri = new URI('').segment(segments);

    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {
      uri.path('/' + uri.path());
    }

    return uri.normalize();
  };

  URI.commonPath = function(one, two) {
    var length = Math.min(one.length, two.length);
    var pos;

    // find first non-matching character
    for (pos = 0; pos < length; pos++) {
      if (one.charAt(pos) !== two.charAt(pos)) {
        pos--;
        break;
      }
    }

    if (pos < 1) {
      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
    }

    // revert to last /
    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
      pos = one.substring(0, pos).lastIndexOf('/');
    }

    return one.substring(0, pos + 1);
  };

  URI.withinString = function(string, callback, options) {
    options || (options = {});
    var _start = options.start || URI.findUri.start;
    var _end = options.end || URI.findUri.end;
    var _trim = options.trim || URI.findUri.trim;
    var _parens = options.parens || URI.findUri.parens;
    var _attributeOpen = /[a-z0-9-]=["']?$/i;

    _start.lastIndex = 0;
    while (true) {
      var match = _start.exec(string);
      if (!match) {
        break;
      }

      var start = match.index;
      if (options.ignoreHtml) {
        // attribut(e=["']?$)
        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
          continue;
        }
      }

      var end = start + string.slice(start).search(_end);
      var slice = string.slice(start, end);
      // make sure we include well balanced parens
      var parensEnd = -1;
      while (true) {
        var parensMatch = _parens.exec(slice);
        if (!parensMatch) {
          break;
        }

        var parensMatchEnd = parensMatch.index + parensMatch[0].length;
        parensEnd = Math.max(parensEnd, parensMatchEnd);
      }

      if (parensEnd > -1) {
        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, '');
      } else {
        slice = slice.replace(_trim, '');
      }

      if (slice.length <= match[0].length) {
        // the extract only contains the starting marker of a URI,
        // e.g. "www" or "http://"
        continue;
      }

      if (options.ignore && options.ignore.test(slice)) {
        continue;
      }

      end = start + slice.length;
      var result = callback(slice, start, end, string);
      if (result === undefined) {
        _start.lastIndex = end;
        continue;
      }

      result = String(result);
      string = string.slice(0, start) + result + string.slice(end);
      _start.lastIndex = start + result.length;
    }

    _start.lastIndex = 0;
    return string;
  };

  URI.ensureValidHostname = function(v, protocol) {
    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
    // they are not part of DNS and therefore ignored by URI.js

    var hasHostname = !!v; // not null and not an empty string
    var hasProtocol = !!protocol;
    var rejectEmptyHostname = false;

    if (hasProtocol) {
      rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
    }

    if (rejectEmptyHostname && !hasHostname) {
      throw new TypeError('Hostname cannot be empty, if protocol is ' + protocol);
    } else if (v && v.match(URI.invalid_hostname_characters)) {
      // test punycode
      if (!punycode) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
      }
      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
      }
    }
  };

  URI.ensureValidPort = function (v) {
    if (!v) {
      return;
    }

    var port = Number(v);
    if (isInteger(port) && (port > 0) && (port < 65536)) {
      return;
    }

    throw new TypeError('Port "' + v + '" is not a valid port');
  };

  // noConflict
  URI.noConflict = function(removeAll) {
    if (removeAll) {
      var unconflicted = {
        URI: this.noConflict()
      };

      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
        unconflicted.URITemplate = root.URITemplate.noConflict();
      }

      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
        unconflicted.IPv6 = root.IPv6.noConflict();
      }

      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
      }

      return unconflicted;
    } else if (root.URI === this) {
      root.URI = _URI;
    }

    return this;
  };

  p.build = function(deferBuild) {
    if (deferBuild === true) {
      this._deferred_build = true;
    } else if (deferBuild === undefined || this._deferred_build) {
      this._string = URI.build(this._parts);
      this._deferred_build = false;
    }

    return this;
  };

  p.clone = function() {
    return new URI(this);
  };

  p.valueOf = p.toString = function() {
    return this.build(false)._string;
  };


  function generateSimpleAccessor(_part){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        this._parts[_part] = v || null;
        this.build(!build);
        return this;
      }
    };
  }

  function generatePrefixAccessor(_part, _key){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        if (v !== null) {
          v = v + '';
          if (v.charAt(0) === _key) {
            v = v.substring(1);
          }
        }

        this._parts[_part] = v;
        this.build(!build);
        return this;
      }
    };
  }

  p.protocol = generateSimpleAccessor('protocol');
  p.username = generateSimpleAccessor('username');
  p.password = generateSimpleAccessor('password');
  p.hostname = generateSimpleAccessor('hostname');
  p.port = generateSimpleAccessor('port');
  p.query = generatePrefixAccessor('query', '?');
  p.fragment = generatePrefixAccessor('fragment', '#');

  p.search = function(v, build) {
    var t = this.query(v, build);
    return typeof t === 'string' && t.length ? ('?' + t) : t;
  };
  p.hash = function(v, build) {
    var t = this.fragment(v, build);
    return typeof t === 'string' && t.length ? ('#' + t) : t;
  };

  p.pathname = function(v, build) {
    if (v === undefined || v === true) {
      var res = this._parts.path || (this._parts.hostname ? '/' : '');
      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
    } else {
      if (this._parts.urn) {
        this._parts.path = v ? URI.recodeUrnPath(v) : '';
      } else {
        this._parts.path = v ? URI.recodePath(v) : '/';
      }
      this.build(!build);
      return this;
    }
  };
  p.path = p.pathname;
  p.href = function(href, build) {
    var key;

    if (href === undefined) {
      return this.toString();
    }

    this._string = '';
    this._parts = URI._parts();

    var _URI = href instanceof URI;
    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
    if (href.nodeName) {
      var attribute = URI.getDomAttribute(href);
      href = href[attribute] || '';
      _object = false;
    }

    // window.location is reported to be an object, but it's not the sort
    // of object we're looking for:
    // * location.protocol ends with a colon
    // * location.query != object.search
    // * location.hash != object.fragment
    // simply serializing the unknown object should do the trick
    // (for location, not for everything...)
    if (!_URI && _object && href.pathname !== undefined) {
      href = href.toString();
    }

    if (typeof href === 'string' || href instanceof String) {
      this._parts = URI.parse(String(href), this._parts);
    } else if (_URI || _object) {
      var src = _URI ? href._parts : href;
      for (key in src) {
        if (key === 'query') { continue; }
        if (hasOwn.call(this._parts, key)) {
          this._parts[key] = src[key];
        }
      }
      if (src.query) {
        this.query(src.query, false);
      }
    } else {
      throw new TypeError('invalid input');
    }

    this.build(!build);
    return this;
  };

  // identification accessors
  p.is = function(what) {
    var ip = false;
    var ip4 = false;
    var ip6 = false;
    var name = false;
    var sld = false;
    var idn = false;
    var punycode = false;
    var relative = !this._parts.urn;

    if (this._parts.hostname) {
      relative = false;
      ip4 = URI.ip4_expression.test(this._parts.hostname);
      ip6 = URI.ip6_expression.test(this._parts.hostname);
      ip = ip4 || ip6;
      name = !ip;
      sld = name && SLD && SLD.has(this._parts.hostname);
      idn = name && URI.idn_expression.test(this._parts.hostname);
      punycode = name && URI.punycode_expression.test(this._parts.hostname);
    }

    switch (what.toLowerCase()) {
      case 'relative':
        return relative;

      case 'absolute':
        return !relative;

      // hostname identification
      case 'domain':
      case 'name':
        return name;

      case 'sld':
        return sld;

      case 'ip':
        return ip;

      case 'ip4':
      case 'ipv4':
      case 'inet4':
        return ip4;

      case 'ip6':
      case 'ipv6':
      case 'inet6':
        return ip6;

      case 'idn':
        return idn;

      case 'url':
        return !this._parts.urn;

      case 'urn':
        return !!this._parts.urn;

      case 'punycode':
        return punycode;
    }

    return null;
  };

  // component specific input validation
  var _protocol = p.protocol;
  var _port = p.port;
  var _hostname = p.hostname;

  p.protocol = function(v, build) {
    if (v) {
      // accept trailing ://
      v = v.replace(/:(\/\/)?$/, '');

      if (!v.match(URI.protocol_expression)) {
        throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
      }
    }

    return _protocol.call(this, v, build);
  };
  p.scheme = p.protocol;
  p.port = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      if (v === 0) {
        v = null;
      }

      if (v) {
        v += '';
        if (v.charAt(0) === ':') {
          v = v.substring(1);
        }

        URI.ensureValidPort(v);
      }
    }
    return _port.call(this, v, build);
  };
  p.hostname = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
      var res = URI.parseHost(v, x);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      v = x.hostname;
      if (this._parts.preventInvalidHostname) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }
    }

    return _hostname.call(this, v, build);
  };

  // compound accessors
  p.origin = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var protocol = this.protocol();
      var authority = this.authority();
      if (!authority) {
        return '';
      }

      return (protocol ? protocol + '://' : '') + this.authority();
    } else {
      var origin = URI(v);
      this
        .protocol(origin.protocol())
        .authority(origin.authority())
        .build(!build);
      return this;
    }
  };
  p.host = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildHost(this._parts) : '';
    } else {
      var res = URI.parseHost(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.authority = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
    } else {
      var res = URI.parseAuthority(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.userinfo = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var t = URI.buildUserinfo(this._parts);
      return t ? t.substring(0, t.length -1) : t;
    } else {
      if (v[v.length-1] !== '@') {
        v += '@';
      }

      URI.parseUserinfo(v, this._parts);
      this.build(!build);
      return this;
    }
  };
  p.resource = function(v, build) {
    var parts;

    if (v === undefined) {
      return this.path() + this.search() + this.hash();
    }

    parts = URI.parse(v);
    this._parts.path = parts.path;
    this._parts.query = parts.query;
    this._parts.fragment = parts.fragment;
    this.build(!build);
    return this;
  };

  // fraction accessors
  p.subdomain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    // convenience, return "www" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // grab domain and add another segment
      var end = this._parts.hostname.length - this.domain().length - 1;
      return this._parts.hostname.substring(0, end) || '';
    } else {
      var e = this._parts.hostname.length - this.domain().length;
      var sub = this._parts.hostname.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(sub));

      if (v && v.charAt(v.length - 1) !== '.') {
        v += '.';
      }

      if (v.indexOf(':') !== -1) {
        throw new TypeError('Domains cannot contain colons');
      }

      if (v) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }

      this._parts.hostname = this._parts.hostname.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.domain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // convenience, return "example.org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // if hostname consists of 1 or 2 segments, it must be the domain
      var t = this._parts.hostname.match(/\./g);
      if (t && t.length < 2) {
        return this._parts.hostname;
      }

      // grab tld and add another segment
      var end = this._parts.hostname.length - this.tld(build).length - 1;
      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
      return this._parts.hostname.substring(end) || '';
    } else {
      if (!v) {
        throw new TypeError('cannot set domain empty');
      }

      if (v.indexOf(':') !== -1) {
        throw new TypeError('Domains cannot contain colons');
      }

      URI.ensureValidHostname(v, this._parts.protocol);

      if (!this._parts.hostname || this.is('IP')) {
        this._parts.hostname = v;
      } else {
        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.tld = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // return "org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      var pos = this._parts.hostname.lastIndexOf('.');
      var tld = this._parts.hostname.substring(pos + 1);

      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
        return SLD.get(this._parts.hostname) || tld;
      }

      return tld;
    } else {
      var replace;

      if (!v) {
        throw new TypeError('cannot set TLD empty');
      } else if (v.match(/[^a-zA-Z0-9-]/)) {
        if (SLD && SLD.is(v)) {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        } else {
          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
        }
      } else if (!this._parts.hostname || this.is('IP')) {
        throw new ReferenceError('cannot set TLD on non-domain host');
      } else {
        replace = new RegExp(escapeRegEx(this.tld()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.directory = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path && !this._parts.hostname) {
        return '';
      }

      if (this._parts.path === '/') {
        return '/';
      }

      var end = this._parts.path.length - this.filename().length - 1;
      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

      return v ? URI.decodePath(res) : res;

    } else {
      var e = this._parts.path.length - this.filename().length;
      var directory = this._parts.path.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(directory));

      // fully qualifier directories begin with a slash
      if (!this.is('relative')) {
        if (!v) {
          v = '/';
        }

        if (v.charAt(0) !== '/') {
          v = '/' + v;
        }
      }

      // directories always end with a slash
      if (v && v.charAt(v.length - 1) !== '/') {
        v += '/';
      }

      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.filename = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v !== 'string') {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var pos = this._parts.path.lastIndexOf('/');
      var res = this._parts.path.substring(pos+1);

      return v ? URI.decodePathSegment(res) : res;
    } else {
      var mutatedDirectory = false;

      if (v.charAt(0) === '/') {
        v = v.substring(1);
      }

      if (v.match(/\.?\//)) {
        mutatedDirectory = true;
      }

      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);

      if (mutatedDirectory) {
        this.normalizePath(build);
      } else {
        this.build(!build);
      }

      return this;
    }
  };
  p.suffix = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var filename = this.filename();
      var pos = filename.lastIndexOf('.');
      var s, res;

      if (pos === -1) {
        return '';
      }

      // suffix may only contain alnum characters (yup, I made this up.)
      s = filename.substring(pos+1);
      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
      return v ? URI.decodePathSegment(res) : res;
    } else {
      if (v.charAt(0) === '.') {
        v = v.substring(1);
      }

      var suffix = this.suffix();
      var replace;

      if (!suffix) {
        if (!v) {
          return this;
        }

        this._parts.path += '.' + URI.recodePath(v);
      } else if (!v) {
        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
      } else {
        replace = new RegExp(escapeRegEx(suffix) + '$');
      }

      if (replace) {
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.segment = function(segment, v, build) {
    var separator = this._parts.urn ? ':' : '/';
    var path = this.path();
    var absolute = path.substring(0, 1) === '/';
    var segments = path.split(separator);

    if (segment !== undefined && typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (segment !== undefined && typeof segment !== 'number') {
      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
    }

    if (absolute) {
      segments.shift();
    }

    if (segment < 0) {
      // allow negative indexes to address from the end
      segment = Math.max(segments.length + segment, 0);
    }

    if (v === undefined) {
      /*jshint laxbreak: true */
      return segment === undefined
        ? segments
        : segments[segment];
      /*jshint laxbreak: false */
    } else if (segment === null || segments[segment] === undefined) {
      if (isArray(v)) {
        segments = [];
        // collapse empty elements within array
        for (var i=0, l=v.length; i < l; i++) {
          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
            continue;
          }

          if (segments.length && !segments[segments.length -1].length) {
            segments.pop();
          }

          segments.push(trimSlashes(v[i]));
        }
      } else if (v || typeof v === 'string') {
        v = trimSlashes(v);
        if (segments[segments.length -1] === '') {
          // empty trailing elements have to be overwritten
          // to prevent results such as /foo//bar
          segments[segments.length -1] = v;
        } else {
          segments.push(v);
        }
      }
    } else {
      if (v) {
        segments[segment] = trimSlashes(v);
      } else {
        segments.splice(segment, 1);
      }
    }

    if (absolute) {
      segments.unshift('');
    }

    return this.path(segments.join(separator), build);
  };
  p.segmentCoded = function(segment, v, build) {
    var segments, i, l;

    if (typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (v === undefined) {
      segments = this.segment(segment, v, build);
      if (!isArray(segments)) {
        segments = segments !== undefined ? URI.decode(segments) : undefined;
      } else {
        for (i = 0, l = segments.length; i < l; i++) {
          segments[i] = URI.decode(segments[i]);
        }
      }

      return segments;
    }

    if (!isArray(v)) {
      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
    } else {
      for (i = 0, l = v.length; i < l; i++) {
        v[i] = URI.encode(v[i]);
      }
    }

    return this.segment(segment, v, build);
  };

  // mutating query string
  var q = p.query;
  p.query = function(v, build) {
    if (v === true) {
      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    } else if (typeof v === 'function') {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      var result = v.call(this, data);
      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else if (v !== undefined && typeof v !== 'string') {
      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else {
      return q.call(this, v, build);
    }
  };
  p.setQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

    if (typeof name === 'string' || name instanceof String) {
      data[name] = value !== undefined ? value : null;
    } else if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          data[key] = name[key];
        }
      }
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }

    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.addQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.addQuery(data, name, value === undefined ? null : value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.removeQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.removeQuery(data, name, value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.hasQuery = function(name, value, withinArray) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    return URI.hasQuery(data, name, value, withinArray);
  };
  p.setSearch = p.setQuery;
  p.addSearch = p.addQuery;
  p.removeSearch = p.removeQuery;
  p.hasSearch = p.hasQuery;

  // sanitizing URLs
  p.normalize = function() {
    if (this._parts.urn) {
      return this
        .normalizeProtocol(false)
        .normalizePath(false)
        .normalizeQuery(false)
        .normalizeFragment(false)
        .build();
    }

    return this
      .normalizeProtocol(false)
      .normalizeHostname(false)
      .normalizePort(false)
      .normalizePath(false)
      .normalizeQuery(false)
      .normalizeFragment(false)
      .build();
  };
  p.normalizeProtocol = function(build) {
    if (typeof this._parts.protocol === 'string') {
      this._parts.protocol = this._parts.protocol.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizeHostname = function(build) {
    if (this._parts.hostname) {
      if (this.is('IDN') && punycode) {
        this._parts.hostname = punycode.toASCII(this._parts.hostname);
      } else if (this.is('IPv6') && IPv6) {
        this._parts.hostname = IPv6.best(this._parts.hostname);
      }

      this._parts.hostname = this._parts.hostname.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizePort = function(build) {
    // remove port of it's the protocol's default
    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
      this._parts.port = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizePath = function(build) {
    var _path = this._parts.path;
    if (!_path) {
      return this;
    }

    if (this._parts.urn) {
      this._parts.path = URI.recodeUrnPath(this._parts.path);
      this.build(!build);
      return this;
    }

    if (this._parts.path === '/') {
      return this;
    }

    _path = URI.recodePath(_path);

    var _was_relative;
    var _leadingParents = '';
    var _parent, _pos;

    // handle relative paths
    if (_path.charAt(0) !== '/') {
      _was_relative = true;
      _path = '/' + _path;
    }

    // handle relative files (as opposed to directories)
    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
      _path += '/';
    }

    // resolve simples
    _path = _path
      .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
      .replace(/\/{2,}/g, '/');

    // remember leading parents
    if (_was_relative) {
      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
      if (_leadingParents) {
        _leadingParents = _leadingParents[0];
      }
    }

    // resolve parents
    while (true) {
      _parent = _path.search(/\/\.\.(\/|$)/);
      if (_parent === -1) {
        // no more ../ to resolve
        break;
      } else if (_parent === 0) {
        // top level cannot be relative, skip it
        _path = _path.substring(3);
        continue;
      }

      _pos = _path.substring(0, _parent).lastIndexOf('/');
      if (_pos === -1) {
        _pos = _parent;
      }
      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }

    // revert to relative
    if (_was_relative && this.is('relative')) {
      _path = _leadingParents + _path.substring(1);
    }

    this._parts.path = _path;
    this.build(!build);
    return this;
  };
  p.normalizePathname = p.normalizePath;
  p.normalizeQuery = function(build) {
    if (typeof this._parts.query === 'string') {
      if (!this._parts.query.length) {
        this._parts.query = null;
      } else {
        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
      }

      this.build(!build);
    }

    return this;
  };
  p.normalizeFragment = function(build) {
    if (!this._parts.fragment) {
      this._parts.fragment = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizeSearch = p.normalizeQuery;
  p.normalizeHash = p.normalizeFragment;

  p.iso8859 = function() {
    // expect unicode input, iso8859 output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = escape;
    URI.decode = decodeURIComponent;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.unicode = function() {
    // expect iso8859 input, unicode output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = strictEncodeURIComponent;
    URI.decode = unescape;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.readable = function() {
    var uri = this.clone();
    // removing username, password, because they shouldn't be displayed according to RFC 3986
    uri.username('').password('').normalize();
    var t = '';
    if (uri._parts.protocol) {
      t += uri._parts.protocol + '://';
    }

    if (uri._parts.hostname) {
      if (uri.is('punycode') && punycode) {
        t += punycode.toUnicode(uri._parts.hostname);
        if (uri._parts.port) {
          t += ':' + uri._parts.port;
        }
      } else {
        t += uri.host();
      }
    }

    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
      t += '/';
    }

    t += uri.path(true);
    if (uri._parts.query) {
      var q = '';
      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
        var kv = (qp[i] || '').split('=');
        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
          .replace(/&/g, '%26');

        if (kv[1] !== undefined) {
          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
            .replace(/&/g, '%26');
        }
      }
      t += '?' + q.substring(1);
    }

    t += URI.decodeQuery(uri.hash(), true);
    return t;
  };

  // resolving relative and absolute URLs
  p.absoluteTo = function(base) {
    var resolved = this.clone();
    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
    var basedir, i, p;

    if (this._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    if (!(base instanceof URI)) {
      base = new URI(base);
    }

    if (resolved._parts.protocol) {
      // Directly returns even if this._parts.hostname is empty.
      return resolved;
    } else {
      resolved._parts.protocol = base._parts.protocol;
    }

    if (this._parts.hostname) {
      return resolved;
    }

    for (i = 0; (p = properties[i]); i++) {
      resolved._parts[p] = base._parts[p];
    }

    if (!resolved._parts.path) {
      resolved._parts.path = base._parts.path;
      if (!resolved._parts.query) {
        resolved._parts.query = base._parts.query;
      }
    } else {
      if (resolved._parts.path.substring(-2) === '..') {
        resolved._parts.path += '/';
      }

      if (resolved.path().charAt(0) !== '/') {
        basedir = base.directory();
        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
        resolved.normalizePath();
      }
    }

    resolved.build();
    return resolved;
  };
  p.relativeTo = function(base) {
    var relative = this.clone().normalize();
    var relativeParts, baseParts, common, relativePath, basePath;

    if (relative._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    base = new URI(base).normalize();
    relativeParts = relative._parts;
    baseParts = base._parts;
    relativePath = relative.path();
    basePath = base.path();

    if (relativePath.charAt(0) !== '/') {
      throw new Error('URI is already relative');
    }

    if (basePath.charAt(0) !== '/') {
      throw new Error('Cannot calculate a URI relative to another relative URI');
    }

    if (relativeParts.protocol === baseParts.protocol) {
      relativeParts.protocol = null;
    }

    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
      return relative.build();
    }

    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
      return relative.build();
    }

    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
      relativeParts.hostname = null;
      relativeParts.port = null;
    } else {
      return relative.build();
    }

    if (relativePath === basePath) {
      relativeParts.path = '';
      return relative.build();
    }

    // determine common sub path
    common = URI.commonPath(relativePath, basePath);

    // If the paths have nothing in common, return a relative URL with the absolute path.
    if (!common) {
      return relative.build();
    }

    var parents = baseParts.path
      .substring(common.length)
      .replace(/[^\/]*$/, '')
      .replace(/.*?\//g, '../');

    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';

    return relative.build();
  };

  // comparing URIs
  p.equals = function(uri) {
    var one = this.clone();
    var two = new URI(uri);
    var one_map = {};
    var two_map = {};
    var checked = {};
    var one_query, two_query, key;

    one.normalize();
    two.normalize();

    // exact match
    if (one.toString() === two.toString()) {
      return true;
    }

    // extract query string
    one_query = one.query();
    two_query = two.query();
    one.query('');
    two.query('');

    // definitely not equal if not even non-query parts match
    if (one.toString() !== two.toString()) {
      return false;
    }

    // query parameters have the same length, even if they're permuted
    if (one_query.length !== two_query.length) {
      return false;
    }

    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

    for (key in one_map) {
      if (hasOwn.call(one_map, key)) {
        if (!isArray(one_map[key])) {
          if (one_map[key] !== two_map[key]) {
            return false;
          }
        } else if (!arraysEqual(one_map[key], two_map[key])) {
          return false;
        }

        checked[key] = true;
      }
    }

    for (key in two_map) {
      if (hasOwn.call(two_map, key)) {
        if (!checked[key]) {
          // two contains a parameter not present in one
          return false;
        }
      }
    }

    return true;
  };

  // state
  p.preventInvalidHostname = function(v) {
    this._parts.preventInvalidHostname = !!v;
    return this;
  };

  p.duplicateQueryParameters = function(v) {
    this._parts.duplicateQueryParameters = !!v;
    return this;
  };

  p.escapeQuerySpace = function(v) {
    this._parts.escapeQuerySpace = !!v;
    return this;
  };

  return URI;
}));


/***/ }),

/***/ 209:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = (__webpack_require__(861).Buffer)
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}


/***/ }),

/***/ 242:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Api: () => (/* binding */ Api)
/* harmony export */ });
var Api;

/***/ }),

/***/ 251:
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 287:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(526)
const ieee754 = __webpack_require__(251)
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ 293:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parser = __webpack_require__(546);
var compiler = __webpack_require__(708);

module.exports = {
  parse: function(input) {
    var nodes = parser.parse(input.toString());
    return compiler.compile(nodes);
  }
};


/***/ }),

/***/ 299:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AssembledTransaction: () => (/* reexport */ AssembledTransaction),
  Client: () => (/* reexport */ Client),
  DEFAULT_TIMEOUT: () => (/* reexport */ DEFAULT_TIMEOUT),
  Err: () => (/* reexport */ Err),
  NULL_ACCOUNT: () => (/* reexport */ NULL_ACCOUNT),
  Ok: () => (/* reexport */ Ok),
  SentTransaction: () => (/* reexport */ SentTransaction),
  Spec: () => (/* reexport */ Spec),
  Watcher: () => (/* reexport */ Watcher),
  basicNodeSigner: () => (/* reexport */ basicNodeSigner)
});

// EXTERNAL MODULE: ./node_modules/@stellar/stellar-base/dist/stellar-base.min.js
var stellar_base_min = __webpack_require__(950);
// EXTERNAL MODULE: ./src/rpc/index.ts + 3 modules
var rpc = __webpack_require__(496);
// EXTERNAL MODULE: ./src/rpc/api.ts
var api = __webpack_require__(76);
// EXTERNAL MODULE: ./src/rpc/transaction.ts
var transaction = __webpack_require__(680);
;// ./src/contract/rust_result.ts
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Ok = function () {
  function Ok(value) {
    _classCallCheck(this, Ok);
    this.value = value;
  }
  return _createClass(Ok, [{
    key: "unwrapErr",
    value: function unwrapErr() {
      throw new Error("No error");
    }
  }, {
    key: "unwrap",
    value: function unwrap() {
      return this.value;
    }
  }, {
    key: "isOk",
    value: function isOk() {
      return true;
    }
  }, {
    key: "isErr",
    value: function isErr() {
      return false;
    }
  }]);
}();
var Err = function () {
  function Err(error) {
    _classCallCheck(this, Err);
    this.error = error;
  }
  return _createClass(Err, [{
    key: "unwrapErr",
    value: function unwrapErr() {
      return this.error;
    }
  }, {
    key: "unwrap",
    value: function unwrap() {
      throw new Error(this.error.message);
    }
  }, {
    key: "isOk",
    value: function isOk() {
      return false;
    }
  }, {
    key: "isErr",
    value: function isErr() {
      return true;
    }
  }]);
}();
;// ./src/contract/types.ts

var DEFAULT_TIMEOUT = 5 * 60;
var NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
;// ./src/contract/utils.ts
/* provided dependency */ var Buffer = __webpack_require__(287)["Buffer"];
function _regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function utils_typeof(o) { "@babel/helpers - typeof"; return utils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, utils_typeof(o); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }


function withExponentialBackoff(_x, _x2, _x3) {
  return _withExponentialBackoff.apply(this, arguments);
}
function _withExponentialBackoff() {
  _withExponentialBackoff = _asyncToGenerator(_regenerator().m(function _callee(fn, keepWaitingIf, timeoutInSeconds) {
    var exponentialFactor,
      verbose,
      attempts,
      count,
      waitUntil,
      waitTime,
      totalWaitTime,
      _args = arguments,
      _t,
      _t2;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          exponentialFactor = _args.length > 3 && _args[3] !== undefined ? _args[3] : 1.5;
          verbose = _args.length > 4 && _args[4] !== undefined ? _args[4] : false;
          attempts = [];
          count = 0;
          _t = attempts;
          _context.n = 1;
          return fn();
        case 1:
          _t.push.call(_t, _context.v);
          if (keepWaitingIf(attempts[attempts.length - 1])) {
            _context.n = 2;
            break;
          }
          return _context.a(2, attempts);
        case 2:
          waitUntil = new Date(Date.now() + timeoutInSeconds * 1000).valueOf();
          waitTime = 1000;
          totalWaitTime = waitTime;
        case 3:
          if (!(Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1]))) {
            _context.n = 6;
            break;
          }
          count += 1;
          if (verbose) {
            console.info("Waiting ".concat(waitTime, "ms before trying again (bringing the total wait time to ").concat(totalWaitTime, "ms so far, of total ").concat(timeoutInSeconds * 1000, "ms)"));
          }
          _context.n = 4;
          return new Promise(function (res) {
            return setTimeout(res, waitTime);
          });
        case 4:
          waitTime *= exponentialFactor;
          if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {
            waitTime = waitUntil - Date.now();
            if (verbose) {
              console.info("was gonna wait too long; new waitTime: ".concat(waitTime, "ms"));
            }
          }
          totalWaitTime = waitTime + totalWaitTime;
          _t2 = attempts;
          _context.n = 5;
          return fn(attempts[attempts.length - 1]);
        case 5:
          _t2.push.call(_t2, _context.v);
          if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {
            console.info("".concat(count, ". Called ").concat(fn, "; ").concat(attempts.length, " prev attempts. Most recent: ").concat(JSON.stringify(attempts[attempts.length - 1], null, 2)));
          }
          _context.n = 3;
          break;
        case 6:
          return _context.a(2, attempts);
      }
    }, _callee);
  }));
  return _withExponentialBackoff.apply(this, arguments);
}
var contractErrorPattern = /Error\(Contract, #(\d+)\)/;
function implementsToString(obj) {
  return utils_typeof(obj) === "object" && obj !== null && "toString" in obj;
}
function specFromWasm(_x4) {
  return _specFromWasm.apply(this, arguments);
}
function _specFromWasm() {
  _specFromWasm = _asyncToGenerator(_regenerator().m(function _callee2(wasm) {
    var xdrSections, wasmModule, customData, _t3;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.p = _context2.n) {
        case 0:
          _context2.p = 0;
          _context2.n = 1;
          return WebAssembly.compile(wasm);
        case 1:
          wasmModule = _context2.v;
          xdrSections = WebAssembly.Module.customSections(wasmModule, "contractspecv0");
          _context2.n = 3;
          break;
        case 2:
          _context2.p = 2;
          _t3 = _context2.v;
          customData = parseWasmCustomSections(wasm);
          xdrSections = customData.get('contractspecv0');
        case 3:
          if (!(!xdrSections || xdrSections.length === 0)) {
            _context2.n = 4;
            break;
          }
          throw new Error("Could not obtain contract spec from wasm");
        case 4:
          return _context2.a(2, Buffer.from(xdrSections[0]));
      }
    }, _callee2, null, [[0, 2]]);
  }));
  return _specFromWasm.apply(this, arguments);
}
function parseWasmCustomSections(buffer) {
  var sections = new Map();
  var arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  var offset = 0;
  var read = function read(length) {
    if (offset + length > buffer.byteLength) throw new Error('Buffer overflow');
    var bytes = new Uint8Array(arrayBuffer, offset, length);
    offset += length;
    return bytes;
  };
  if (_toConsumableArray(read(4)).join() !== '0,97,115,109') throw new Error('Invalid WASM magic');
  if (_toConsumableArray(read(4)).join() !== '1,0,0,0') throw new Error('Invalid WASM version');
  while (offset < buffer.byteLength) {
    var sectionId = read(1)[0];
    var sectionLength = readVarUint32();
    var start = offset;
    if (sectionId === 0) {
      var nameLen = readVarUint32();
      if (nameLen === 0 || offset + nameLen > start + sectionLength) continue;
      var nameBytes = read(nameLen);
      var payload = read(sectionLength - (offset - start));
      try {
        var name = new TextDecoder('utf-8', {
          fatal: true
        }).decode(nameBytes);
        if (payload.length > 0) {
          sections.set(name, (sections.get(name) || []).concat(payload));
        }
      } catch (_unused) {}
    } else {
      offset += sectionLength;
    }
  }
  function readVarUint32() {
    var value = 0,
      shift = 0;
    while (true) {
      var byte = read(1)[0];
      value |= (byte & 0x7F) << shift;
      if ((byte & 0x80) === 0) break;
      if ((shift += 7) >= 32) throw new Error('Invalid WASM value');
    }
    return value >>> 0;
  }
  return sections;
}
function processSpecEntryStream(buffer) {
  var reader = new stellar_base_min.cereal.XdrReader(buffer);
  var res = [];
  while (!reader.eof) {
    res.push(stellar_base_min.xdr.ScSpecEntry.read(reader));
  }
  return res;
}
function getAccount(_x5, _x6) {
  return _getAccount.apply(this, arguments);
}
function _getAccount() {
  _getAccount = _asyncToGenerator(_regenerator().m(function _callee3(options, server) {
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          return _context3.a(2, options.publicKey ? server.getAccount(options.publicKey) : new stellar_base_min.Account(NULL_ACCOUNT, "0"));
      }
    }, _callee3);
  }));
  return _getAccount.apply(this, arguments);
}
;// ./src/contract/sent_transaction.ts
var _SentTransaction;
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == sent_transaction_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function sent_transaction_typeof(o) { "@babel/helpers - typeof"; return sent_transaction_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, sent_transaction_typeof(o); }
function sent_transaction_regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return sent_transaction_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (sent_transaction_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, sent_transaction_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, sent_transaction_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), sent_transaction_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", sent_transaction_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), sent_transaction_regeneratorDefine2(u), sent_transaction_regeneratorDefine2(u, o, "Generator"), sent_transaction_regeneratorDefine2(u, n, function () { return this; }), sent_transaction_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (sent_transaction_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function sent_transaction_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } sent_transaction_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { sent_transaction_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, sent_transaction_regeneratorDefine2(e, r, n, t); }
function sent_transaction_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function sent_transaction_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { sent_transaction_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { sent_transaction_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function sent_transaction_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function sent_transaction_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, sent_transaction_toPropertyKey(o.key), o); } }
function sent_transaction_createClass(e, r, t) { return r && sent_transaction_defineProperties(e.prototype, r), t && sent_transaction_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = sent_transaction_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function sent_transaction_toPropertyKey(t) { var i = sent_transaction_toPrimitive(t, "string"); return "symbol" == sent_transaction_typeof(i) ? i : i + ""; }
function sent_transaction_toPrimitive(t, r) { if ("object" != sent_transaction_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != sent_transaction_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var SentTransaction = function () {
  function SentTransaction(assembled) {
    var _this = this,
      _this$assembled$optio2;
    sent_transaction_classCallCheck(this, SentTransaction);
    _defineProperty(this, "send", function () {
      var _ref = sent_transaction_asyncToGenerator(sent_transaction_regenerator().m(function _callee2(watcher) {
        var _this$assembled$optio;
        var hash, timeoutInSeconds;
        return sent_transaction_regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return _this.server.sendTransaction(_this.assembled.signed);
            case 1:
              _this.sendTransactionResponse = _context2.v;
              if (!(_this.sendTransactionResponse.status !== "PENDING")) {
                _context2.n = 2;
                break;
              }
              throw new SentTransaction.Errors.SendFailed("Sending the transaction to the network failed!\n".concat(JSON.stringify(_this.sendTransactionResponse, null, 2)));
            case 2:
              if (watcher !== null && watcher !== void 0 && watcher.onSubmitted) watcher.onSubmitted(_this.sendTransactionResponse);
              hash = _this.sendTransactionResponse.hash;
              timeoutInSeconds = (_this$assembled$optio = _this.assembled.options.timeoutInSeconds) !== null && _this$assembled$optio !== void 0 ? _this$assembled$optio : DEFAULT_TIMEOUT;
              _context2.n = 3;
              return withExponentialBackoff(sent_transaction_asyncToGenerator(sent_transaction_regenerator().m(function _callee() {
                var tx;
                return sent_transaction_regenerator().w(function (_context) {
                  while (1) switch (_context.n) {
                    case 0:
                      _context.n = 1;
                      return _this.server.getTransaction(hash);
                    case 1:
                      tx = _context.v;
                      if (watcher !== null && watcher !== void 0 && watcher.onProgress) watcher.onProgress(tx);
                      return _context.a(2, tx);
                  }
                }, _callee);
              })), function (resp) {
                return resp.status === api/* Api */.j.GetTransactionStatus.NOT_FOUND;
              }, timeoutInSeconds);
            case 3:
              _this.getTransactionResponseAll = _context2.v;
              _this.getTransactionResponse = _this.getTransactionResponseAll[_this.getTransactionResponseAll.length - 1];
              if (!(_this.getTransactionResponse.status === api/* Api */.j.GetTransactionStatus.NOT_FOUND)) {
                _context2.n = 4;
                break;
              }
              throw new SentTransaction.Errors.TransactionStillPending("Waited ".concat(timeoutInSeconds, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(_this.sendTransactionResponse, null, 2), "\n") + "All attempts to get the result: ".concat(JSON.stringify(_this.getTransactionResponseAll, null, 2)));
            case 4:
              return _context2.a(2, _this);
          }
        }, _callee2);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    this.assembled = assembled;
    this.server = new rpc.Server(this.assembled.options.rpcUrl, {
      allowHttp: (_this$assembled$optio2 = this.assembled.options.allowHttp) !== null && _this$assembled$optio2 !== void 0 ? _this$assembled$optio2 : false
    });
  }
  return sent_transaction_createClass(SentTransaction, [{
    key: "result",
    get: function get() {
      if ("getTransactionResponse" in this && this.getTransactionResponse) {
        if ("returnValue" in this.getTransactionResponse) {
          return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
        }
        throw new Error("Transaction failed! Cannot parse result.");
      }
      if (this.sendTransactionResponse) {
        var _this$sendTransaction;
        var errorResult = (_this$sendTransaction = this.sendTransactionResponse.errorResult) === null || _this$sendTransaction === void 0 ? void 0 : _this$sendTransaction.result();
        if (errorResult) {
          throw new SentTransaction.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(errorResult));
        }
        throw new SentTransaction.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
      }
      throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
    }
  }]);
}();
_SentTransaction = SentTransaction;
_defineProperty(SentTransaction, "Errors", {
  SendFailed: function (_Error) {
    function SendFailedError() {
      sent_transaction_classCallCheck(this, SendFailedError);
      return _callSuper(this, SendFailedError, arguments);
    }
    _inherits(SendFailedError, _Error);
    return sent_transaction_createClass(SendFailedError);
  }(_wrapNativeSuper(Error)),
  SendResultOnly: function (_Error2) {
    function SendResultOnlyError() {
      sent_transaction_classCallCheck(this, SendResultOnlyError);
      return _callSuper(this, SendResultOnlyError, arguments);
    }
    _inherits(SendResultOnlyError, _Error2);
    return sent_transaction_createClass(SendResultOnlyError);
  }(_wrapNativeSuper(Error)),
  TransactionStillPending: function (_Error3) {
    function TransactionStillPendingError() {
      sent_transaction_classCallCheck(this, TransactionStillPendingError);
      return _callSuper(this, TransactionStillPendingError, arguments);
    }
    _inherits(TransactionStillPendingError, _Error3);
    return sent_transaction_createClass(TransactionStillPendingError);
  }(_wrapNativeSuper(Error))
});
_defineProperty(SentTransaction, "init", function () {
  var _ref3 = sent_transaction_asyncToGenerator(sent_transaction_regenerator().m(function _callee3(assembled, watcher) {
    var tx, sent;
    return sent_transaction_regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          tx = new _SentTransaction(assembled);
          _context3.n = 1;
          return tx.send(watcher);
        case 1:
          sent = _context3.v;
          return _context3.a(2, sent);
      }
    }, _callee3);
  }));
  return function (_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}());
var Watcher = sent_transaction_createClass(function Watcher() {
  sent_transaction_classCallCheck(this, Watcher);
});
;// ./src/contract/assembled_transaction.ts
/* provided dependency */ var assembled_transaction_Buffer = __webpack_require__(287)["Buffer"];
function assembled_transaction_callSuper(t, o, e) { return o = assembled_transaction_getPrototypeOf(o), assembled_transaction_possibleConstructorReturn(t, assembled_transaction_isNativeReflectConstruct() ? Reflect.construct(o, e || [], assembled_transaction_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function assembled_transaction_possibleConstructorReturn(t, e) { if (e && ("object" == assembled_transaction_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return assembled_transaction_assertThisInitialized(t); }
function assembled_transaction_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function assembled_transaction_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && assembled_transaction_setPrototypeOf(t, e); }
function assembled_transaction_wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return assembled_transaction_wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !assembled_transaction_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return assembled_transaction_construct(t, arguments, assembled_transaction_getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), assembled_transaction_setPrototypeOf(Wrapper, t); }, assembled_transaction_wrapNativeSuper(t); }
function assembled_transaction_construct(t, e, r) { if (assembled_transaction_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && assembled_transaction_setPrototypeOf(p, r.prototype), p; }
function assembled_transaction_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (assembled_transaction_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function assembled_transaction_isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function assembled_transaction_setPrototypeOf(t, e) { return assembled_transaction_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, assembled_transaction_setPrototypeOf(t, e); }
function assembled_transaction_getPrototypeOf(t) { return assembled_transaction_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, assembled_transaction_getPrototypeOf(t); }
function assembled_transaction_typeof(o) { "@babel/helpers - typeof"; return assembled_transaction_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, assembled_transaction_typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { assembled_transaction_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(assembled_transaction_typeof(e) + " is not iterable"); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || assembled_transaction_unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = assembled_transaction_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function assembled_transaction_regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return assembled_transaction_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (assembled_transaction_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, assembled_transaction_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, assembled_transaction_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), assembled_transaction_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", assembled_transaction_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), assembled_transaction_regeneratorDefine2(u), assembled_transaction_regeneratorDefine2(u, o, "Generator"), assembled_transaction_regeneratorDefine2(u, n, function () { return this; }), assembled_transaction_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (assembled_transaction_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function assembled_transaction_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } assembled_transaction_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { assembled_transaction_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, assembled_transaction_regeneratorDefine2(e, r, n, t); }
function assembled_transaction_toConsumableArray(r) { return assembled_transaction_arrayWithoutHoles(r) || assembled_transaction_iterableToArray(r) || assembled_transaction_unsupportedIterableToArray(r) || assembled_transaction_nonIterableSpread(); }
function assembled_transaction_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function assembled_transaction_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return assembled_transaction_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? assembled_transaction_arrayLikeToArray(r, a) : void 0; } }
function assembled_transaction_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function assembled_transaction_arrayWithoutHoles(r) { if (Array.isArray(r)) return assembled_transaction_arrayLikeToArray(r); }
function assembled_transaction_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function assembled_transaction_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function assembled_transaction_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { assembled_transaction_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { assembled_transaction_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function assembled_transaction_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function assembled_transaction_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, assembled_transaction_toPropertyKey(o.key), o); } }
function assembled_transaction_createClass(e, r, t) { return r && assembled_transaction_defineProperties(e.prototype, r), t && assembled_transaction_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function assembled_transaction_defineProperty(e, r, t) { return (r = assembled_transaction_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function assembled_transaction_toPropertyKey(t) { var i = assembled_transaction_toPrimitive(t, "string"); return "symbol" == assembled_transaction_typeof(i) ? i : i + ""; }
function assembled_transaction_toPrimitive(t, r) { if ("object" != assembled_transaction_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != assembled_transaction_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }








var AssembledTransaction = function () {
  function AssembledTransaction(options) {
    var _this = this,
      _this$options$simulat,
      _this$options$allowHt;
    assembled_transaction_classCallCheck(this, AssembledTransaction);
    assembled_transaction_defineProperty(this, "simulate", assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee() {
      var _ref2,
        restore,
        account,
        result,
        _this$options$fee,
        _this$options$args,
        _this$options$timeout,
        contract,
        _args = arguments;
      return assembled_transaction_regenerator().w(function (_context) {
        while (1) switch (_context.n) {
          case 0:
            _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, restore = _ref2.restore;
            if (_this.built) {
              _context.n = 2;
              break;
            }
            if (_this.raw) {
              _context.n = 1;
              break;
            }
            throw new Error("Transaction has not yet been assembled; " + "call `AssembledTransaction.build` first.");
          case 1:
            _this.built = _this.raw.build();
          case 2:
            restore = restore !== null && restore !== void 0 ? restore : _this.options.restore;
            delete _this.simulationResult;
            delete _this.simulationTransactionData;
            _context.n = 3;
            return _this.server.simulateTransaction(_this.built);
          case 3:
            _this.simulation = _context.v;
            if (!(restore && api/* Api */.j.isSimulationRestore(_this.simulation))) {
              _context.n = 8;
              break;
            }
            _context.n = 4;
            return getAccount(_this.options, _this.server);
          case 4:
            account = _context.v;
            _context.n = 5;
            return _this.restoreFootprint(_this.simulation.restorePreamble, account);
          case 5:
            result = _context.v;
            if (!(result.status === api/* Api */.j.GetTransactionStatus.SUCCESS)) {
              _context.n = 7;
              break;
            }
            contract = new stellar_base_min.Contract(_this.options.contractId);
            _this.raw = new stellar_base_min.TransactionBuilder(account, {
              fee: (_this$options$fee = _this.options.fee) !== null && _this$options$fee !== void 0 ? _this$options$fee : stellar_base_min.BASE_FEE,
              networkPassphrase: _this.options.networkPassphrase
            }).addOperation(contract.call.apply(contract, [_this.options.method].concat(assembled_transaction_toConsumableArray((_this$options$args = _this.options.args) !== null && _this$options$args !== void 0 ? _this$options$args : [])))).setTimeout((_this$options$timeout = _this.options.timeoutInSeconds) !== null && _this$options$timeout !== void 0 ? _this$options$timeout : DEFAULT_TIMEOUT);
            _context.n = 6;
            return _this.simulate();
          case 6:
            return _context.a(2, _this);
          case 7:
            throw new AssembledTransaction.Errors.RestorationFailure("Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:\n".concat(JSON.stringify(result)));
          case 8:
            if (api/* Api */.j.isSimulationSuccess(_this.simulation)) {
              _this.built = (0,transaction/* assembleTransaction */.X)(_this.built, _this.simulation).build();
            }
            return _context.a(2, _this);
        }
      }, _callee);
    })));
    assembled_transaction_defineProperty(this, "sign", assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee2() {
      var _this$options$timeout2;
      var _ref4,
        _ref4$force,
        force,
        _ref4$signTransaction,
        signTransaction,
        sigsNeeded,
        timeoutInSeconds,
        signOpts,
        _yield$signTransactio,
        signature,
        error,
        _args2 = arguments;
      return assembled_transaction_regenerator().w(function (_context2) {
        while (1) switch (_context2.n) {
          case 0:
            _ref4 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref4$force = _ref4.force, force = _ref4$force === void 0 ? false : _ref4$force, _ref4$signTransaction = _ref4.signTransaction, signTransaction = _ref4$signTransaction === void 0 ? _this.options.signTransaction : _ref4$signTransaction;
            if (_this.built) {
              _context2.n = 1;
              break;
            }
            throw new Error("Transaction has not yet been simulated");
          case 1:
            if (!(!force && _this.isReadCall)) {
              _context2.n = 2;
              break;
            }
            throw new AssembledTransaction.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. " + "Use `force: true` to sign and send anyway.");
          case 2:
            if (signTransaction) {
              _context2.n = 3;
              break;
            }
            throw new AssembledTransaction.Errors.NoSigner("You must provide a signTransaction function, either when calling " + "`signAndSend` or when initializing your Client");
          case 3:
            sigsNeeded = _this.needsNonInvokerSigningBy().filter(function (id) {
              return !id.startsWith("C");
            });
            if (!sigsNeeded.length) {
              _context2.n = 4;
              break;
            }
            throw new AssembledTransaction.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(sigsNeeded, ". ") + "See `needsNonInvokerSigningBy` for details.");
          case 4:
            timeoutInSeconds = (_this$options$timeout2 = _this.options.timeoutInSeconds) !== null && _this$options$timeout2 !== void 0 ? _this$options$timeout2 : DEFAULT_TIMEOUT;
            _this.built = stellar_base_min.TransactionBuilder.cloneFrom(_this.built, {
              fee: _this.built.fee,
              timebounds: undefined,
              sorobanData: _this.simulationData.transactionData
            }).setTimeout(timeoutInSeconds).build();
            signOpts = {
              networkPassphrase: _this.options.networkPassphrase
            };
            if (_this.options.address) signOpts.address = _this.options.address;
            if (_this.options.submit !== undefined) signOpts.submit = _this.options.submit;
            if (_this.options.submitUrl) signOpts.submitUrl = _this.options.submitUrl;
            _context2.n = 5;
            return signTransaction(_this.built.toXDR(), signOpts);
          case 5:
            _yield$signTransactio = _context2.v;
            signature = _yield$signTransactio.signedTxXdr;
            error = _yield$signTransactio.error;
            _this.handleWalletError(error);
            _this.signed = stellar_base_min.TransactionBuilder.fromXDR(signature, _this.options.networkPassphrase);
          case 6:
            return _context2.a(2);
        }
      }, _callee2);
    })));
    assembled_transaction_defineProperty(this, "signAndSend", assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee3() {
      var _ref6,
        _ref6$force,
        force,
        _ref6$signTransaction,
        signTransaction,
        watcher,
        originalSubmit,
        _args3 = arguments;
      return assembled_transaction_regenerator().w(function (_context3) {
        while (1) switch (_context3.p = _context3.n) {
          case 0:
            _ref6 = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {}, _ref6$force = _ref6.force, force = _ref6$force === void 0 ? false : _ref6$force, _ref6$signTransaction = _ref6.signTransaction, signTransaction = _ref6$signTransaction === void 0 ? _this.options.signTransaction : _ref6$signTransaction, watcher = _ref6.watcher;
            if (_this.signed) {
              _context3.n = 3;
              break;
            }
            originalSubmit = _this.options.submit;
            if (_this.options.submit) {
              _this.options.submit = false;
            }
            _context3.p = 1;
            _context3.n = 2;
            return _this.sign({
              force: force,
              signTransaction: signTransaction
            });
          case 2:
            _context3.p = 2;
            _this.options.submit = originalSubmit;
            return _context3.f(2);
          case 3:
            return _context3.a(2, _this.send(watcher));
        }
      }, _callee3, null, [[1,, 2, 3]]);
    })));
    assembled_transaction_defineProperty(this, "needsNonInvokerSigningBy", function () {
      var _rawInvokeHostFunctio;
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref7$includeAlreadyS = _ref7.includeAlreadySigned,
        includeAlreadySigned = _ref7$includeAlreadyS === void 0 ? false : _ref7$includeAlreadyS;
      if (!_this.built) {
        throw new Error("Transaction has not yet been simulated");
      }
      if (!("operations" in _this.built)) {
        throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(_this.built)));
      }
      var rawInvokeHostFunctionOp = _this.built.operations[0];
      return assembled_transaction_toConsumableArray(new Set(((_rawInvokeHostFunctio = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio !== void 0 ? _rawInvokeHostFunctio : []).filter(function (entry) {
        return entry.credentials().switch() === stellar_base_min.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === "scvVoid");
      }).map(function (entry) {
        return stellar_base_min.Address.fromScAddress(entry.credentials().address().address()).toString();
      })));
    });
    assembled_transaction_defineProperty(this, "signAuthEntries", assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee6() {
      var _rawInvokeHostFunctio2;
      var _ref9,
        _ref9$expiration,
        expiration,
        _ref9$signAuthEntry,
        signAuthEntry,
        _ref9$address,
        address,
        _ref9$authorizeEntry,
        authorizeEntry,
        needsNonInvokerSigningBy,
        rawInvokeHostFunctionOp,
        authEntries,
        _iterator,
        _step,
        _loop,
        _ret,
        _args7 = arguments,
        _t5;
      return assembled_transaction_regenerator().w(function (_context7) {
        while (1) switch (_context7.p = _context7.n) {
          case 0:
            _ref9 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, _ref9$expiration = _ref9.expiration, expiration = _ref9$expiration === void 0 ? assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee4() {
              var _t;
              return assembled_transaction_regenerator().w(function (_context4) {
                while (1) switch (_context4.n) {
                  case 0:
                    _context4.n = 1;
                    return _this.server.getLatestLedger();
                  case 1:
                    _t = _context4.v.sequence;
                    return _context4.a(2, _t + 100);
                }
              }, _callee4);
            }))() : _ref9$expiration, _ref9$signAuthEntry = _ref9.signAuthEntry, signAuthEntry = _ref9$signAuthEntry === void 0 ? _this.options.signAuthEntry : _ref9$signAuthEntry, _ref9$address = _ref9.address, address = _ref9$address === void 0 ? _this.options.publicKey : _ref9$address, _ref9$authorizeEntry = _ref9.authorizeEntry, authorizeEntry = _ref9$authorizeEntry === void 0 ? stellar_base_min.authorizeEntry : _ref9$authorizeEntry;
            if (_this.built) {
              _context7.n = 1;
              break;
            }
            throw new Error("Transaction has not yet been assembled or simulated");
          case 1:
            if (!(authorizeEntry === stellar_base_min.authorizeEntry)) {
              _context7.n = 4;
              break;
            }
            needsNonInvokerSigningBy = _this.needsNonInvokerSigningBy();
            if (!(needsNonInvokerSigningBy.length === 0)) {
              _context7.n = 2;
              break;
            }
            throw new AssembledTransaction.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
          case 2:
            if (!(needsNonInvokerSigningBy.indexOf(address !== null && address !== void 0 ? address : "") === -1)) {
              _context7.n = 3;
              break;
            }
            throw new AssembledTransaction.Errors.NoSignatureNeeded("No auth entries for public key \"".concat(address, "\""));
          case 3:
            if (signAuthEntry) {
              _context7.n = 4;
              break;
            }
            throw new AssembledTransaction.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
          case 4:
            rawInvokeHostFunctionOp = _this.built.operations[0];
            authEntries = (_rawInvokeHostFunctio2 = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio2 !== void 0 ? _rawInvokeHostFunctio2 : [];
            _iterator = _createForOfIteratorHelper(authEntries.entries());
            _context7.p = 5;
            _loop = assembled_transaction_regenerator().m(function _loop() {
              var _step$value, i, entry, credentials, authEntryAddress, sign, _t2, _t3, _t4;
              return assembled_transaction_regenerator().w(function (_context6) {
                while (1) switch (_context6.n) {
                  case 0:
                    _step$value = _slicedToArray(_step.value, 2), i = _step$value[0], entry = _step$value[1];
                    credentials = stellar_base_min.xdr.SorobanCredentials.fromXDR(entry.credentials().toXDR());
                    if (!(credentials.switch() !== stellar_base_min.xdr.SorobanCredentialsType.sorobanCredentialsAddress())) {
                      _context6.n = 1;
                      break;
                    }
                    return _context6.a(2, 0);
                  case 1:
                    authEntryAddress = stellar_base_min.Address.fromScAddress(credentials.address().address()).toString();
                    if (!(authEntryAddress !== address)) {
                      _context6.n = 2;
                      break;
                    }
                    return _context6.a(2, 0);
                  case 2:
                    sign = signAuthEntry !== null && signAuthEntry !== void 0 ? signAuthEntry : Promise.resolve;
                    _t2 = authorizeEntry;
                    _t3 = entry;
                    _t4 = function () {
                      var _ref1 = assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee5(preimage) {
                        var _yield$sign, signedAuthEntry, error;
                        return assembled_transaction_regenerator().w(function (_context5) {
                          while (1) switch (_context5.n) {
                            case 0:
                              _context5.n = 1;
                              return sign(preimage.toXDR("base64"), {
                                address: address
                              });
                            case 1:
                              _yield$sign = _context5.v;
                              signedAuthEntry = _yield$sign.signedAuthEntry;
                              error = _yield$sign.error;
                              _this.handleWalletError(error);
                              return _context5.a(2, assembled_transaction_Buffer.from(signedAuthEntry, "base64"));
                          }
                        }, _callee5);
                      }));
                      return function (_x) {
                        return _ref1.apply(this, arguments);
                      };
                    }();
                    _context6.n = 3;
                    return expiration;
                  case 3:
                    _context6.n = 4;
                    return _t2(_t3, _t4, _context6.v, _this.options.networkPassphrase);
                  case 4:
                    authEntries[i] = _context6.v;
                  case 5:
                    return _context6.a(2);
                }
              }, _loop);
            });
            _iterator.s();
          case 6:
            if ((_step = _iterator.n()).done) {
              _context7.n = 9;
              break;
            }
            return _context7.d(_regeneratorValues(_loop()), 7);
          case 7:
            _ret = _context7.v;
            if (!(_ret === 0)) {
              _context7.n = 8;
              break;
            }
            return _context7.a(3, 8);
          case 8:
            _context7.n = 6;
            break;
          case 9:
            _context7.n = 11;
            break;
          case 10:
            _context7.p = 10;
            _t5 = _context7.v;
            _iterator.e(_t5);
          case 11:
            _context7.p = 11;
            _iterator.f();
            return _context7.f(11);
          case 12:
            return _context7.a(2);
        }
      }, _callee6, null, [[5, 10, 11, 12]]);
    })));
    this.options = options;
    this.options.simulate = (_this$options$simulat = this.options.simulate) !== null && _this$options$simulat !== void 0 ? _this$options$simulat : true;
    this.server = new rpc.Server(this.options.rpcUrl, {
      allowHttp: (_this$options$allowHt = this.options.allowHttp) !== null && _this$options$allowHt !== void 0 ? _this$options$allowHt : false
    });
  }
  return assembled_transaction_createClass(AssembledTransaction, [{
    key: "toJSON",
    value: function toJSON() {
      var _this$built;
      return JSON.stringify({
        method: this.options.method,
        tx: (_this$built = this.built) === null || _this$built === void 0 ? void 0 : _this$built.toXDR(),
        simulationResult: {
          auth: this.simulationData.result.auth.map(function (a) {
            return a.toXDR("base64");
          }),
          retval: this.simulationData.result.retval.toXDR("base64")
        },
        simulationTransactionData: this.simulationData.transactionData.toXDR("base64")
      });
    }
  }, {
    key: "toXDR",
    value: function toXDR() {
      var _this$built2;
      if (!this.built) throw new Error("Transaction has not yet been simulated; " + "call `AssembledTransaction.simulate` first.");
      return (_this$built2 = this.built) === null || _this$built2 === void 0 ? void 0 : _this$built2.toEnvelope().toXDR("base64");
    }
  }, {
    key: "handleWalletError",
    value: function handleWalletError(error) {
      if (!error) return;
      var message = error.message,
        code = error.code;
      var fullMessage = "".concat(message).concat(error.ext ? " (".concat(error.ext.join(", "), ")") : "");
      switch (code) {
        case -1:
          throw new AssembledTransaction.Errors.InternalWalletError(fullMessage);
        case -2:
          throw new AssembledTransaction.Errors.ExternalServiceError(fullMessage);
        case -3:
          throw new AssembledTransaction.Errors.InvalidClientRequest(fullMessage);
        case -4:
          throw new AssembledTransaction.Errors.UserRejected(fullMessage);
        default:
          throw new Error("Unhandled error: ".concat(fullMessage));
      }
    }
  }, {
    key: "simulationData",
    get: function get() {
      var _simulation$result;
      if (this.simulationResult && this.simulationTransactionData) {
        return {
          result: this.simulationResult,
          transactionData: this.simulationTransactionData
        };
      }
      var simulation = this.simulation;
      if (!simulation) {
        throw new AssembledTransaction.Errors.NotYetSimulated("Transaction has not yet been simulated");
      }
      if (api/* Api */.j.isSimulationError(simulation)) {
        throw new AssembledTransaction.Errors.SimulationFailed("Transaction simulation failed: \"".concat(simulation.error, "\""));
      }
      if (api/* Api */.j.isSimulationRestore(simulation)) {
        throw new AssembledTransaction.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\n" + "You can set `restore` to true in the method options in order to " + "automatically restore the contract state when needed.");
      }
      this.simulationResult = (_simulation$result = simulation.result) !== null && _simulation$result !== void 0 ? _simulation$result : {
        auth: [],
        retval: stellar_base_min.xdr.ScVal.scvVoid()
      };
      this.simulationTransactionData = simulation.transactionData.build();
      return {
        result: this.simulationResult,
        transactionData: this.simulationTransactionData
      };
    }
  }, {
    key: "result",
    get: function get() {
      try {
        if (!this.simulationData.result) {
          throw new Error("No simulation result!");
        }
        return this.options.parseResultXdr(this.simulationData.result.retval);
      } catch (e) {
        if (!implementsToString(e)) throw e;
        var err = this.parseError(e.toString());
        if (err) return err;
        throw e;
      }
    }
  }, {
    key: "parseError",
    value: function parseError(errorMessage) {
      if (!this.options.errorTypes) return undefined;
      var match = errorMessage.match(contractErrorPattern);
      if (!match) return undefined;
      var i = parseInt(match[1], 10);
      var err = this.options.errorTypes[i];
      if (!err) return undefined;
      return new Err(err);
    }
  }, {
    key: "send",
    value: (function () {
      var _send = assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee7(watcher) {
        var sent;
        return assembled_transaction_regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              if (this.signed) {
                _context8.n = 1;
                break;
              }
              throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
            case 1:
              _context8.n = 2;
              return SentTransaction.init(this, watcher);
            case 2:
              sent = _context8.v;
              return _context8.a(2, sent);
          }
        }, _callee7, this);
      }));
      function send(_x2) {
        return _send.apply(this, arguments);
      }
      return send;
    }())
  }, {
    key: "isReadCall",
    get: function get() {
      var authsCount = this.simulationData.result.auth.length;
      var writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;
      return authsCount === 0 && writeLength === 0;
    }
  }, {
    key: "restoreFootprint",
    value: (function () {
      var _restoreFootprint = assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee8(restorePreamble, account) {
        var restoreTx, sentTransaction, _t6;
        return assembled_transaction_regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              if (this.options.signTransaction) {
                _context9.n = 1;
                break;
              }
              throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
            case 1:
              if (!(account !== null && account !== void 0)) {
                _context9.n = 2;
                break;
              }
              _t6 = account;
              _context9.n = 4;
              break;
            case 2:
              _context9.n = 3;
              return getAccount(this.options, this.server);
            case 3:
              _t6 = _context9.v;
            case 4:
              account = _t6;
              _context9.n = 5;
              return AssembledTransaction.buildFootprintRestoreTransaction(_objectSpread({}, this.options), restorePreamble.transactionData, account, restorePreamble.minResourceFee);
            case 5:
              restoreTx = _context9.v;
              _context9.n = 6;
              return restoreTx.signAndSend();
            case 6:
              sentTransaction = _context9.v;
              if (sentTransaction.getTransactionResponse) {
                _context9.n = 7;
                break;
              }
              throw new AssembledTransaction.Errors.RestorationFailure("The attempt at automatic restore failed. \n".concat(JSON.stringify(sentTransaction)));
            case 7:
              return _context9.a(2, sentTransaction.getTransactionResponse);
          }
        }, _callee8, this);
      }));
      function restoreFootprint(_x3, _x4) {
        return _restoreFootprint.apply(this, arguments);
      }
      return restoreFootprint;
    }())
  }], [{
    key: "fromJSON",
    value: function fromJSON(options, _ref10) {
      var tx = _ref10.tx,
        simulationResult = _ref10.simulationResult,
        simulationTransactionData = _ref10.simulationTransactionData;
      var txn = new AssembledTransaction(options);
      txn.built = stellar_base_min.TransactionBuilder.fromXDR(tx, options.networkPassphrase);
      txn.simulationResult = {
        auth: simulationResult.auth.map(function (a) {
          return stellar_base_min.xdr.SorobanAuthorizationEntry.fromXDR(a, "base64");
        }),
        retval: stellar_base_min.xdr.ScVal.fromXDR(simulationResult.retval, "base64")
      };
      txn.simulationTransactionData = stellar_base_min.xdr.SorobanTransactionData.fromXDR(simulationTransactionData, "base64");
      return txn;
    }
  }, {
    key: "fromXDR",
    value: function fromXDR(options, encodedXDR, spec) {
      var _operation$func;
      var envelope = stellar_base_min.xdr.TransactionEnvelope.fromXDR(encodedXDR, "base64");
      var built = stellar_base_min.TransactionBuilder.fromXDR(envelope, options.networkPassphrase);
      var operation = built.operations[0];
      if (!(operation !== null && operation !== void 0 && (_operation$func = operation.func) !== null && _operation$func !== void 0 && _operation$func.value) || typeof operation.func.value !== "function") {
        throw new Error("Could not extract the method from the transaction envelope.");
      }
      var invokeContractArgs = operation.func.value();
      if (!(invokeContractArgs !== null && invokeContractArgs !== void 0 && invokeContractArgs.functionName)) {
        throw new Error("Could not extract the method name from the transaction envelope.");
      }
      var method = invokeContractArgs.functionName().toString("utf-8");
      var txn = new AssembledTransaction(_objectSpread(_objectSpread({}, options), {}, {
        method: method,
        parseResultXdr: function parseResultXdr(result) {
          return spec.funcResToNative(method, result);
        }
      }));
      txn.built = built;
      return txn;
    }
  }, {
    key: "build",
    value: function build(options) {
      var _options$args;
      var contract = new stellar_base_min.Contract(options.contractId);
      return AssembledTransaction.buildWithOp(contract.call.apply(contract, [options.method].concat(assembled_transaction_toConsumableArray((_options$args = options.args) !== null && _options$args !== void 0 ? _options$args : []))), options);
    }
  }, {
    key: "buildWithOp",
    value: (function () {
      var _buildWithOp = assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee9(operation, options) {
        var _options$fee, _options$timeoutInSec;
        var tx, account;
        return assembled_transaction_regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              tx = new AssembledTransaction(options);
              _context0.n = 1;
              return getAccount(options, tx.server);
            case 1:
              account = _context0.v;
              tx.raw = new stellar_base_min.TransactionBuilder(account, {
                fee: (_options$fee = options.fee) !== null && _options$fee !== void 0 ? _options$fee : stellar_base_min.BASE_FEE,
                networkPassphrase: options.networkPassphrase
              }).setTimeout((_options$timeoutInSec = options.timeoutInSeconds) !== null && _options$timeoutInSec !== void 0 ? _options$timeoutInSec : DEFAULT_TIMEOUT).addOperation(operation);
              if (!options.simulate) {
                _context0.n = 2;
                break;
              }
              _context0.n = 2;
              return tx.simulate();
            case 2:
              return _context0.a(2, tx);
          }
        }, _callee9);
      }));
      function buildWithOp(_x5, _x6) {
        return _buildWithOp.apply(this, arguments);
      }
      return buildWithOp;
    }())
  }, {
    key: "buildFootprintRestoreTransaction",
    value: function () {
      var _buildFootprintRestoreTransaction = assembled_transaction_asyncToGenerator(assembled_transaction_regenerator().m(function _callee0(options, sorobanData, account, fee) {
        var _options$timeoutInSec2;
        var tx;
        return assembled_transaction_regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              tx = new AssembledTransaction(options);
              tx.raw = new stellar_base_min.TransactionBuilder(account, {
                fee: fee,
                networkPassphrase: options.networkPassphrase
              }).setSorobanData(sorobanData instanceof stellar_base_min.SorobanDataBuilder ? sorobanData.build() : sorobanData).addOperation(stellar_base_min.Operation.restoreFootprint({})).setTimeout((_options$timeoutInSec2 = options.timeoutInSeconds) !== null && _options$timeoutInSec2 !== void 0 ? _options$timeoutInSec2 : DEFAULT_TIMEOUT);
              _context1.n = 1;
              return tx.simulate({
                restore: false
              });
            case 1:
              return _context1.a(2, tx);
          }
        }, _callee0);
      }));
      function buildFootprintRestoreTransaction(_x7, _x8, _x9, _x0) {
        return _buildFootprintRestoreTransaction.apply(this, arguments);
      }
      return buildFootprintRestoreTransaction;
    }()
  }]);
}();
assembled_transaction_defineProperty(AssembledTransaction, "Errors", {
  ExpiredState: function (_Error) {
    function ExpiredStateError() {
      assembled_transaction_classCallCheck(this, ExpiredStateError);
      return assembled_transaction_callSuper(this, ExpiredStateError, arguments);
    }
    assembled_transaction_inherits(ExpiredStateError, _Error);
    return assembled_transaction_createClass(ExpiredStateError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  RestorationFailure: function (_Error2) {
    function RestoreFailureError() {
      assembled_transaction_classCallCheck(this, RestoreFailureError);
      return assembled_transaction_callSuper(this, RestoreFailureError, arguments);
    }
    assembled_transaction_inherits(RestoreFailureError, _Error2);
    return assembled_transaction_createClass(RestoreFailureError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  NeedsMoreSignatures: function (_Error3) {
    function NeedsMoreSignaturesError() {
      assembled_transaction_classCallCheck(this, NeedsMoreSignaturesError);
      return assembled_transaction_callSuper(this, NeedsMoreSignaturesError, arguments);
    }
    assembled_transaction_inherits(NeedsMoreSignaturesError, _Error3);
    return assembled_transaction_createClass(NeedsMoreSignaturesError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  NoSignatureNeeded: function (_Error4) {
    function NoSignatureNeededError() {
      assembled_transaction_classCallCheck(this, NoSignatureNeededError);
      return assembled_transaction_callSuper(this, NoSignatureNeededError, arguments);
    }
    assembled_transaction_inherits(NoSignatureNeededError, _Error4);
    return assembled_transaction_createClass(NoSignatureNeededError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  NoUnsignedNonInvokerAuthEntries: function (_Error5) {
    function NoUnsignedNonInvokerAuthEntriesError() {
      assembled_transaction_classCallCheck(this, NoUnsignedNonInvokerAuthEntriesError);
      return assembled_transaction_callSuper(this, NoUnsignedNonInvokerAuthEntriesError, arguments);
    }
    assembled_transaction_inherits(NoUnsignedNonInvokerAuthEntriesError, _Error5);
    return assembled_transaction_createClass(NoUnsignedNonInvokerAuthEntriesError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  NoSigner: function (_Error6) {
    function NoSignerError() {
      assembled_transaction_classCallCheck(this, NoSignerError);
      return assembled_transaction_callSuper(this, NoSignerError, arguments);
    }
    assembled_transaction_inherits(NoSignerError, _Error6);
    return assembled_transaction_createClass(NoSignerError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  NotYetSimulated: function (_Error7) {
    function NotYetSimulatedError() {
      assembled_transaction_classCallCheck(this, NotYetSimulatedError);
      return assembled_transaction_callSuper(this, NotYetSimulatedError, arguments);
    }
    assembled_transaction_inherits(NotYetSimulatedError, _Error7);
    return assembled_transaction_createClass(NotYetSimulatedError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  FakeAccount: function (_Error8) {
    function FakeAccountError() {
      assembled_transaction_classCallCheck(this, FakeAccountError);
      return assembled_transaction_callSuper(this, FakeAccountError, arguments);
    }
    assembled_transaction_inherits(FakeAccountError, _Error8);
    return assembled_transaction_createClass(FakeAccountError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  SimulationFailed: function (_Error9) {
    function SimulationFailedError() {
      assembled_transaction_classCallCheck(this, SimulationFailedError);
      return assembled_transaction_callSuper(this, SimulationFailedError, arguments);
    }
    assembled_transaction_inherits(SimulationFailedError, _Error9);
    return assembled_transaction_createClass(SimulationFailedError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  InternalWalletError: function (_Error0) {
    function InternalWalletError() {
      assembled_transaction_classCallCheck(this, InternalWalletError);
      return assembled_transaction_callSuper(this, InternalWalletError, arguments);
    }
    assembled_transaction_inherits(InternalWalletError, _Error0);
    return assembled_transaction_createClass(InternalWalletError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  ExternalServiceError: function (_Error1) {
    function ExternalServiceError() {
      assembled_transaction_classCallCheck(this, ExternalServiceError);
      return assembled_transaction_callSuper(this, ExternalServiceError, arguments);
    }
    assembled_transaction_inherits(ExternalServiceError, _Error1);
    return assembled_transaction_createClass(ExternalServiceError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  InvalidClientRequest: function (_Error10) {
    function InvalidClientRequestError() {
      assembled_transaction_classCallCheck(this, InvalidClientRequestError);
      return assembled_transaction_callSuper(this, InvalidClientRequestError, arguments);
    }
    assembled_transaction_inherits(InvalidClientRequestError, _Error10);
    return assembled_transaction_createClass(InvalidClientRequestError);
  }(assembled_transaction_wrapNativeSuper(Error)),
  UserRejected: function (_Error11) {
    function UserRejectedError() {
      assembled_transaction_classCallCheck(this, UserRejectedError);
      return assembled_transaction_callSuper(this, UserRejectedError, arguments);
    }
    assembled_transaction_inherits(UserRejectedError, _Error11);
    return assembled_transaction_createClass(UserRejectedError);
  }(assembled_transaction_wrapNativeSuper(Error))
});
;// ./src/contract/basic_node_signer.ts
/* provided dependency */ var basic_node_signer_Buffer = __webpack_require__(287)["Buffer"];
function basic_node_signer_regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return basic_node_signer_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (basic_node_signer_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, basic_node_signer_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, basic_node_signer_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), basic_node_signer_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", basic_node_signer_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), basic_node_signer_regeneratorDefine2(u), basic_node_signer_regeneratorDefine2(u, o, "Generator"), basic_node_signer_regeneratorDefine2(u, n, function () { return this; }), basic_node_signer_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (basic_node_signer_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function basic_node_signer_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } basic_node_signer_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { basic_node_signer_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, basic_node_signer_regeneratorDefine2(e, r, n, t); }
function basic_node_signer_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function basic_node_signer_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { basic_node_signer_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { basic_node_signer_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }

var basicNodeSigner = function basicNodeSigner(keypair, networkPassphrase) {
  return {
    signTransaction: function () {
      var _signTransaction = basic_node_signer_asyncToGenerator(basic_node_signer_regenerator().m(function _callee(xdr, opts) {
        var t;
        return basic_node_signer_regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              t = stellar_base_min.TransactionBuilder.fromXDR(xdr, (opts === null || opts === void 0 ? void 0 : opts.networkPassphrase) || networkPassphrase);
              t.sign(keypair);
              return _context.a(2, {
                signedTxXdr: t.toXDR(),
                signerAddress: keypair.publicKey()
              });
          }
        }, _callee);
      }));
      function signTransaction(_x, _x2) {
        return _signTransaction.apply(this, arguments);
      }
      return signTransaction;
    }(),
    signAuthEntry: function () {
      var _signAuthEntry = basic_node_signer_asyncToGenerator(basic_node_signer_regenerator().m(function _callee2(authEntry) {
        var signedAuthEntry;
        return basic_node_signer_regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              signedAuthEntry = keypair.sign((0,stellar_base_min.hash)(basic_node_signer_Buffer.from(authEntry, "base64"))).toString("base64");
              return _context2.a(2, {
                signedAuthEntry: signedAuthEntry,
                signerAddress: keypair.publicKey()
              });
          }
        }, _callee2);
      }));
      function signAuthEntry(_x3) {
        return _signAuthEntry.apply(this, arguments);
      }
      return signAuthEntry;
    }()
  };
};
;// ./src/contract/spec.ts
/* provided dependency */ var spec_Buffer = __webpack_require__(287)["Buffer"];
function spec_regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return spec_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (spec_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, spec_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, spec_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), spec_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", spec_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), spec_regeneratorDefine2(u), spec_regeneratorDefine2(u, o, "Generator"), spec_regeneratorDefine2(u, n, function () { return this; }), spec_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (spec_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function spec_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } spec_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { spec_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, spec_regeneratorDefine2(e, r, n, t); }
function spec_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function spec_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { spec_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { spec_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function spec_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function spec_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? spec_ownKeys(Object(t), !0).forEach(function (r) { spec_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : spec_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function spec_typeof(o) { "@babel/helpers - typeof"; return spec_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, spec_typeof(o); }
function spec_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function spec_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, spec_toPropertyKey(o.key), o); } }
function spec_createClass(e, r, t) { return r && spec_defineProperties(e.prototype, r), t && spec_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function spec_defineProperty(e, r, t) { return (r = spec_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function spec_toPropertyKey(t) { var i = spec_toPrimitive(t, "string"); return "symbol" == spec_typeof(i) ? i : i + ""; }
function spec_toPrimitive(t, r) { if ("object" != spec_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != spec_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function spec_slicedToArray(r, e) { return spec_arrayWithHoles(r) || spec_iterableToArrayLimit(r, e) || spec_unsupportedIterableToArray(r, e) || spec_nonIterableRest(); }
function spec_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function spec_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return spec_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? spec_arrayLikeToArray(r, a) : void 0; } }
function spec_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function spec_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function spec_arrayWithHoles(r) { if (Array.isArray(r)) return r; }



function enumToJsonSchema(udt) {
  var description = udt.doc().toString();
  var cases = udt.cases();
  var oneOf = [];
  cases.forEach(function (aCase) {
    var title = aCase.name().toString();
    var desc = aCase.doc().toString();
    oneOf.push({
      description: desc,
      title: title,
      enum: [aCase.value()],
      type: "number"
    });
  });
  var res = {
    oneOf: oneOf
  };
  if (description.length > 0) {
    res.description = description;
  }
  return res;
}
function isNumeric(field) {
  return /^\d+$/.test(field.name().toString());
}
function readObj(args, input) {
  var inputName = input.name().toString();
  var entry = Object.entries(args).find(function (_ref) {
    var _ref2 = spec_slicedToArray(_ref, 1),
      name = _ref2[0];
    return name === inputName;
  });
  if (!entry) {
    throw new Error("Missing field ".concat(inputName));
  }
  return entry[1];
}
function findCase(name) {
  return function matches(entry) {
    switch (entry.switch().value) {
      case stellar_base_min.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value:
        {
          var tuple = entry.tupleCase();
          return tuple.name().toString() === name;
        }
      case stellar_base_min.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value:
        {
          var voidCase = entry.voidCase();
          return voidCase.name().toString() === name;
        }
      default:
        return false;
    }
  };
}
function stringToScVal(str, ty) {
  switch (ty.value) {
    case stellar_base_min.xdr.ScSpecType.scSpecTypeString().value:
      return stellar_base_min.xdr.ScVal.scvString(str);
    case stellar_base_min.xdr.ScSpecType.scSpecTypeSymbol().value:
      return stellar_base_min.xdr.ScVal.scvSymbol(str);
    case stellar_base_min.xdr.ScSpecType.scSpecTypeAddress().value:
      return stellar_base_min.Address.fromString(str).toScVal();
    case stellar_base_min.xdr.ScSpecType.scSpecTypeU64().value:
      return new stellar_base_min.XdrLargeInt("u64", str).toScVal();
    case stellar_base_min.xdr.ScSpecType.scSpecTypeI64().value:
      return new stellar_base_min.XdrLargeInt("i64", str).toScVal();
    case stellar_base_min.xdr.ScSpecType.scSpecTypeU128().value:
      return new stellar_base_min.XdrLargeInt("u128", str).toScVal();
    case stellar_base_min.xdr.ScSpecType.scSpecTypeI128().value:
      return new stellar_base_min.XdrLargeInt("i128", str).toScVal();
    case stellar_base_min.xdr.ScSpecType.scSpecTypeU256().value:
      return new stellar_base_min.XdrLargeInt("u256", str).toScVal();
    case stellar_base_min.xdr.ScSpecType.scSpecTypeI256().value:
      return new stellar_base_min.XdrLargeInt("i256", str).toScVal();
    case stellar_base_min.xdr.ScSpecType.scSpecTypeBytes().value:
    case stellar_base_min.xdr.ScSpecType.scSpecTypeBytesN().value:
      return stellar_base_min.xdr.ScVal.scvBytes(spec_Buffer.from(str, "base64"));
    default:
      throw new TypeError("invalid type ".concat(ty.name, " specified for string value"));
  }
}
var PRIMITIVE_DEFINITONS = {
  U32: {
    type: "integer",
    minimum: 0,
    maximum: 4294967295
  },
  I32: {
    type: "integer",
    minimum: -2147483648,
    maximum: 2147483647
  },
  U64: {
    type: "string",
    pattern: "^([1-9][0-9]*|0)$",
    minLength: 1,
    maxLength: 20
  },
  I64: {
    type: "string",
    pattern: "^(-?[1-9][0-9]*|0)$",
    minLength: 1,
    maxLength: 21
  },
  U128: {
    type: "string",
    pattern: "^([1-9][0-9]*|0)$",
    minLength: 1,
    maxLength: 39
  },
  I128: {
    type: "string",
    pattern: "^(-?[1-9][0-9]*|0)$",
    minLength: 1,
    maxLength: 40
  },
  U256: {
    type: "string",
    pattern: "^([1-9][0-9]*|0)$",
    minLength: 1,
    maxLength: 78
  },
  I256: {
    type: "string",
    pattern: "^(-?[1-9][0-9]*|0)$",
    minLength: 1,
    maxLength: 79
  },
  Address: {
    type: "string",
    format: "address",
    description: "Address can be a public key or contract id"
  },
  ScString: {
    type: "string",
    description: "ScString is a string"
  },
  ScSymbol: {
    type: "string",
    description: "ScSymbol is a string"
  },
  DataUrl: {
    type: "string",
    pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$"
  }
};
function typeRef(typeDef) {
  var t = typeDef.switch();
  var value = t.value;
  var ref;
  switch (value) {
    case stellar_base_min.xdr.ScSpecType.scSpecTypeVal().value:
      {
        ref = "Val";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeBool().value:
      {
        return {
          type: "boolean"
        };
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeVoid().value:
      {
        return {
          type: "null"
        };
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeError().value:
      {
        ref = "Error";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeU32().value:
      {
        ref = "U32";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeI32().value:
      {
        ref = "I32";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeU64().value:
      {
        ref = "U64";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeI64().value:
      {
        ref = "I64";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeTimepoint().value:
      {
        throw new Error("Timepoint type not supported");
        // removed by dead control flow
{}
        // removed by dead control flow
{}
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeDuration().value:
      {
        throw new Error("Duration not supported");
        // removed by dead control flow
{}
        // removed by dead control flow
{}
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeU128().value:
      {
        ref = "U128";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeI128().value:
      {
        ref = "I128";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeU256().value:
      {
        ref = "U256";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeI256().value:
      {
        ref = "I256";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeBytes().value:
      {
        ref = "DataUrl";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeString().value:
      {
        ref = "ScString";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeSymbol().value:
      {
        ref = "ScSymbol";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeAddress().value:
      {
        ref = "Address";
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeOption().value:
      {
        var opt = typeDef.option();
        return typeRef(opt.valueType());
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeResult().value:
      {
        break;
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeVec().value:
      {
        var arr = typeDef.vec();
        var reference = typeRef(arr.elementType());
        return {
          type: "array",
          items: reference
        };
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeMap().value:
      {
        var map = typeDef.map();
        var items = [typeRef(map.keyType()), typeRef(map.valueType())];
        return {
          type: "array",
          items: {
            type: "array",
            items: items,
            minItems: 2,
            maxItems: 2
          }
        };
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeTuple().value:
      {
        var tuple = typeDef.tuple();
        var minItems = tuple.valueTypes().length;
        var maxItems = minItems;
        var _items = tuple.valueTypes().map(typeRef);
        return {
          type: "array",
          items: _items,
          minItems: minItems,
          maxItems: maxItems
        };
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeBytesN().value:
      {
        var _arr = typeDef.bytesN();
        return {
          $ref: "#/definitions/DataUrl",
          maxLength: _arr.n()
        };
      }
    case stellar_base_min.xdr.ScSpecType.scSpecTypeUdt().value:
      {
        var udt = typeDef.udt();
        ref = udt.name().toString();
        break;
      }
  }
  return {
    $ref: "#/definitions/".concat(ref)
  };
}
function isRequired(typeDef) {
  return typeDef.switch().value !== stellar_base_min.xdr.ScSpecType.scSpecTypeOption().value;
}
function argsAndRequired(input) {
  var properties = {};
  var required = [];
  input.forEach(function (arg) {
    var aType = arg.type();
    var name = arg.name().toString();
    properties[name] = typeRef(aType);
    if (isRequired(aType)) {
      required.push(name);
    }
  });
  var res = {
    properties: properties
  };
  if (required.length > 0) {
    res.required = required;
  }
  return res;
}
function structToJsonSchema(udt) {
  var fields = udt.fields();
  if (fields.some(isNumeric)) {
    if (!fields.every(isNumeric)) {
      throw new Error("mixed numeric and non-numeric field names are not allowed");
    }
    var items = fields.map(function (_, i) {
      return typeRef(fields[i].type());
    });
    return {
      type: "array",
      items: items,
      minItems: fields.length,
      maxItems: fields.length
    };
  }
  var description = udt.doc().toString();
  var _argsAndRequired = argsAndRequired(fields),
    properties = _argsAndRequired.properties,
    required = _argsAndRequired.required;
  properties.additionalProperties = false;
  return {
    description: description,
    properties: properties,
    required: required,
    type: "object"
  };
}
function functionToJsonSchema(func) {
  var _argsAndRequired2 = argsAndRequired(func.inputs()),
    properties = _argsAndRequired2.properties,
    required = _argsAndRequired2.required;
  var args = {
    additionalProperties: false,
    properties: properties,
    type: "object"
  };
  if ((required === null || required === void 0 ? void 0 : required.length) > 0) {
    args.required = required;
  }
  var input = {
    properties: {
      args: args
    }
  };
  var outputs = func.outputs();
  var output = outputs.length > 0 ? typeRef(outputs[0]) : typeRef(stellar_base_min.xdr.ScSpecTypeDef.scSpecTypeVoid());
  var description = func.doc().toString();
  if (description.length > 0) {
    input.description = description;
  }
  input.additionalProperties = false;
  output.additionalProperties = false;
  return {
    input: input,
    output: output
  };
}
function unionToJsonSchema(udt) {
  var description = udt.doc().toString();
  var cases = udt.cases();
  var oneOf = [];
  cases.forEach(function (aCase) {
    switch (aCase.switch().value) {
      case stellar_base_min.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value:
        {
          var c = aCase.voidCase();
          var title = c.name().toString();
          oneOf.push({
            type: "object",
            title: title,
            properties: {
              tag: title
            },
            additionalProperties: false,
            required: ["tag"]
          });
          break;
        }
      case stellar_base_min.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value:
        {
          var _c = aCase.tupleCase();
          var _title = _c.name().toString();
          oneOf.push({
            type: "object",
            title: _title,
            properties: {
              tag: _title,
              values: {
                type: "array",
                items: _c.type().map(typeRef)
              }
            },
            required: ["tag", "values"],
            additionalProperties: false
          });
        }
    }
  });
  var res = {
    oneOf: oneOf
  };
  if (description.length > 0) {
    res.description = description;
  }
  return res;
}
var Spec = function () {
  function Spec(entries) {
    spec_classCallCheck(this, Spec);
    spec_defineProperty(this, "entries", []);
    if (spec_Buffer.isBuffer(entries)) {
      this.entries = processSpecEntryStream(entries);
    } else if (typeof entries === "string") {
      this.entries = processSpecEntryStream(spec_Buffer.from(entries, "base64"));
    } else {
      if (entries.length === 0) {
        throw new Error("Contract spec must have at least one entry");
      }
      var entry = entries[0];
      if (typeof entry === "string") {
        this.entries = entries.map(function (s) {
          return stellar_base_min.xdr.ScSpecEntry.fromXDR(s, "base64");
        });
      } else {
        this.entries = entries;
      }
    }
  }
  return spec_createClass(Spec, [{
    key: "funcs",
    value: function funcs() {
      return this.entries.filter(function (entry) {
        return entry.switch().value === stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
      }).map(function (entry) {
        return entry.functionV0();
      });
    }
  }, {
    key: "getFunc",
    value: function getFunc(name) {
      var entry = this.findEntry(name);
      if (entry.switch().value !== stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) {
        throw new Error("".concat(name, " is not a function"));
      }
      return entry.functionV0();
    }
  }, {
    key: "funcArgsToScVals",
    value: function funcArgsToScVals(name, args) {
      var _this = this;
      var fn = this.getFunc(name);
      return fn.inputs().map(function (input) {
        return _this.nativeToScVal(readObj(args, input), input.type());
      });
    }
  }, {
    key: "funcResToNative",
    value: function funcResToNative(name, val_or_base64) {
      var val = typeof val_or_base64 === "string" ? stellar_base_min.xdr.ScVal.fromXDR(val_or_base64, "base64") : val_or_base64;
      var func = this.getFunc(name);
      var outputs = func.outputs();
      if (outputs.length === 0) {
        var type = val.switch();
        if (type.value !== stellar_base_min.xdr.ScValType.scvVoid().value) {
          throw new Error("Expected void, got ".concat(type.name));
        }
        return null;
      }
      if (outputs.length > 1) {
        throw new Error("Multiple outputs not supported");
      }
      var output = outputs[0];
      if (output.switch().value === stellar_base_min.xdr.ScSpecType.scSpecTypeResult().value) {
        return new Ok(this.scValToNative(val, output.result().okType()));
      }
      return this.scValToNative(val, output);
    }
  }, {
    key: "findEntry",
    value: function findEntry(name) {
      var entry = this.entries.find(function (e) {
        return e.value().name().toString() === name;
      });
      if (!entry) {
        throw new Error("no such entry: ".concat(name));
      }
      return entry;
    }
  }, {
    key: "nativeToScVal",
    value: function nativeToScVal(val, ty) {
      var _this2 = this;
      var t = ty.switch();
      var value = t.value;
      if (t.value === stellar_base_min.xdr.ScSpecType.scSpecTypeUdt().value) {
        var udt = ty.udt();
        return this.nativeToUdt(val, udt.name().toString());
      }
      if (value === stellar_base_min.xdr.ScSpecType.scSpecTypeOption().value) {
        var opt = ty.option();
        if (val === undefined) {
          return stellar_base_min.xdr.ScVal.scvVoid();
        }
        return this.nativeToScVal(val, opt.valueType());
      }
      switch (spec_typeof(val)) {
        case "object":
          {
            var _val$constructor$name, _val$constructor;
            if (val === null) {
              switch (value) {
                case stellar_base_min.xdr.ScSpecType.scSpecTypeVoid().value:
                  return stellar_base_min.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(ty, " was not void, but value was null"));
              }
            }
            if (val instanceof stellar_base_min.xdr.ScVal) {
              return val;
            }
            if (val instanceof stellar_base_min.Address) {
              if (ty.switch().value !== stellar_base_min.xdr.ScSpecType.scSpecTypeAddress().value) {
                throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
              }
              return val.toScVal();
            }
            if (val instanceof stellar_base_min.Contract) {
              if (ty.switch().value !== stellar_base_min.xdr.ScSpecType.scSpecTypeAddress().value) {
                throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
              }
              return val.address().toScVal();
            }
            if (val instanceof Uint8Array || spec_Buffer.isBuffer(val)) {
              var copy = Uint8Array.from(val);
              switch (value) {
                case stellar_base_min.xdr.ScSpecType.scSpecTypeBytesN().value:
                  {
                    var bytesN = ty.bytesN();
                    if (copy.length !== bytesN.n()) {
                      throw new TypeError("expected ".concat(bytesN.n(), " bytes, but got ").concat(copy.length));
                    }
                    return stellar_base_min.xdr.ScVal.scvBytes(copy);
                  }
                case stellar_base_min.xdr.ScSpecType.scSpecTypeBytes().value:
                  return stellar_base_min.xdr.ScVal.scvBytes(copy);
                default:
                  throw new TypeError("invalid type (".concat(ty, ") specified for Bytes and BytesN"));
              }
            }
            if (Array.isArray(val)) {
              switch (value) {
                case stellar_base_min.xdr.ScSpecType.scSpecTypeVec().value:
                  {
                    var vec = ty.vec();
                    var elementType = vec.elementType();
                    return stellar_base_min.xdr.ScVal.scvVec(val.map(function (v) {
                      return _this2.nativeToScVal(v, elementType);
                    }));
                  }
                case stellar_base_min.xdr.ScSpecType.scSpecTypeTuple().value:
                  {
                    var tup = ty.tuple();
                    var valTypes = tup.valueTypes();
                    if (val.length !== valTypes.length) {
                      throw new TypeError("Tuple expects ".concat(valTypes.length, " values, but ").concat(val.length, " were provided"));
                    }
                    return stellar_base_min.xdr.ScVal.scvVec(val.map(function (v, i) {
                      return _this2.nativeToScVal(v, valTypes[i]);
                    }));
                  }
                case stellar_base_min.xdr.ScSpecType.scSpecTypeMap().value:
                  {
                    var map = ty.map();
                    var keyType = map.keyType();
                    var valueType = map.valueType();
                    return stellar_base_min.xdr.ScVal.scvMap(val.map(function (entry) {
                      var key = _this2.nativeToScVal(entry[0], keyType);
                      var mapVal = _this2.nativeToScVal(entry[1], valueType);
                      return new stellar_base_min.xdr.ScMapEntry({
                        key: key,
                        val: mapVal
                      });
                    }));
                  }
                default:
                  throw new TypeError("Type ".concat(ty, " was not vec, but value was Array"));
              }
            }
            if (val.constructor === Map) {
              if (value !== stellar_base_min.xdr.ScSpecType.scSpecTypeMap().value) {
                throw new TypeError("Type ".concat(ty, " was not map, but value was Map"));
              }
              var scMap = ty.map();
              var _map = val;
              var entries = [];
              var values = _map.entries();
              var res = values.next();
              while (!res.done) {
                var _res$value = spec_slicedToArray(res.value, 2),
                  k = _res$value[0],
                  v = _res$value[1];
                var key = this.nativeToScVal(k, scMap.keyType());
                var mapval = this.nativeToScVal(v, scMap.valueType());
                entries.push(new stellar_base_min.xdr.ScMapEntry({
                  key: key,
                  val: mapval
                }));
                res = values.next();
              }
              return stellar_base_min.xdr.ScVal.scvMap(entries);
            }
            if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
              var _val$constructor2;
              throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
            }
            throw new TypeError("Received object ".concat(val, "  did not match the provided type ").concat(ty));
          }
        case "number":
        case "bigint":
          {
            switch (value) {
              case stellar_base_min.xdr.ScSpecType.scSpecTypeU32().value:
                return stellar_base_min.xdr.ScVal.scvU32(val);
              case stellar_base_min.xdr.ScSpecType.scSpecTypeI32().value:
                return stellar_base_min.xdr.ScVal.scvI32(val);
              case stellar_base_min.xdr.ScSpecType.scSpecTypeU64().value:
              case stellar_base_min.xdr.ScSpecType.scSpecTypeI64().value:
              case stellar_base_min.xdr.ScSpecType.scSpecTypeU128().value:
              case stellar_base_min.xdr.ScSpecType.scSpecTypeI128().value:
              case stellar_base_min.xdr.ScSpecType.scSpecTypeU256().value:
              case stellar_base_min.xdr.ScSpecType.scSpecTypeI256().value:
                {
                  var intType = t.name.substring(10).toLowerCase();
                  return new stellar_base_min.XdrLargeInt(intType, val).toScVal();
                }
              default:
                throw new TypeError("invalid type (".concat(ty, ") specified for integer"));
            }
          }
        case "string":
          return stringToScVal(val, t);
        case "boolean":
          {
            if (value !== stellar_base_min.xdr.ScSpecType.scSpecTypeBool().value) {
              throw TypeError("Type ".concat(ty, " was not bool, but value was bool"));
            }
            return stellar_base_min.xdr.ScVal.scvBool(val);
          }
        case "undefined":
          {
            if (!ty) {
              return stellar_base_min.xdr.ScVal.scvVoid();
            }
            switch (value) {
              case stellar_base_min.xdr.ScSpecType.scSpecTypeVoid().value:
              case stellar_base_min.xdr.ScSpecType.scSpecTypeOption().value:
                return stellar_base_min.xdr.ScVal.scvVoid();
              default:
                throw new TypeError("Type ".concat(ty, " was not void, but value was undefined"));
            }
          }
        case "function":
          return this.nativeToScVal(val(), ty);
        default:
          throw new TypeError("failed to convert typeof ".concat(spec_typeof(val), " (").concat(val, ")"));
      }
    }
  }, {
    key: "nativeToUdt",
    value: function nativeToUdt(val, name) {
      var entry = this.findEntry(name);
      switch (entry.switch()) {
        case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
          if (typeof val !== "number") {
            throw new TypeError("expected number for enum ".concat(name, ", but got ").concat(spec_typeof(val)));
          }
          return this.nativeToEnum(val, entry.udtEnumV0());
        case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
          return this.nativeToStruct(val, entry.udtStructV0());
        case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
          return this.nativeToUnion(val, entry.udtUnionV0());
        default:
          throw new Error("failed to parse udt ".concat(name));
      }
    }
  }, {
    key: "nativeToUnion",
    value: function nativeToUnion(val, union_) {
      var _this3 = this;
      var entryName = val.tag;
      var caseFound = union_.cases().find(function (entry) {
        var caseN = entry.value().name().toString();
        return caseN === entryName;
      });
      if (!caseFound) {
        throw new TypeError("no such enum entry: ".concat(entryName, " in ").concat(union_));
      }
      var key = stellar_base_min.xdr.ScVal.scvSymbol(entryName);
      switch (caseFound.switch()) {
        case stellar_base_min.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0():
          {
            return stellar_base_min.xdr.ScVal.scvVec([key]);
          }
        case stellar_base_min.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0():
          {
            var types = caseFound.tupleCase().type();
            if (Array.isArray(val.values)) {
              if (val.values.length !== types.length) {
                throw new TypeError("union ".concat(union_, " expects ").concat(types.length, " values, but got ").concat(val.values.length));
              }
              var scvals = val.values.map(function (v, i) {
                return _this3.nativeToScVal(v, types[i]);
              });
              scvals.unshift(key);
              return stellar_base_min.xdr.ScVal.scvVec(scvals);
            }
            throw new Error("failed to parse union case ".concat(caseFound, " with ").concat(val));
          }
        default:
          throw new Error("failed to parse union ".concat(union_, " with ").concat(val));
      }
    }
  }, {
    key: "nativeToStruct",
    value: function nativeToStruct(val, struct) {
      var _this4 = this;
      var fields = struct.fields();
      if (fields.some(isNumeric)) {
        if (!fields.every(isNumeric)) {
          throw new Error("mixed numeric and non-numeric field names are not allowed");
        }
        return stellar_base_min.xdr.ScVal.scvVec(fields.map(function (_, i) {
          return _this4.nativeToScVal(val[i], fields[i].type());
        }));
      }
      return stellar_base_min.xdr.ScVal.scvMap(fields.map(function (field) {
        var name = field.name().toString();
        return new stellar_base_min.xdr.ScMapEntry({
          key: _this4.nativeToScVal(name, stellar_base_min.xdr.ScSpecTypeDef.scSpecTypeSymbol()),
          val: _this4.nativeToScVal(val[name], field.type())
        });
      }));
    }
  }, {
    key: "nativeToEnum",
    value: function nativeToEnum(val, enum_) {
      if (enum_.cases().some(function (entry) {
        return entry.value() === val;
      })) {
        return stellar_base_min.xdr.ScVal.scvU32(val);
      }
      throw new TypeError("no such enum entry: ".concat(val, " in ").concat(enum_));
    }
  }, {
    key: "scValStrToNative",
    value: function scValStrToNative(scv, typeDef) {
      return this.scValToNative(stellar_base_min.xdr.ScVal.fromXDR(scv, "base64"), typeDef);
    }
  }, {
    key: "scValToNative",
    value: function scValToNative(scv, typeDef) {
      var _this5 = this;
      var t = typeDef.switch();
      var value = t.value;
      if (value === stellar_base_min.xdr.ScSpecType.scSpecTypeUdt().value) {
        return this.scValUdtToNative(scv, typeDef.udt());
      }
      switch (scv.switch().value) {
        case stellar_base_min.xdr.ScValType.scvVoid().value:
          return undefined;
        case stellar_base_min.xdr.ScValType.scvU64().value:
        case stellar_base_min.xdr.ScValType.scvI64().value:
        case stellar_base_min.xdr.ScValType.scvU128().value:
        case stellar_base_min.xdr.ScValType.scvI128().value:
        case stellar_base_min.xdr.ScValType.scvU256().value:
        case stellar_base_min.xdr.ScValType.scvI256().value:
          return (0,stellar_base_min.scValToBigInt)(scv);
        case stellar_base_min.xdr.ScValType.scvVec().value:
          {
            if (value === stellar_base_min.xdr.ScSpecType.scSpecTypeVec().value) {
              var _scv$vec;
              var vec = typeDef.vec();
              return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(function (elm) {
                return _this5.scValToNative(elm, vec.elementType());
              });
            }
            if (value === stellar_base_min.xdr.ScSpecType.scSpecTypeTuple().value) {
              var _scv$vec2;
              var tuple = typeDef.tuple();
              var valTypes = tuple.valueTypes();
              return ((_scv$vec2 = scv.vec()) !== null && _scv$vec2 !== void 0 ? _scv$vec2 : []).map(function (elm, i) {
                return _this5.scValToNative(elm, valTypes[i]);
              });
            }
            throw new TypeError("Type ".concat(typeDef, " was not vec, but ").concat(scv, " is"));
          }
        case stellar_base_min.xdr.ScValType.scvAddress().value:
          return stellar_base_min.Address.fromScVal(scv).toString();
        case stellar_base_min.xdr.ScValType.scvMap().value:
          {
            var _scv$map;
            var map = (_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : [];
            if (value === stellar_base_min.xdr.ScSpecType.scSpecTypeMap().value) {
              var typed = typeDef.map();
              var keyType = typed.keyType();
              var valueType = typed.valueType();
              var res = map.map(function (entry) {
                return [_this5.scValToNative(entry.key(), keyType), _this5.scValToNative(entry.val(), valueType)];
              });
              return res;
            }
            throw new TypeError("ScSpecType ".concat(t.name, " was not map, but ").concat(JSON.stringify(scv, null, 2), " is"));
          }
        case stellar_base_min.xdr.ScValType.scvBool().value:
        case stellar_base_min.xdr.ScValType.scvU32().value:
        case stellar_base_min.xdr.ScValType.scvI32().value:
        case stellar_base_min.xdr.ScValType.scvBytes().value:
          return scv.value();
        case stellar_base_min.xdr.ScValType.scvString().value:
        case stellar_base_min.xdr.ScValType.scvSymbol().value:
          {
            var _scv$value;
            if (value !== stellar_base_min.xdr.ScSpecType.scSpecTypeString().value && value !== stellar_base_min.xdr.ScSpecType.scSpecTypeSymbol().value) {
              throw new Error("ScSpecType ".concat(t.name, " was not string or symbol, but ").concat(JSON.stringify(scv, null, 2), " is"));
            }
            return (_scv$value = scv.value()) === null || _scv$value === void 0 ? void 0 : _scv$value.toString();
          }
        case stellar_base_min.xdr.ScValType.scvTimepoint().value:
        case stellar_base_min.xdr.ScValType.scvDuration().value:
          return (0,stellar_base_min.scValToBigInt)(stellar_base_min.xdr.ScVal.scvU64(scv.u64()));
        default:
          throw new TypeError("failed to convert ".concat(JSON.stringify(scv, null, 2), " to native type from type ").concat(t.name));
      }
    }
  }, {
    key: "scValUdtToNative",
    value: function scValUdtToNative(scv, udt) {
      var entry = this.findEntry(udt.name().toString());
      switch (entry.switch()) {
        case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
          return this.enumToNative(scv);
        case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
          return this.structToNative(scv, entry.udtStructV0());
        case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
          return this.unionToNative(scv, entry.udtUnionV0());
        default:
          throw new Error("failed to parse udt ".concat(udt.name().toString(), ": ").concat(entry));
      }
    }
  }, {
    key: "unionToNative",
    value: function unionToNative(val, udt) {
      var _this6 = this;
      var vec = val.vec();
      if (!vec) {
        throw new Error("".concat(JSON.stringify(val, null, 2), " is not a vec"));
      }
      if (vec.length === 0 && udt.cases.length !== 0) {
        throw new Error("".concat(val, " has length 0, but the there are at least one case in the union"));
      }
      var name = vec[0].sym().toString();
      if (vec[0].switch().value !== stellar_base_min.xdr.ScValType.scvSymbol().value) {
        throw new Error("{vec[0]} is not a symbol");
      }
      var entry = udt.cases().find(findCase(name));
      if (!entry) {
        throw new Error("failed to find entry ".concat(name, " in union {udt.name().toString()}"));
      }
      var res = {
        tag: name
      };
      if (entry.switch().value === stellar_base_min.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
        var tuple = entry.tupleCase();
        var ty = tuple.type();
        var values = ty.map(function (e, i) {
          return _this6.scValToNative(vec[i + 1], e);
        });
        res.values = values;
      }
      return res;
    }
  }, {
    key: "structToNative",
    value: function structToNative(val, udt) {
      var _this7 = this,
        _val$map;
      var res = {};
      var fields = udt.fields();
      if (fields.some(isNumeric)) {
        var _val$vec;
        var r = (_val$vec = val.vec()) === null || _val$vec === void 0 ? void 0 : _val$vec.map(function (entry, i) {
          return _this7.scValToNative(entry, fields[i].type());
        });
        return r;
      }
      (_val$map = val.map()) === null || _val$map === void 0 || _val$map.forEach(function (entry, i) {
        var field = fields[i];
        res[field.name().toString()] = _this7.scValToNative(entry.val(), field.type());
      });
      return res;
    }
  }, {
    key: "enumToNative",
    value: function enumToNative(scv) {
      if (scv.switch().value !== stellar_base_min.xdr.ScValType.scvU32().value) {
        throw new Error("Enum must have a u32 value");
      }
      var num = scv.u32();
      return num;
    }
  }, {
    key: "errorCases",
    value: function errorCases() {
      return this.entries.filter(function (entry) {
        return entry.switch().value === stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
      }).flatMap(function (entry) {
        return entry.value().cases();
      });
    }
  }, {
    key: "jsonSchema",
    value: function jsonSchema(funcName) {
      var definitions = {};
      this.entries.forEach(function (entry) {
        switch (entry.switch().value) {
          case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value:
            {
              var udt = entry.udtEnumV0();
              definitions[udt.name().toString()] = enumToJsonSchema(udt);
              break;
            }
          case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value:
            {
              var _udt = entry.udtStructV0();
              definitions[_udt.name().toString()] = structToJsonSchema(_udt);
              break;
            }
          case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value:
            {
              var _udt2 = entry.udtUnionV0();
              definitions[_udt2.name().toString()] = unionToJsonSchema(_udt2);
              break;
            }
          case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value:
            {
              var fn = entry.functionV0();
              var fnName = fn.name().toString();
              var _functionToJsonSchema = functionToJsonSchema(fn),
                input = _functionToJsonSchema.input;
              definitions[fnName] = input;
              break;
            }
          case stellar_base_min.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value:
            {}
        }
      });
      var res = {
        $schema: "http://json-schema.org/draft-07/schema#",
        definitions: spec_objectSpread(spec_objectSpread({}, PRIMITIVE_DEFINITONS), definitions)
      };
      if (funcName) {
        res.$ref = "#/definitions/".concat(funcName);
      }
      return res;
    }
  }], [{
    key: "fromWasm",
    value: (function () {
      var _fromWasm = spec_asyncToGenerator(spec_regenerator().m(function _callee(wasm) {
        var spec;
        return spec_regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return specFromWasm(wasm);
            case 1:
              spec = _context.v;
              return _context.a(2, new Spec(spec));
          }
        }, _callee);
      }));
      function fromWasm(_x) {
        return _fromWasm.apply(this, arguments);
      }
      return fromWasm;
    }())
  }]);
}();
;// ./src/contract/client.ts
/* provided dependency */ var client_Buffer = __webpack_require__(287)["Buffer"];
function client_typeof(o) { "@babel/helpers - typeof"; return client_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, client_typeof(o); }
var _excluded = ["method"],
  _excluded2 = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
function client_regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return client_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (client_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, client_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, client_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), client_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", client_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), client_regeneratorDefine2(u), client_regeneratorDefine2(u, o, "Generator"), client_regeneratorDefine2(u, n, function () { return this; }), client_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (client_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function client_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } client_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { client_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, client_regeneratorDefine2(e, r, n, t); }
function client_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function client_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? client_ownKeys(Object(t), !0).forEach(function (r) { client_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : client_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function client_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function client_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, client_toPropertyKey(o.key), o); } }
function client_createClass(e, r, t) { return r && client_defineProperties(e.prototype, r), t && client_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function client_defineProperty(e, r, t) { return (r = client_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function client_toPropertyKey(t) { var i = client_toPrimitive(t, "string"); return "symbol" == client_typeof(i) ? i : i + ""; }
function client_toPrimitive(t, r) { if ("object" != client_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != client_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function client_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function client_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { client_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { client_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }




var CONSTRUCTOR_FUNC = "__constructor";
function specFromWasmHash(_x, _x2) {
  return _specFromWasmHash.apply(this, arguments);
}
function _specFromWasmHash() {
  _specFromWasmHash = client_asyncToGenerator(client_regenerator().m(function _callee5(wasmHash, options) {
    var format,
      rpcUrl,
      allowHttp,
      serverOpts,
      server,
      wasm,
      _args5 = arguments;
    return client_regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          format = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : "hex";
          if (!(!options || !options.rpcUrl)) {
            _context5.n = 1;
            break;
          }
          throw new TypeError("options must contain rpcUrl");
        case 1:
          rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
          serverOpts = {
            allowHttp: allowHttp
          };
          server = new rpc.Server(rpcUrl, serverOpts);
          _context5.n = 2;
          return server.getContractWasmByHash(wasmHash, format);
        case 2:
          wasm = _context5.v;
          return _context5.a(2, Spec.fromWasm(wasm));
      }
    }, _callee5);
  }));
  return _specFromWasmHash.apply(this, arguments);
}
var Client = function () {
  function Client(spec, options) {
    var _this = this;
    client_classCallCheck(this, Client);
    client_defineProperty(this, "txFromJSON", function (json) {
      var _JSON$parse = JSON.parse(json),
        method = _JSON$parse.method,
        tx = _objectWithoutProperties(_JSON$parse, _excluded);
      return AssembledTransaction.fromJSON(client_objectSpread(client_objectSpread({}, _this.options), {}, {
        method: method,
        parseResultXdr: function parseResultXdr(result) {
          return _this.spec.funcResToNative(method, result);
        }
      }), tx);
    });
    client_defineProperty(this, "txFromXDR", function (xdrBase64) {
      return AssembledTransaction.fromXDR(_this.options, xdrBase64, _this.spec);
    });
    this.spec = spec;
    this.options = options;
    this.spec.funcs().forEach(function (xdrFn) {
      var method = xdrFn.name().toString();
      if (method === CONSTRUCTOR_FUNC) {
        return;
      }
      var assembleTransaction = function assembleTransaction(args, methodOptions) {
        return AssembledTransaction.build(client_objectSpread(client_objectSpread(client_objectSpread({
          method: method,
          args: args && spec.funcArgsToScVals(method, args)
        }, options), methodOptions), {}, {
          errorTypes: spec.errorCases().reduce(function (acc, curr) {
            return client_objectSpread(client_objectSpread({}, acc), {}, client_defineProperty({}, curr.value(), {
              message: curr.doc().toString()
            }));
          }, {}),
          parseResultXdr: function parseResultXdr(result) {
            return spec.funcResToNative(method, result);
          }
        }));
      };
      _this[method] = spec.getFunc(method).inputs().length === 0 ? function (opts) {
        return assembleTransaction(undefined, opts);
      } : assembleTransaction;
    });
  }
  return client_createClass(Client, null, [{
    key: "deploy",
    value: function () {
      var _deploy = client_asyncToGenerator(client_regenerator().m(function _callee(args, options) {
        var wasmHash, salt, format, fee, timeoutInSeconds, simulate, clientOptions, spec, operation;
        return client_regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              wasmHash = options.wasmHash, salt = options.salt, format = options.format, fee = options.fee, timeoutInSeconds = options.timeoutInSeconds, simulate = options.simulate, clientOptions = _objectWithoutProperties(options, _excluded2);
              _context.n = 1;
              return specFromWasmHash(wasmHash, clientOptions, format);
            case 1:
              spec = _context.v;
              operation = stellar_base_min.Operation.createCustomContract({
                address: new stellar_base_min.Address(options.address || options.publicKey),
                wasmHash: typeof wasmHash === "string" ? client_Buffer.from(wasmHash, format !== null && format !== void 0 ? format : "hex") : wasmHash,
                salt: salt,
                constructorArgs: args ? spec.funcArgsToScVals(CONSTRUCTOR_FUNC, args) : []
              });
              return _context.a(2, AssembledTransaction.buildWithOp(operation, client_objectSpread(client_objectSpread({
                fee: fee,
                timeoutInSeconds: timeoutInSeconds,
                simulate: simulate
              }, clientOptions), {}, {
                contractId: "ignored",
                method: CONSTRUCTOR_FUNC,
                parseResultXdr: function parseResultXdr(result) {
                  return new Client(spec, client_objectSpread(client_objectSpread({}, clientOptions), {}, {
                    contractId: stellar_base_min.Address.fromScVal(result).toString()
                  }));
                }
              })));
          }
        }, _callee);
      }));
      function deploy(_x3, _x4) {
        return _deploy.apply(this, arguments);
      }
      return deploy;
    }()
  }, {
    key: "fromWasmHash",
    value: (function () {
      var _fromWasmHash = client_asyncToGenerator(client_regenerator().m(function _callee2(wasmHash, options) {
        var format,
          rpcUrl,
          allowHttp,
          serverOpts,
          server,
          wasm,
          _args2 = arguments;
        return client_regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              format = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : "hex";
              if (!(!options || !options.rpcUrl)) {
                _context2.n = 1;
                break;
              }
              throw new TypeError('options must contain rpcUrl');
            case 1:
              rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
              serverOpts = {
                allowHttp: allowHttp
              };
              server = new rpc.Server(rpcUrl, serverOpts);
              _context2.n = 2;
              return server.getContractWasmByHash(wasmHash, format);
            case 2:
              wasm = _context2.v;
              return _context2.a(2, Client.fromWasm(wasm, options));
          }
        }, _callee2);
      }));
      function fromWasmHash(_x5, _x6) {
        return _fromWasmHash.apply(this, arguments);
      }
      return fromWasmHash;
    }())
  }, {
    key: "fromWasm",
    value: (function () {
      var _fromWasm = client_asyncToGenerator(client_regenerator().m(function _callee3(wasm, options) {
        var spec;
        return client_regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return Spec.fromWasm(wasm);
            case 1:
              spec = _context3.v;
              return _context3.a(2, new Client(spec, options));
          }
        }, _callee3);
      }));
      function fromWasm(_x7, _x8) {
        return _fromWasm.apply(this, arguments);
      }
      return fromWasm;
    }())
  }, {
    key: "from",
    value: (function () {
      var _from = client_asyncToGenerator(client_regenerator().m(function _callee4(options) {
        var rpcUrl, contractId, allowHttp, serverOpts, server, wasm;
        return client_regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              if (!(!options || !options.rpcUrl || !options.contractId)) {
                _context4.n = 1;
                break;
              }
              throw new TypeError('options must contain rpcUrl and contractId');
            case 1:
              rpcUrl = options.rpcUrl, contractId = options.contractId, allowHttp = options.allowHttp;
              serverOpts = {
                allowHttp: allowHttp
              };
              server = new rpc.Server(rpcUrl, serverOpts);
              _context4.n = 2;
              return server.getContractWasmByContractId(contractId);
            case 2:
              wasm = _context4.v;
              return _context4.a(2, Client.fromWasm(wasm, options));
          }
        }, _callee4);
      }));
      function from(_x9) {
        return _from.apply(this, arguments);
      }
      return from;
    }())
  }]);
}();
;// ./src/contract/index.ts








/***/ }),

/***/ 340:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.0 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else // removed by dead control flow
{}

}(this));


/***/ }),

/***/ 356:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccountRequiresMemoError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_0__.Cu),
/* harmony export */   BadRequestError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_0__.v7),
/* harmony export */   BadResponseError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_0__.nS),
/* harmony export */   Config: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_1__.T),
/* harmony export */   Federation: () => (/* reexport module object */ _federation__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   Friendbot: () => (/* reexport module object */ _friendbot__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   Horizon: () => (/* reexport module object */ _horizon__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   NetworkError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_0__.Dr),
/* harmony export */   NotFoundError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_0__.m_),
/* harmony export */   StellarToml: () => (/* reexport module object */ _stellartoml__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   Utils: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   WebAuth: () => (/* reexport module object */ _webauth__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   contract: () => (/* reexport module object */ _contract__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rpc: () => (/* reexport module object */ _rpc__WEBPACK_IMPORTED_MODULE_8__)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(976);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(732);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(502);
/* harmony import */ var _stellartoml__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(898);
/* harmony import */ var _federation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(600);
/* harmony import */ var _webauth__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(479);
/* harmony import */ var _friendbot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(242);
/* harmony import */ var _horizon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(733);
/* harmony import */ var _rpc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(496);
/* harmony import */ var _contract__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(299);
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(950);
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_stellar_stellar_base__WEBPACK_IMPORTED_MODULE_10__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_10__) if(["default","Config","Utils","StellarToml","Federation","WebAuth","Friendbot","Horizon","rpc","contract","AccountRequiresMemoError","BadRequestError","BadResponseError","NetworkError","NotFoundError"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_10__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* module decorator */ module = __webpack_require__.hmd(module);


















/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);
if (typeof __webpack_require__.g.__USE_AXIOS__ === 'undefined') {
  __webpack_require__.g.__USE_AXIOS__ = true;
}
if (typeof __webpack_require__.g.__USE_EVENTSOURCE__ === 'undefined') {
  __webpack_require__.g.__USE_EVENTSOURCE__ = false;
}

/***/ }),

/***/ 430:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */

(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if ( true && module.exports) {
    // Node
    module.exports = factory();
  } else if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else // removed by dead control flow
{}
}(this, function (root) {
  'use strict';

  /*
  var _in = "fe80:0000:0000:0000:0204:61ff:fe9d:f156";
  var _out = IPv6.best(_in);
  var _expected = "fe80::204:61ff:fe9d:f156";

  console.log(_in, _out, _expected, _out === _expected);
  */

  // save current IPv6 variable, if any
  var _IPv6 = root && root.IPv6;

  function bestPresentation(address) {
    // based on:
    // Javascript to test an IPv6 address for proper format, and to
    // present the "best text representation" according to IETF Draft RFC at
    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04
    // 8 Feb 2010 Rich Brown, Dartware, LLC
    // Please feel free to use this code as long as you provide a link to
    // http://www.intermapper.com
    // http://intermapper.com/support/tools/IPV6-Validator.aspx
    // http://download.dartware.com/thirdparty/ipv6validator.js

    var _address = address.toLowerCase();
    var segments = _address.split(':');
    var length = segments.length;
    var total = 8;

    // trim colons (:: or ::a:b:c… or …a:b:c::)
    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
      // must have been ::
      // remove first two items
      segments.shift();
      segments.shift();
    } else if (segments[0] === '' && segments[1] === '') {
      // must have been ::xxxx
      // remove the first item
      segments.shift();
    } else if (segments[length - 1] === '' && segments[length - 2] === '') {
      // must have been xxxx::
      segments.pop();
    }

    length = segments.length;

    // adjust total segments for IPv4 trailer
    if (segments[length - 1].indexOf('.') !== -1) {
      // found a "." which means IPv4
      total = 7;
    }

    // fill empty segments them with "0000"
    var pos;
    for (pos = 0; pos < length; pos++) {
      if (segments[pos] === '') {
        break;
      }
    }

    if (pos < total) {
      segments.splice(pos, 1, '0000');
      while (segments.length < total) {
        segments.splice(pos, 0, '0000');
      }
    }

    // strip leading zeros
    var _segments;
    for (var i = 0; i < total; i++) {
      _segments = segments[i].split('');
      for (var j = 0; j < 3 ; j++) {
        if (_segments[0] === '0' && _segments.length > 1) {
          _segments.splice(0,1);
        } else {
          break;
        }
      }

      segments[i] = _segments.join('');
    }

    // find longest sequence of zeroes and coalesce them into one segment
    var best = -1;
    var _best = 0;
    var _current = 0;
    var current = -1;
    var inzeroes = false;
    // i; already declared

    for (i = 0; i < total; i++) {
      if (inzeroes) {
        if (segments[i] === '0') {
          _current += 1;
        } else {
          inzeroes = false;
          if (_current > _best) {
            best = current;
            _best = _current;
          }
        }
      } else {
        if (segments[i] === '0') {
          inzeroes = true;
          current = i;
          _current = 1;
        }
      }
    }

    if (_current > _best) {
      best = current;
      _best = _current;
    }

    if (_best > 1) {
      segments.splice(best, _best, '');
    }

    length = segments.length;

    // assemble remaining segments
    var result = '';
    if (segments[0] === '')  {
      result = ':';
    }

    for (i = 0; i < length; i++) {
      result += segments[i];
      if (i === length - 1) {
        break;
      }

      result += ':';
    }

    if (segments[length - 1] === '') {
      result += ':';
    }

    return result;
  }

  function noConflict() {
    /*jshint validthis: true */
    if (root.IPv6 === this) {
      root.IPv6 = _IPv6;
    }

    return this;
  }

  return {
    best: bestPresentation,
    noConflict: noConflict
  };
}));


/***/ }),

/***/ 479:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  InvalidChallengeError: () => (/* reexport */ InvalidChallengeError),
  buildChallengeTx: () => (/* reexport */ buildChallengeTx),
  gatherTxSigners: () => (/* reexport */ gatherTxSigners),
  readChallengeTx: () => (/* reexport */ readChallengeTx),
  verifyChallengeTxSigners: () => (/* reexport */ verifyChallengeTxSigners),
  verifyChallengeTxThreshold: () => (/* reexport */ verifyChallengeTxThreshold),
  verifyTxSignedBy: () => (/* reexport */ verifyTxSignedBy)
});

// EXTERNAL MODULE: ./node_modules/randombytes/browser.js
var browser = __webpack_require__(209);
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);
// EXTERNAL MODULE: ./node_modules/@stellar/stellar-base/dist/stellar-base.min.js
var stellar_base_min = __webpack_require__(950);
// EXTERNAL MODULE: ./src/utils.ts
var utils = __webpack_require__(502);
;// ./src/webauth/errors.ts
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var InvalidChallengeError = function (_Error) {
  function InvalidChallengeError(message) {
    var _this;
    _classCallCheck(this, InvalidChallengeError);
    var trueProto = (this instanceof InvalidChallengeError ? this.constructor : void 0).prototype;
    _this = _callSuper(this, InvalidChallengeError, [message]);
    _this.__proto__ = trueProto;
    _this.constructor = InvalidChallengeError;
    _this.name = "InvalidChallengeError";
    return _this;
  }
  _inherits(InvalidChallengeError, _Error);
  return _createClass(InvalidChallengeError);
}(_wrapNativeSuper(Error));
;// ./src/webauth/utils.ts
/* provided dependency */ var Buffer = __webpack_require__(287)["Buffer"];
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function utils_typeof(o) { "@babel/helpers - typeof"; return utils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, utils_typeof(o); }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }




function buildChallengeTx(serverKeypair, clientAccountID, homeDomain) {
  var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;
  var networkPassphrase = arguments.length > 4 ? arguments[4] : undefined;
  var webAuthDomain = arguments.length > 5 ? arguments[5] : undefined;
  var memo = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  var clientDomain = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
  var clientSigningKey = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
  if (clientAccountID.startsWith("M") && memo) {
    throw Error("memo cannot be used if clientAccountID is a muxed account");
  }
  var account = new stellar_base_min.Account(serverKeypair.publicKey(), "-1");
  var now = Math.floor(Date.now() / 1000);
  var value = browser_default()(48).toString("base64");
  var builder = new stellar_base_min.TransactionBuilder(account, {
    fee: stellar_base_min.BASE_FEE,
    networkPassphrase: networkPassphrase,
    timebounds: {
      minTime: now,
      maxTime: now + timeout
    }
  }).addOperation(stellar_base_min.Operation.manageData({
    name: "".concat(homeDomain, " auth"),
    value: value,
    source: clientAccountID
  })).addOperation(stellar_base_min.Operation.manageData({
    name: "web_auth_domain",
    value: webAuthDomain,
    source: account.accountId()
  }));
  if (clientDomain) {
    if (!clientSigningKey) {
      throw Error("clientSigningKey is required if clientDomain is provided");
    }
    builder.addOperation(stellar_base_min.Operation.manageData({
      name: "client_domain",
      value: clientDomain,
      source: clientSigningKey
    }));
  }
  if (memo) {
    builder.addMemo(stellar_base_min.Memo.id(memo));
  }
  var transaction = builder.build();
  transaction.sign(serverKeypair);
  return transaction.toEnvelope().toXDR("base64").toString();
}
function readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains, webAuthDomain) {
  var _transaction$timeBoun;
  if (serverAccountID.startsWith("M")) {
    throw Error("Invalid serverAccountID: multiplexed accounts are not supported.");
  }
  var transaction;
  try {
    transaction = new stellar_base_min.Transaction(challengeTx, networkPassphrase);
  } catch (_unused) {
    try {
      transaction = new stellar_base_min.FeeBumpTransaction(challengeTx, networkPassphrase);
    } catch (_unused2) {
      throw new InvalidChallengeError("Invalid challenge: unable to deserialize challengeTx transaction string");
    }
    throw new InvalidChallengeError("Invalid challenge: expected a Transaction but received a FeeBumpTransaction");
  }
  var sequence = Number.parseInt(transaction.sequence, 10);
  if (sequence !== 0) {
    throw new InvalidChallengeError("The transaction sequence number should be zero");
  }
  if (transaction.source !== serverAccountID) {
    throw new InvalidChallengeError("The transaction source account is not equal to the server's account");
  }
  if (transaction.operations.length < 1) {
    throw new InvalidChallengeError("The transaction should contain at least one operation");
  }
  var _transaction$operatio = _toArray(transaction.operations),
    operation = _transaction$operatio[0],
    subsequentOperations = _transaction$operatio.slice(1);
  if (!operation.source) {
    throw new InvalidChallengeError("The transaction's operation should contain a source account");
  }
  var clientAccountID = operation.source;
  var memo = null;
  if (transaction.memo.type !== stellar_base_min.MemoNone) {
    if (clientAccountID.startsWith("M")) {
      throw new InvalidChallengeError("The transaction has a memo but the client account ID is a muxed account");
    }
    if (transaction.memo.type !== stellar_base_min.MemoID) {
      throw new InvalidChallengeError("The transaction's memo must be of type `id`");
    }
    memo = transaction.memo.value;
  }
  if (operation.type !== "manageData") {
    throw new InvalidChallengeError("The transaction's operation type should be 'manageData'");
  }
  if (transaction.timeBounds && Number.parseInt((_transaction$timeBoun = transaction.timeBounds) === null || _transaction$timeBoun === void 0 ? void 0 : _transaction$timeBoun.maxTime, 10) === stellar_base_min.TimeoutInfinite) {
    throw new InvalidChallengeError("The transaction requires non-infinite timebounds");
  }
  if (!utils/* Utils */.A.validateTimebounds(transaction, 60 * 5)) {
    throw new InvalidChallengeError("The transaction has expired");
  }
  if (operation.value === undefined) {
    throw new InvalidChallengeError("The transaction's operation values should not be null");
  }
  if (!operation.value) {
    throw new InvalidChallengeError("The transaction's operation value should not be null");
  }
  if (Buffer.from(operation.value.toString(), "base64").length !== 48) {
    throw new InvalidChallengeError("The transaction's operation value should be a 64 bytes base64 random string");
  }
  if (!homeDomains) {
    throw new InvalidChallengeError("Invalid homeDomains: a home domain must be provided for verification");
  }
  var matchedHomeDomain;
  if (typeof homeDomains === "string") {
    if ("".concat(homeDomains, " auth") === operation.name) {
      matchedHomeDomain = homeDomains;
    }
  } else if (Array.isArray(homeDomains)) {
    matchedHomeDomain = homeDomains.find(function (domain) {
      return "".concat(domain, " auth") === operation.name;
    });
  } else {
    throw new InvalidChallengeError("Invalid homeDomains: homeDomains type is ".concat(utils_typeof(homeDomains), " but should be a string or an array"));
  }
  if (!matchedHomeDomain) {
    throw new InvalidChallengeError("Invalid homeDomains: the transaction's operation key name does not match the expected home domain");
  }
  var _iterator = _createForOfIteratorHelper(subsequentOperations),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var op = _step.value;
      if (op.type !== "manageData") {
        throw new InvalidChallengeError("The transaction has operations that are not of type 'manageData'");
      }
      if (op.source !== serverAccountID && op.name !== "client_domain") {
        throw new InvalidChallengeError("The transaction has operations that are unrecognized");
      }
      if (op.name === "web_auth_domain") {
        if (op.value === undefined) {
          throw new InvalidChallengeError("'web_auth_domain' operation value should not be null");
        }
        if (op.value.compare(Buffer.from(webAuthDomain))) {
          throw new InvalidChallengeError("'web_auth_domain' operation value does not match ".concat(webAuthDomain));
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (!verifyTxSignedBy(transaction, serverAccountID)) {
    throw new InvalidChallengeError("Transaction not signed by server: '".concat(serverAccountID, "'"));
  }
  return {
    tx: transaction,
    clientAccountID: clientAccountID,
    matchedHomeDomain: matchedHomeDomain,
    memo: memo
  };
}
function verifyChallengeTxThreshold(challengeTx, serverAccountID, networkPassphrase, threshold, signerSummary, homeDomains, webAuthDomain) {
  var signers = signerSummary.map(function (signer) {
    return signer.key;
  });
  var signersFound = verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains, webAuthDomain);
  var weight = 0;
  var _loop = function _loop() {
    var _signerSummary$find;
    var signer = _signersFound[_i];
    var sigWeight = ((_signerSummary$find = signerSummary.find(function (s) {
      return s.key === signer;
    })) === null || _signerSummary$find === void 0 ? void 0 : _signerSummary$find.weight) || 0;
    weight += sigWeight;
  };
  for (var _i = 0, _signersFound = signersFound; _i < _signersFound.length; _i++) {
    _loop();
  }
  if (weight < threshold) {
    throw new InvalidChallengeError("signers with weight ".concat(weight, " do not meet threshold ").concat(threshold, "\""));
  }
  return signersFound;
}
function verifyChallengeTxSigners(challengeTx, serverAccountID, networkPassphrase, signers, homeDomains, webAuthDomain) {
  var _readChallengeTx = readChallengeTx(challengeTx, serverAccountID, networkPassphrase, homeDomains, webAuthDomain),
    tx = _readChallengeTx.tx;
  var serverKP;
  try {
    serverKP = stellar_base_min.Keypair.fromPublicKey(serverAccountID);
  } catch (err) {
    throw new Error("Couldn't infer keypair from the provided 'serverAccountID': ".concat(err.message));
  }
  var clientSigners = new Set();
  var _iterator2 = _createForOfIteratorHelper(signers),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _signer = _step2.value;
      if (_signer === serverKP.publicKey()) {
        continue;
      }
      if (_signer.charAt(0) !== "G") {
        continue;
      }
      clientSigners.add(_signer);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (clientSigners.size === 0) {
    throw new InvalidChallengeError("No verifiable client signers provided, at least one G... address must be provided");
  }
  var clientSigningKey;
  var _iterator3 = _createForOfIteratorHelper(tx.operations),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var op = _step3.value;
      if (op.type === "manageData" && op.name === "client_domain") {
        if (clientSigningKey) {
          throw new InvalidChallengeError("Found more than one client_domain operation");
        }
        clientSigningKey = op.source;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var allSigners = [serverKP.publicKey()].concat(_toConsumableArray(Array.from(clientSigners)));
  if (clientSigningKey) {
    allSigners.push(clientSigningKey);
  }
  var signersFound = gatherTxSigners(tx, allSigners);
  var serverSignatureFound = false;
  var clientSigningKeySignatureFound = false;
  for (var _i2 = 0, _signersFound2 = signersFound; _i2 < _signersFound2.length; _i2++) {
    var signer = _signersFound2[_i2];
    if (signer === serverKP.publicKey()) {
      serverSignatureFound = true;
    }
    if (signer === clientSigningKey) {
      clientSigningKeySignatureFound = true;
    }
  }
  if (!serverSignatureFound) {
    throw new InvalidChallengeError("Transaction not signed by server: '".concat(serverKP.publicKey(), "'"));
  }
  if (clientSigningKey && !clientSigningKeySignatureFound) {
    throw new InvalidChallengeError("Transaction not signed by the source account of the 'client_domain' " + "ManageData operation");
  }
  if (signersFound.length === 1) {
    throw new InvalidChallengeError("None of the given signers match the transaction signatures");
  }
  if (signersFound.length !== tx.signatures.length) {
    throw new InvalidChallengeError("Transaction has unrecognized signatures");
  }
  signersFound.splice(signersFound.indexOf(serverKP.publicKey()), 1);
  if (clientSigningKey) {
    signersFound.splice(signersFound.indexOf(clientSigningKey), 1);
  }
  return signersFound;
}
function verifyTxSignedBy(transaction, accountID) {
  return gatherTxSigners(transaction, [accountID]).length !== 0;
}
function gatherTxSigners(transaction, signers) {
  var hashedSignatureBase = transaction.hash();
  var txSignatures = _toConsumableArray(transaction.signatures);
  var signersFound = new Set();
  var _iterator4 = _createForOfIteratorHelper(signers),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var signer = _step4.value;
      if (txSignatures.length === 0) {
        break;
      }
      var keypair = void 0;
      try {
        keypair = stellar_base_min.Keypair.fromPublicKey(signer);
      } catch (err) {
        throw new InvalidChallengeError("Signer is not a valid address: ".concat(err.message));
      }
      for (var i = 0; i < txSignatures.length; i++) {
        var decSig = txSignatures[i];
        if (!decSig.hint().equals(keypair.signatureHint())) {
          continue;
        }
        if (keypair.verify(hashedSignatureBase, decSig.signature())) {
          signersFound.add(signer);
          txSignatures.splice(i, 1);
          break;
        }
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return Array.from(signersFound);
}
;// ./src/webauth/index.ts



/***/ }),

/***/ 496:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Api: () => (/* reexport */ api/* Api */.j),
  AxiosClient: () => (/* reexport */ axios),
  BasicSleepStrategy: () => (/* reexport */ BasicSleepStrategy),
  Durability: () => (/* reexport */ Durability),
  LinearSleepStrategy: () => (/* reexport */ LinearSleepStrategy),
  Server: () => (/* reexport */ RpcServer),
  assembleTransaction: () => (/* reexport */ transaction/* assembleTransaction */.X),
  "default": () => (/* binding */ rpc),
  parseRawEvents: () => (/* reexport */ parsers/* parseRawEvents */.fG),
  parseRawSimulation: () => (/* reexport */ parsers/* parseRawSimulation */.jr)
});

// EXTERNAL MODULE: ./src/rpc/api.ts
var api = __webpack_require__(76);
// EXTERNAL MODULE: ./node_modules/urijs/src/URI.js
var URI = __webpack_require__(193);
var URI_default = /*#__PURE__*/__webpack_require__.n(URI);
// EXTERNAL MODULE: ./node_modules/@stellar/stellar-base/dist/stellar-base.min.js
var stellar_base_min = __webpack_require__(950);
// EXTERNAL MODULE: ./src/http-client/index.ts + 1 modules
var http_client = __webpack_require__(983);
;// ./src/rpc/axios.ts

var version = "14.1.1";
var AxiosClient = (0,http_client/* create */.vt)({
  headers: {
    'X-Client-Name': 'js-soroban-client',
    'X-Client-Version': version
  }
});
/* harmony default export */ const axios = (AxiosClient);
;// ./src/rpc/jsonrpc.ts
function _regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }

function jsonrpc_hasOwnProperty(obj, prop) {
  return obj.hasOwnProperty(prop);
}
function postObject(_x, _x2) {
  return _postObject.apply(this, arguments);
}
function _postObject() {
  _postObject = _asyncToGenerator(_regenerator().m(function _callee(url, method) {
    var param,
      response,
      _response$data,
      _args = arguments;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          param = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
          _context.n = 1;
          return axios.post(url, {
            jsonrpc: "2.0",
            id: 1,
            method: method,
            params: param
          });
        case 1:
          response = _context.v;
          if (!jsonrpc_hasOwnProperty(response.data, "error")) {
            _context.n = 2;
            break;
          }
          throw response.data.error;
        case 2:
          return _context.a(2, (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.result);
        case 3:
          return _context.a(2);
      }
    }, _callee);
  }));
  return _postObject.apply(this, arguments);
}
// EXTERNAL MODULE: ./src/rpc/transaction.ts
var transaction = __webpack_require__(680);
// EXTERNAL MODULE: ./src/rpc/parsers.ts
var parsers = __webpack_require__(784);
// EXTERNAL MODULE: ./src/utils.ts
var utils = __webpack_require__(502);
;// ./src/rpc/server.ts
/* provided dependency */ var Buffer = __webpack_require__(287)["Buffer"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function server_regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return server_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (server_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, server_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, server_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), server_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", server_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), server_regeneratorDefine2(u), server_regeneratorDefine2(u, o, "Generator"), server_regeneratorDefine2(u, n, function () { return this; }), server_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (server_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function server_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } server_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { server_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, server_regeneratorDefine2(e, r, n, t); }
function server_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function server_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { server_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { server_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }








var SUBMIT_TRANSACTION_TIMEOUT = (/* unused pure expression or super */ null && (60 * 1000));
var Durability = function (Durability) {
  Durability["Temporary"] = "temporary";
  Durability["Persistent"] = "persistent";
  return Durability;
}({});
var DEFAULT_GET_TRANSACTION_TIMEOUT = 30;
var BasicSleepStrategy = function BasicSleepStrategy(_iter) {
  return 1000;
};
var LinearSleepStrategy = function LinearSleepStrategy(iter) {
  return 1000 * iter;
};
function findCreatedAccountSequenceInTransactionMeta(meta) {
  var _operations$flatMap$f;
  var operations = [];
  switch (meta.switch()) {
    case 0:
      operations = meta.operations();
      break;
    case 1:
    case 2:
    case 3:
    case 4:
      operations = meta.value().operations();
      break;
    default:
      throw new Error('Unexpected transaction meta switch value');
  }
  var sequenceNumber = (_operations$flatMap$f = operations.flatMap(function (op) {
    return op.changes();
  }).find(function (c) {
    return c.switch() === stellar_base_min.xdr.LedgerEntryChangeType.ledgerEntryCreated() && c.created().data().switch() === stellar_base_min.xdr.LedgerEntryType.account();
  })) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.created()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.data()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.account()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.seqNum()) === null || _operations$flatMap$f === void 0 ? void 0 : _operations$flatMap$f.toString();
  if (sequenceNumber) {
    return sequenceNumber;
  }
  throw new Error('No account created in transaction');
}
var RpcServer = function () {
  function RpcServer(serverURL) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, RpcServer);
    this.serverURL = URI_default()(serverURL);
    if (opts.headers && Object.keys(opts.headers).length !== 0) {
      axios.interceptors.request.use(function (config) {
        config.headers = Object.assign(config.headers, opts.headers);
        return config;
      });
    }
    if (this.serverURL.protocol() !== 'https' && !opts.allowHttp) {
      throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
    }
  }
  return _createClass(RpcServer, [{
    key: "getAccount",
    value: (function () {
      var _getAccount = server_asyncToGenerator(server_regenerator().m(function _callee(address) {
        var ledgerKey, resp, accountEntry;
        return server_regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              ledgerKey = stellar_base_min.xdr.LedgerKey.account(new stellar_base_min.xdr.LedgerKeyAccount({
                accountId: stellar_base_min.Keypair.fromPublicKey(address).xdrPublicKey()
              }));
              _context.n = 1;
              return this.getLedgerEntries(ledgerKey);
            case 1:
              resp = _context.v;
              if (!(resp.entries.length === 0)) {
                _context.n = 2;
                break;
              }
              return _context.a(2, Promise.reject({
                code: 404,
                message: "Account not found: ".concat(address)
              }));
            case 2:
              accountEntry = resp.entries[0].val.account();
              return _context.a(2, new stellar_base_min.Account(address, accountEntry.seqNum().toString()));
          }
        }, _callee, this);
      }));
      function getAccount(_x) {
        return _getAccount.apply(this, arguments);
      }
      return getAccount;
    }())
  }, {
    key: "getHealth",
    value: (function () {
      var _getHealth = server_asyncToGenerator(server_regenerator().m(function _callee2() {
        return server_regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              return _context2.a(2, postObject(this.serverURL.toString(), 'getHealth'));
          }
        }, _callee2, this);
      }));
      function getHealth() {
        return _getHealth.apply(this, arguments);
      }
      return getHealth;
    }())
  }, {
    key: "getContractData",
    value: (function () {
      var _getContractData = server_asyncToGenerator(server_regenerator().m(function _callee3(contract, key) {
        var durability,
          scAddress,
          xdrDurability,
          contractKey,
          _args3 = arguments,
          _t;
        return server_regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              durability = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : Durability.Persistent;
              if (!(typeof contract === 'string')) {
                _context3.n = 1;
                break;
              }
              scAddress = new stellar_base_min.Contract(contract).address().toScAddress();
              _context3.n = 4;
              break;
            case 1:
              if (!(contract instanceof stellar_base_min.Address)) {
                _context3.n = 2;
                break;
              }
              scAddress = contract.toScAddress();
              _context3.n = 4;
              break;
            case 2:
              if (!(contract instanceof stellar_base_min.Contract)) {
                _context3.n = 3;
                break;
              }
              scAddress = contract.address().toScAddress();
              _context3.n = 4;
              break;
            case 3:
              throw new TypeError("unknown contract type: ".concat(contract));
            case 4:
              _t = durability;
              _context3.n = _t === Durability.Temporary ? 5 : _t === Durability.Persistent ? 6 : 7;
              break;
            case 5:
              xdrDurability = stellar_base_min.xdr.ContractDataDurability.temporary();
              return _context3.a(3, 8);
            case 6:
              xdrDurability = stellar_base_min.xdr.ContractDataDurability.persistent();
              return _context3.a(3, 8);
            case 7:
              throw new TypeError("invalid durability: ".concat(durability));
            case 8:
              contractKey = stellar_base_min.xdr.LedgerKey.contractData(new stellar_base_min.xdr.LedgerKeyContractData({
                key: key,
                contract: scAddress,
                durability: xdrDurability
              }));
              return _context3.a(2, this.getLedgerEntries(contractKey).then(function (r) {
                if (r.entries.length === 0) {
                  return Promise.reject({
                    code: 404,
                    message: "Contract data not found. Contract: ".concat(stellar_base_min.Address.fromScAddress(scAddress).toString(), ", Key: ").concat(key.toXDR('base64'), ", Durability: ").concat(durability)
                  });
                }
                return r.entries[0];
              }));
          }
        }, _callee3, this);
      }));
      function getContractData(_x2, _x3) {
        return _getContractData.apply(this, arguments);
      }
      return getContractData;
    }())
  }, {
    key: "getContractWasmByContractId",
    value: (function () {
      var _getContractWasmByContractId = server_asyncToGenerator(server_regenerator().m(function _callee4(contractId) {
        var _response$entries$;
        var contractLedgerKey, response, wasmHash;
        return server_regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              contractLedgerKey = new stellar_base_min.Contract(contractId).getFootprint();
              _context4.n = 1;
              return this.getLedgerEntries(contractLedgerKey);
            case 1:
              response = _context4.v;
              if (!(!response.entries.length || !((_response$entries$ = response.entries[0]) !== null && _response$entries$ !== void 0 && _response$entries$.val))) {
                _context4.n = 2;
                break;
              }
              return _context4.a(2, Promise.reject({
                code: 404,
                message: "Could not obtain contract hash from server"
              }));
            case 2:
              wasmHash = response.entries[0].val.contractData().val().instance().executable().wasmHash();
              return _context4.a(2, this.getContractWasmByHash(wasmHash));
          }
        }, _callee4, this);
      }));
      function getContractWasmByContractId(_x4) {
        return _getContractWasmByContractId.apply(this, arguments);
      }
      return getContractWasmByContractId;
    }())
  }, {
    key: "getContractWasmByHash",
    value: (function () {
      var _getContractWasmByHash = server_asyncToGenerator(server_regenerator().m(function _callee5(wasmHash) {
        var _responseWasm$entries;
        var format,
          wasmHashBuffer,
          ledgerKeyWasmHash,
          responseWasm,
          wasmBuffer,
          _args5 = arguments;
        return server_regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              format = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : undefined;
              wasmHashBuffer = typeof wasmHash === "string" ? Buffer.from(wasmHash, format) : wasmHash;
              ledgerKeyWasmHash = stellar_base_min.xdr.LedgerKey.contractCode(new stellar_base_min.xdr.LedgerKeyContractCode({
                hash: wasmHashBuffer
              }));
              _context5.n = 1;
              return this.getLedgerEntries(ledgerKeyWasmHash);
            case 1:
              responseWasm = _context5.v;
              if (!(!responseWasm.entries.length || !((_responseWasm$entries = responseWasm.entries[0]) !== null && _responseWasm$entries !== void 0 && _responseWasm$entries.val))) {
                _context5.n = 2;
                break;
              }
              return _context5.a(2, Promise.reject({
                code: 404,
                message: "Could not obtain contract wasm from server"
              }));
            case 2:
              wasmBuffer = responseWasm.entries[0].val.contractCode().code();
              return _context5.a(2, wasmBuffer);
          }
        }, _callee5, this);
      }));
      function getContractWasmByHash(_x5) {
        return _getContractWasmByHash.apply(this, arguments);
      }
      return getContractWasmByHash;
    }())
  }, {
    key: "getLedgerEntries",
    value: (function () {
      var _getLedgerEntries2 = server_asyncToGenerator(server_regenerator().m(function _callee6() {
        var _args6 = arguments;
        return server_regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              return _context6.a(2, this._getLedgerEntries.apply(this, _args6).then(parsers/* parseRawLedgerEntries */.$D));
          }
        }, _callee6, this);
      }));
      function getLedgerEntries() {
        return _getLedgerEntries2.apply(this, arguments);
      }
      return getLedgerEntries;
    }())
  }, {
    key: "_getLedgerEntries",
    value: function () {
      var _getLedgerEntries3 = server_asyncToGenerator(server_regenerator().m(function _callee7() {
        var _len,
          keys,
          _key,
          _args7 = arguments;
        return server_regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              for (_len = _args7.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
                keys[_key] = _args7[_key];
              }
              return _context7.a(2, postObject(this.serverURL.toString(), 'getLedgerEntries', {
                keys: keys.map(function (k) {
                  return k.toXDR('base64');
                })
              }));
          }
        }, _callee7, this);
      }));
      function _getLedgerEntries() {
        return _getLedgerEntries3.apply(this, arguments);
      }
      return _getLedgerEntries;
    }()
  }, {
    key: "pollTransaction",
    value: (function () {
      var _pollTransaction = server_asyncToGenerator(server_regenerator().m(function _callee8(hash, opts) {
        var _opts$attempts, _opts$attempts2;
        var maxAttempts, foundInfo, attempt, _opts$sleepStrategy;
        return server_regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              maxAttempts = ((_opts$attempts = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts !== void 0 ? _opts$attempts : 0) < 1 ? DEFAULT_GET_TRANSACTION_TIMEOUT : (_opts$attempts2 = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts2 !== void 0 ? _opts$attempts2 : DEFAULT_GET_TRANSACTION_TIMEOUT;
              attempt = 1;
            case 1:
              if (!(attempt < maxAttempts)) {
                _context8.n = 5;
                break;
              }
              _context8.n = 2;
              return this.getTransaction(hash);
            case 2:
              foundInfo = _context8.v;
              if (!(foundInfo.status !== api/* Api */.j.GetTransactionStatus.NOT_FOUND)) {
                _context8.n = 3;
                break;
              }
              return _context8.a(2, foundInfo);
            case 3:
              _context8.n = 4;
              return utils/* Utils */.A.sleep(((_opts$sleepStrategy = opts === null || opts === void 0 ? void 0 : opts.sleepStrategy) !== null && _opts$sleepStrategy !== void 0 ? _opts$sleepStrategy : BasicSleepStrategy)(attempt));
            case 4:
              attempt++;
              _context8.n = 1;
              break;
            case 5:
              return _context8.a(2, foundInfo);
          }
        }, _callee8, this);
      }));
      function pollTransaction(_x6, _x7) {
        return _pollTransaction.apply(this, arguments);
      }
      return pollTransaction;
    }())
  }, {
    key: "getTransaction",
    value: (function () {
      var _getTransaction2 = server_asyncToGenerator(server_regenerator().m(function _callee9(hash) {
        return server_regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2, this._getTransaction(hash).then(function (raw) {
                var foundInfo = {};
                if (raw.status !== api/* Api */.j.GetTransactionStatus.NOT_FOUND) {
                  Object.assign(foundInfo, (0,parsers/* parseTransactionInfo */.WC)(raw));
                }
                var result = _objectSpread({
                  status: raw.status,
                  txHash: hash,
                  latestLedger: raw.latestLedger,
                  latestLedgerCloseTime: raw.latestLedgerCloseTime,
                  oldestLedger: raw.oldestLedger,
                  oldestLedgerCloseTime: raw.oldestLedgerCloseTime
                }, foundInfo);
                return result;
              }));
          }
        }, _callee9, this);
      }));
      function getTransaction(_x8) {
        return _getTransaction2.apply(this, arguments);
      }
      return getTransaction;
    }())
  }, {
    key: "_getTransaction",
    value: function () {
      var _getTransaction3 = server_asyncToGenerator(server_regenerator().m(function _callee0(hash) {
        return server_regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              return _context0.a(2, postObject(this.serverURL.toString(), 'getTransaction', {
                hash: hash
              }));
          }
        }, _callee0, this);
      }));
      function _getTransaction(_x9) {
        return _getTransaction3.apply(this, arguments);
      }
      return _getTransaction;
    }()
  }, {
    key: "getTransactions",
    value: (function () {
      var _getTransactions2 = server_asyncToGenerator(server_regenerator().m(function _callee1(request) {
        return server_regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              return _context1.a(2, this._getTransactions(request).then(function (raw) {
                var result = {
                  transactions: (raw.transactions || []).map(parsers/* parseRawTransactions */.tR),
                  latestLedger: raw.latestLedger,
                  latestLedgerCloseTimestamp: raw.latestLedgerCloseTimestamp,
                  oldestLedger: raw.oldestLedger,
                  oldestLedgerCloseTimestamp: raw.oldestLedgerCloseTimestamp,
                  cursor: raw.cursor
                };
                return result;
              }));
          }
        }, _callee1, this);
      }));
      function getTransactions(_x0) {
        return _getTransactions2.apply(this, arguments);
      }
      return getTransactions;
    }())
  }, {
    key: "_getTransactions",
    value: function () {
      var _getTransactions3 = server_asyncToGenerator(server_regenerator().m(function _callee10(request) {
        return server_regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              return _context10.a(2, postObject(this.serverURL.toString(), 'getTransactions', request));
          }
        }, _callee10, this);
      }));
      function _getTransactions(_x1) {
        return _getTransactions3.apply(this, arguments);
      }
      return _getTransactions;
    }()
  }, {
    key: "getEvents",
    value: (function () {
      var _getEvents2 = server_asyncToGenerator(server_regenerator().m(function _callee11(request) {
        return server_regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              return _context11.a(2, this._getEvents(request).then(parsers/* parseRawEvents */.fG));
          }
        }, _callee11, this);
      }));
      function getEvents(_x10) {
        return _getEvents2.apply(this, arguments);
      }
      return getEvents;
    }())
  }, {
    key: "_getEvents",
    value: function () {
      var _getEvents3 = server_asyncToGenerator(server_regenerator().m(function _callee12(request) {
        var _request$filters;
        return server_regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              return _context12.a(2, postObject(this.serverURL.toString(), 'getEvents', _objectSpread(_objectSpread({
                filters: (_request$filters = request.filters) !== null && _request$filters !== void 0 ? _request$filters : [],
                pagination: _objectSpread(_objectSpread({}, request.cursor && {
                  cursor: request.cursor
                }), request.limit && {
                  limit: request.limit
                })
              }, request.startLedger && {
                startLedger: request.startLedger
              }), request.endLedger && {
                endLedger: request.endLedger
              })));
          }
        }, _callee12, this);
      }));
      function _getEvents(_x11) {
        return _getEvents3.apply(this, arguments);
      }
      return _getEvents;
    }()
  }, {
    key: "getNetwork",
    value: (function () {
      var _getNetwork = server_asyncToGenerator(server_regenerator().m(function _callee13() {
        return server_regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              return _context13.a(2, postObject(this.serverURL.toString(), 'getNetwork'));
          }
        }, _callee13, this);
      }));
      function getNetwork() {
        return _getNetwork.apply(this, arguments);
      }
      return getNetwork;
    }())
  }, {
    key: "getLatestLedger",
    value: (function () {
      var _getLatestLedger = server_asyncToGenerator(server_regenerator().m(function _callee14() {
        return server_regenerator().w(function (_context14) {
          while (1) switch (_context14.n) {
            case 0:
              return _context14.a(2, postObject(this.serverURL.toString(), 'getLatestLedger'));
          }
        }, _callee14, this);
      }));
      function getLatestLedger() {
        return _getLatestLedger.apply(this, arguments);
      }
      return getLatestLedger;
    }())
  }, {
    key: "simulateTransaction",
    value: (function () {
      var _simulateTransaction2 = server_asyncToGenerator(server_regenerator().m(function _callee15(tx, addlResources, authMode) {
        return server_regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              return _context15.a(2, this._simulateTransaction(tx, addlResources, authMode).then(parsers/* parseRawSimulation */.jr));
          }
        }, _callee15, this);
      }));
      function simulateTransaction(_x12, _x13, _x14) {
        return _simulateTransaction2.apply(this, arguments);
      }
      return simulateTransaction;
    }())
  }, {
    key: "_simulateTransaction",
    value: function () {
      var _simulateTransaction3 = server_asyncToGenerator(server_regenerator().m(function _callee16(transaction, addlResources, authMode) {
        return server_regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              return _context16.a(2, postObject(this.serverURL.toString(), 'simulateTransaction', _objectSpread({
                transaction: transaction.toXDR(),
                authMode: authMode
              }, addlResources !== undefined && {
                resourceConfig: {
                  instructionLeeway: addlResources.cpuInstructions
                }
              })));
          }
        }, _callee16, this);
      }));
      function _simulateTransaction(_x15, _x16, _x17) {
        return _simulateTransaction3.apply(this, arguments);
      }
      return _simulateTransaction;
    }()
  }, {
    key: "prepareTransaction",
    value: (function () {
      var _prepareTransaction = server_asyncToGenerator(server_regenerator().m(function _callee17(tx) {
        var simResponse;
        return server_regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              _context17.n = 1;
              return this.simulateTransaction(tx);
            case 1:
              simResponse = _context17.v;
              if (!api/* Api */.j.isSimulationError(simResponse)) {
                _context17.n = 2;
                break;
              }
              throw new Error(simResponse.error);
            case 2:
              return _context17.a(2, (0,transaction/* assembleTransaction */.X)(tx, simResponse).build());
          }
        }, _callee17, this);
      }));
      function prepareTransaction(_x18) {
        return _prepareTransaction.apply(this, arguments);
      }
      return prepareTransaction;
    }())
  }, {
    key: "sendTransaction",
    value: (function () {
      var _sendTransaction2 = server_asyncToGenerator(server_regenerator().m(function _callee18(transaction) {
        return server_regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              return _context18.a(2, this._sendTransaction(transaction).then(parsers/* parseRawSendTransaction */.Af));
          }
        }, _callee18, this);
      }));
      function sendTransaction(_x19) {
        return _sendTransaction2.apply(this, arguments);
      }
      return sendTransaction;
    }())
  }, {
    key: "_sendTransaction",
    value: function () {
      var _sendTransaction3 = server_asyncToGenerator(server_regenerator().m(function _callee19(transaction) {
        return server_regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              return _context19.a(2, postObject(this.serverURL.toString(), 'sendTransaction', {
                transaction: transaction.toXDR()
              }));
          }
        }, _callee19, this);
      }));
      function _sendTransaction(_x20) {
        return _sendTransaction3.apply(this, arguments);
      }
      return _sendTransaction;
    }()
  }, {
    key: "requestAirdrop",
    value: (function () {
      var _requestAirdrop = server_asyncToGenerator(server_regenerator().m(function _callee20(address, friendbotUrl) {
        var account, response, meta, txMeta, sequence, _error$response, _error$response$detai, _t2, _t3;
        return server_regenerator().w(function (_context20) {
          while (1) switch (_context20.p = _context20.n) {
            case 0:
              account = typeof address === 'string' ? address : address.accountId();
              _t2 = friendbotUrl;
              if (_t2) {
                _context20.n = 2;
                break;
              }
              _context20.n = 1;
              return this.getNetwork();
            case 1:
              _t2 = _context20.v.friendbotUrl;
            case 2:
              friendbotUrl = _t2;
              if (friendbotUrl) {
                _context20.n = 3;
                break;
              }
              throw new Error('No friendbot URL configured for current network');
            case 3:
              _context20.p = 3;
              _context20.n = 4;
              return axios.post("".concat(friendbotUrl, "?addr=").concat(encodeURIComponent(account)));
            case 4:
              response = _context20.v;
              if (response.data.result_meta_xdr) {
                _context20.n = 7;
                break;
              }
              _context20.n = 5;
              return this.getTransaction(response.data.hash);
            case 5:
              txMeta = _context20.v;
              if (!(txMeta.status !== api/* Api */.j.GetTransactionStatus.SUCCESS)) {
                _context20.n = 6;
                break;
              }
              throw new Error("Funding account ".concat(address, " failed"));
            case 6:
              meta = txMeta.resultMetaXdr;
              _context20.n = 8;
              break;
            case 7:
              meta = stellar_base_min.xdr.TransactionMeta.fromXDR(response.data.result_meta_xdr, 'base64');
            case 8:
              sequence = findCreatedAccountSequenceInTransactionMeta(meta);
              return _context20.a(2, new stellar_base_min.Account(account, sequence));
            case 9:
              _context20.p = 9;
              _t3 = _context20.v;
              if (!(((_error$response = _t3.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 400)) {
                _context20.n = 10;
                break;
              }
              if (!((_error$response$detai = _t3.response.detail) !== null && _error$response$detai !== void 0 && _error$response$detai.includes('createAccountAlreadyExist'))) {
                _context20.n = 10;
                break;
              }
              return _context20.a(2, this.getAccount(account));
            case 10:
              throw _t3;
            case 11:
              return _context20.a(2);
          }
        }, _callee20, this, [[3, 9]]);
      }));
      function requestAirdrop(_x21, _x22) {
        return _requestAirdrop.apply(this, arguments);
      }
      return requestAirdrop;
    }())
  }, {
    key: "getFeeStats",
    value: (function () {
      var _getFeeStats = server_asyncToGenerator(server_regenerator().m(function _callee21() {
        return server_regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              return _context21.a(2, postObject(this.serverURL.toString(), 'getFeeStats'));
          }
        }, _callee21, this);
      }));
      function getFeeStats() {
        return _getFeeStats.apply(this, arguments);
      }
      return getFeeStats;
    }())
  }, {
    key: "getVersionInfo",
    value: (function () {
      var _getVersionInfo = server_asyncToGenerator(server_regenerator().m(function _callee22() {
        return server_regenerator().w(function (_context22) {
          while (1) switch (_context22.n) {
            case 0:
              return _context22.a(2, postObject(this.serverURL.toString(), 'getVersionInfo'));
          }
        }, _callee22, this);
      }));
      function getVersionInfo() {
        return _getVersionInfo.apply(this, arguments);
      }
      return getVersionInfo;
    }())
  }, {
    key: "getSACBalance",
    value: (function () {
      var _getSACBalance = server_asyncToGenerator(server_regenerator().m(function _callee23(contractId, sac, networkPassphrase) {
        var passphrase, sacId, key, ledgerKey, response, _response$entries$2, lastModifiedLedgerSeq, liveUntilLedgerSeq, val, entry, _t4;
        return server_regenerator().w(function (_context23) {
          while (1) switch (_context23.n) {
            case 0:
              if (stellar_base_min.StrKey.isValidContract(contractId)) {
                _context23.n = 1;
                break;
              }
              throw new TypeError("expected contract ID, got ".concat(contractId));
            case 1:
              if (!(networkPassphrase !== null && networkPassphrase !== void 0)) {
                _context23.n = 2;
                break;
              }
              _t4 = networkPassphrase;
              _context23.n = 4;
              break;
            case 2:
              _context23.n = 3;
              return this.getNetwork().then(function (n) {
                return n.passphrase;
              });
            case 3:
              _t4 = _context23.v;
            case 4:
              passphrase = _t4;
              sacId = sac.contractId(passphrase);
              key = (0,stellar_base_min.nativeToScVal)(["Balance", contractId], {
                type: ["symbol", "address"]
              });
              ledgerKey = stellar_base_min.xdr.LedgerKey.contractData(new stellar_base_min.xdr.LedgerKeyContractData({
                contract: new stellar_base_min.Address(sacId).toScAddress(),
                durability: stellar_base_min.xdr.ContractDataDurability.persistent(),
                key: key
              }));
              _context23.n = 5;
              return this.getLedgerEntries(ledgerKey);
            case 5:
              response = _context23.v;
              if (!(response.entries.length === 0)) {
                _context23.n = 6;
                break;
              }
              return _context23.a(2, {
                latestLedger: response.latestLedger
              });
            case 6:
              _response$entries$2 = response.entries[0], lastModifiedLedgerSeq = _response$entries$2.lastModifiedLedgerSeq, liveUntilLedgerSeq = _response$entries$2.liveUntilLedgerSeq, val = _response$entries$2.val;
              if (!(val.switch().value !== stellar_base_min.xdr.LedgerEntryType.contractData().value)) {
                _context23.n = 7;
                break;
              }
              return _context23.a(2, {
                latestLedger: response.latestLedger
              });
            case 7:
              entry = (0,stellar_base_min.scValToNative)(val.contractData().val());
              return _context23.a(2, {
                latestLedger: response.latestLedger,
                balanceEntry: {
                  liveUntilLedgerSeq: liveUntilLedgerSeq,
                  lastModifiedLedgerSeq: lastModifiedLedgerSeq,
                  amount: entry.amount.toString(),
                  authorized: entry.authorized,
                  clawback: entry.clawback
                }
              });
          }
        }, _callee23, this);
      }));
      function getSACBalance(_x23, _x24, _x25) {
        return _getSACBalance.apply(this, arguments);
      }
      return getSACBalance;
    }())
  }]);
}();
;// ./src/rpc/index.ts
/* module decorator */ module = __webpack_require__.hmd(module);





/* harmony default export */ const rpc = (module.exports);

/***/ }),

/***/ 502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Utils)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Utils = function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }
  return _createClass(Utils, null, [{
    key: "validateTimebounds",
    value: function validateTimebounds(transaction) {
      var gracePeriod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (!transaction.timeBounds) {
        return false;
      }
      var now = Math.floor(Date.now() / 1000);
      var _transaction$timeBoun = transaction.timeBounds,
        minTime = _transaction$timeBoun.minTime,
        maxTime = _transaction$timeBoun.maxTime;
      return now >= Number.parseInt(minTime, 10) - gracePeriod && now <= Number.parseInt(maxTime, 10) + gracePeriod;
    }
  }, {
    key: "sleep",
    value: function sleep(ms) {
      return new Promise(function (resolve) {
        return setTimeout(resolve, ms);
      });
    }
  }]);
}();

/***/ }),

/***/ 526:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 546:
/***/ ((module) => {

module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function() { return nodes },
        peg$c2 = peg$FAILED,
        peg$c3 = "#",
        peg$c4 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c5 = void 0,
        peg$c6 = { type: "any", description: "any character" },
        peg$c7 = "[",
        peg$c8 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c9 = "]",
        peg$c10 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c11 = function(name) { addNode(node('ObjectPath', name, line, column)) },
        peg$c12 = function(name) { addNode(node('ArrayPath', name, line, column)) },
        peg$c13 = function(parts, name) { return parts.concat(name) },
        peg$c14 = function(name) { return [name] },
        peg$c15 = function(name) { return name },
        peg$c16 = ".",
        peg$c17 = { type: "literal", value: ".", description: "\".\"" },
        peg$c18 = "=",
        peg$c19 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c20 = function(key, value) { addNode(node('Assign', value, line, column, key)) },
        peg$c21 = function(chars) { return chars.join('') },
        peg$c22 = function(node) { return node.value },
        peg$c23 = "\"\"\"",
        peg$c24 = { type: "literal", value: "\"\"\"", description: "\"\\\"\\\"\\\"\"" },
        peg$c25 = null,
        peg$c26 = function(chars) { return node('String', chars.join(''), line, column) },
        peg$c27 = "\"",
        peg$c28 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c29 = "'''",
        peg$c30 = { type: "literal", value: "'''", description: "\"'''\"" },
        peg$c31 = "'",
        peg$c32 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c33 = function(char) { return char },
        peg$c34 = function(char) { return char},
        peg$c35 = "\\",
        peg$c36 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c37 = function() { return '' },
        peg$c38 = "e",
        peg$c39 = { type: "literal", value: "e", description: "\"e\"" },
        peg$c40 = "E",
        peg$c41 = { type: "literal", value: "E", description: "\"E\"" },
        peg$c42 = function(left, right) { return node('Float', parseFloat(left + 'e' + right), line, column) },
        peg$c43 = function(text) { return node('Float', parseFloat(text), line, column) },
        peg$c44 = "+",
        peg$c45 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c46 = function(digits) { return digits.join('') },
        peg$c47 = "-",
        peg$c48 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c49 = function(digits) { return '-' + digits.join('') },
        peg$c50 = function(text) { return node('Integer', parseInt(text, 10), line, column) },
        peg$c51 = "true",
        peg$c52 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c53 = function() { return node('Boolean', true, line, column) },
        peg$c54 = "false",
        peg$c55 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c56 = function() { return node('Boolean', false, line, column) },
        peg$c57 = function() { return node('Array', [], line, column) },
        peg$c58 = function(value) { return node('Array', value ? [value] : [], line, column) },
        peg$c59 = function(values) { return node('Array', values, line, column) },
        peg$c60 = function(values, value) { return node('Array', values.concat(value), line, column) },
        peg$c61 = function(value) { return value },
        peg$c62 = ",",
        peg$c63 = { type: "literal", value: ",", description: "\",\"" },
        peg$c64 = "{",
        peg$c65 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c66 = "}",
        peg$c67 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c68 = function(values) { return node('InlineTable', values, line, column) },
        peg$c69 = function(key, value) { return node('InlineTableValue', value, line, column, key) },
        peg$c70 = function(digits) { return "." + digits },
        peg$c71 = function(date) { return  date.join('') },
        peg$c72 = ":",
        peg$c73 = { type: "literal", value: ":", description: "\":\"" },
        peg$c74 = function(time) { return time.join('') },
        peg$c75 = "T",
        peg$c76 = { type: "literal", value: "T", description: "\"T\"" },
        peg$c77 = "Z",
        peg$c78 = { type: "literal", value: "Z", description: "\"Z\"" },
        peg$c79 = function(date, time) { return node('Date', new Date(date + "T" + time + "Z"), line, column) },
        peg$c80 = function(date, time) { return node('Date', new Date(date + "T" + time), line, column) },
        peg$c81 = /^[ \t]/,
        peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" },
        peg$c83 = "\n",
        peg$c84 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c85 = "\r",
        peg$c86 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c87 = /^[0-9a-f]/i,
        peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" },
        peg$c89 = /^[0-9]/,
        peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c91 = "_",
        peg$c92 = { type: "literal", value: "_", description: "\"_\"" },
        peg$c93 = function() { return "" },
        peg$c94 = /^[A-Za-z0-9_\-]/,
        peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" },
        peg$c96 = function(d) { return d.join('') },
        peg$c97 = "\\\"",
        peg$c98 = { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
        peg$c99 = function() { return '"'  },
        peg$c100 = "\\\\",
        peg$c101 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
        peg$c102 = function() { return '\\' },
        peg$c103 = "\\b",
        peg$c104 = { type: "literal", value: "\\b", description: "\"\\\\b\"" },
        peg$c105 = function() { return '\b' },
        peg$c106 = "\\t",
        peg$c107 = { type: "literal", value: "\\t", description: "\"\\\\t\"" },
        peg$c108 = function() { return '\t' },
        peg$c109 = "\\n",
        peg$c110 = { type: "literal", value: "\\n", description: "\"\\\\n\"" },
        peg$c111 = function() { return '\n' },
        peg$c112 = "\\f",
        peg$c113 = { type: "literal", value: "\\f", description: "\"\\\\f\"" },
        peg$c114 = function() { return '\f' },
        peg$c115 = "\\r",
        peg$c116 = { type: "literal", value: "\\r", description: "\"\\\\r\"" },
        peg$c117 = function() { return '\r' },
        peg$c118 = "\\U",
        peg$c119 = { type: "literal", value: "\\U", description: "\"\\\\U\"" },
        peg$c120 = function(digits) { return convertCodePoint(digits.join('')) },
        peg$c121 = "\\u",
        peg$c122 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$cache = {},
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 0,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseline();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseline();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1();
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseline() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 49 + 1,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexpression();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsecomment();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsecomment();
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseNL();
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseNL();
                }
              } else {
                s5 = peg$c2;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              if (s5 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4, s5];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseNL();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseNL();
            }
          } else {
            s2 = peg$c2;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$parseEOF();
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseNL();
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpression() {
      var s0;

      var key    = peg$currPos * 49 + 2,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsecomment();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepath();
        if (s0 === peg$FAILED) {
          s0 = peg$parsetablearray();
          if (s0 === peg$FAILED) {
            s0 = peg$parseassignment();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 49 + 3,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c3;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseNL();
        if (s5 === peg$FAILED) {
          s5 = peg$parseEOF();
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c5;
        } else {
          peg$currPos = s4;
          s4 = peg$c2;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c2;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseNL();
          if (s5 === peg$FAILED) {
            s5 = peg$parseEOF();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c5;
          } else {
            peg$currPos = s4;
            s4 = peg$c2;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepath() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 49 + 4,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsetable_key();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c9;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c11(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetablearray() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 49 + 5,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s2 = peg$c7;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsetable_key();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s6 = peg$c9;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c10); }
                }
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s7 = peg$c9;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c10); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c12(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetable_key() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 6,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsedot_ended_table_key_part();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsedot_ended_table_key_part();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetable_key_part();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c13(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsetable_key_part();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c14(s1);
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetable_key_part() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 7,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsekey();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c15(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsequoted_key();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c15(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedot_ended_table_key_part() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 49 + 8,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsekey();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c17); }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsequoted_key();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c17); }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassignment() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 49 + 9,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsekey();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c18;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c19); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsevalue();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c20(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsequoted_key();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c18;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c19); }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsevalue();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c20(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsekey() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 10,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseASCII_BASIC();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseASCII_BASIC();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c21(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsequoted_key() {
      var s0, s1;

      var key    = peg$currPos * 49 + 11,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsedouble_quoted_single_line_string();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c22(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsesingle_quoted_single_line_string();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c22(s1);
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsevalue() {
      var s0;

      var key    = peg$currPos * 49 + 12,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsestring();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedatetime();
        if (s0 === peg$FAILED) {
          s0 = peg$parsefloat();
          if (s0 === peg$FAILED) {
            s0 = peg$parseinteger();
            if (s0 === peg$FAILED) {
              s0 = peg$parseboolean();
              if (s0 === peg$FAILED) {
                s0 = peg$parsearray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseinline_table();
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestring() {
      var s0;

      var key    = peg$currPos * 49 + 13,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsedouble_quoted_multiline_string();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedouble_quoted_single_line_string();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesingle_quoted_multiline_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsesingle_quoted_single_line_string();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedouble_quoted_multiline_string() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 14,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c23) {
        s1 = peg$c23;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNL();
        if (s2 === peg$FAILED) {
          s2 = peg$c25;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsemultiline_string_char();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsemultiline_string_char();
          }
          if (s3 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s4 = peg$c23;
              peg$currPos += 3;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c24); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedouble_quoted_single_line_string() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 49 + 15,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c27;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsestring_char();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsestring_char();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c27;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c26(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesingle_quoted_multiline_string() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 16,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c29) {
        s1 = peg$c29;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNL();
        if (s2 === peg$FAILED) {
          s2 = peg$c25;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsemultiline_literal_char();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsemultiline_literal_char();
          }
          if (s3 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c29) {
              s4 = peg$c29;
              peg$currPos += 3;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c30); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesingle_quoted_single_line_string() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 49 + 17,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseliteral_char();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseliteral_char();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c31;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c32); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c26(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestring_char() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 18,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseESCAPED();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 34) {
          s2 = peg$c27;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteral_char() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 19,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 39) {
        s2 = peg$c31;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c5;
      } else {
        peg$currPos = s1;
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c6); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c33(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemultiline_string_char() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 20,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseESCAPED();
      if (s0 === peg$FAILED) {
        s0 = peg$parsemultiline_string_delim();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 3) === peg$c23) {
            s2 = peg$c23;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c24); }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c34(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemultiline_string_delim() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 21,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNL();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseNLS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseNLS();
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c37();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemultiline_literal_char() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 22,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 3) === peg$c29) {
        s2 = peg$c29;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c5;
      } else {
        peg$currPos = s1;
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c6); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c33(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefloat() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 49 + 23,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsefloat_text();
      if (s1 === peg$FAILED) {
        s1 = peg$parseinteger_text();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 101) {
          s2 = peg$c38;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c39); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 69) {
            s2 = peg$c40;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c41); }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseinteger_text();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c42(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsefloat_text();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c43(s1);
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefloat_text() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 49 + 24,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c44;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c25;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseDIGITS();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c16;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c17); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseDIGITS();
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c47;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseDIGITS();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c17); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGITS();
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c49(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1;

      var key    = peg$currPos * 49 + 25,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseinteger_text();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c50(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinteger_text() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 26,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c44;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c25;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseDIGIT_OR_UNDER();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseDIGIT_OR_UNDER();
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c16;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c17); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = peg$c5;
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c46(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c47;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c17); }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = peg$c5;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c49(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseboolean() {
      var s0, s1;

      var key    = peg$currPos * 49 + 27,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c51) {
        s1 = peg$c51;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c53();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c54) {
          s1 = peg$c54;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c55); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c56();
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearray() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 28,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsearray_sep();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsearray_sep();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c9;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c57();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsearray_value();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c58(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsearray_value_list();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsearray_value_list();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c59(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_value_list();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsearray_value_list();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsearray_value();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s4 = peg$c9;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c10); }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c60(s2, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearray_value() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 29,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsearray_sep();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsearray_sep();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsevalue();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsearray_sep();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsearray_sep();
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c61(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearray_value_list() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 49 + 30,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsearray_sep();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsearray_sep();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsevalue();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsearray_sep();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsearray_sep();
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c62;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c63); }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsearray_sep();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsearray_sep();
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c61(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearray_sep() {
      var s0;

      var key    = peg$currPos * 49 + 31,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseS();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNL();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecomment();
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinline_table() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 49 + 32,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c64;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseinline_table_assignment();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseinline_table_assignment();
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c66;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c67); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c68(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinline_table_assignment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      var key    = peg$currPos * 49 + 33,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsekey();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c19); }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parsevalue();
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parseS();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseS();
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s8 = peg$c62;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c63); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = [];
                      s10 = peg$parseS();
                      while (s10 !== peg$FAILED) {
                        s9.push(s10);
                        s10 = peg$parseS();
                      }
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c69(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s4 = peg$c18;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c19); }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsevalue();
                  if (s6 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c69(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecfragment() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 34,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c16;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDIGITS();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c70(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      var key    = peg$currPos * 49 + 35,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseDIGIT_OR_UNDER();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDIGIT_OR_UNDER();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDIGIT_OR_UNDER();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseDIGIT_OR_UNDER();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s6 = peg$c47;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c48); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parseDIGIT_OR_UNDER();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDIGIT_OR_UNDER();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                      s9 = peg$c47;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c48); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseDIGIT_OR_UNDER();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseDIGIT_OR_UNDER();
                        if (s11 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c71(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetime() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      var key    = peg$currPos * 49 + 36,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseDIGIT_OR_UNDER();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDIGIT_OR_UNDER();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c72;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c73); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseDIGIT_OR_UNDER();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseDIGIT_OR_UNDER();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s7 = peg$c72;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c73); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDIGIT_OR_UNDER();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseDIGIT_OR_UNDER();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parsesecfragment();
                      if (s10 === peg$FAILED) {
                        s10 = peg$c25;
                      }
                      if (s10 !== peg$FAILED) {
                        s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                        s1 = s2;
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c74(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetime_with_offset() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;

      var key    = peg$currPos * 49 + 37,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseDIGIT_OR_UNDER();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDIGIT_OR_UNDER();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c72;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c73); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseDIGIT_OR_UNDER();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseDIGIT_OR_UNDER();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s7 = peg$c72;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c73); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDIGIT_OR_UNDER();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseDIGIT_OR_UNDER();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parsesecfragment();
                      if (s10 === peg$FAILED) {
                        s10 = peg$c25;
                      }
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                          s11 = peg$c47;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c48); }
                        }
                        if (s11 === peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 43) {
                            s11 = peg$c44;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c45); }
                          }
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parseDIGIT_OR_UNDER();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parseDIGIT_OR_UNDER();
                            if (s13 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 58) {
                                s14 = peg$c72;
                                peg$currPos++;
                              } else {
                                s14 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c73); }
                              }
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parseDIGIT_OR_UNDER();
                                if (s15 !== peg$FAILED) {
                                  s16 = peg$parseDIGIT_OR_UNDER();
                                  if (s16 !== peg$FAILED) {
                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                    s1 = s2;
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c74(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedatetime() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 49 + 38,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsedate();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 84) {
          s2 = peg$c75;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsetime();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 90) {
              s4 = peg$c77;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c78); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c79(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedate();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 84) {
            s2 = peg$c75;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c76); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetime_with_offset();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c80(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseS() {
      var s0;

      var key    = peg$currPos * 49 + 39,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c81.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c82); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNL() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 40,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c83;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c84); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 13) {
          s1 = peg$c85;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c86); }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s2 = peg$c83;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c84); }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNLS() {
      var s0;

      var key    = peg$currPos * 49 + 41,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseNL();
      if (s0 === peg$FAILED) {
        s0 = peg$parseS();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEOF() {
      var s0, s1;

      var key    = peg$currPos * 49 + 42,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = peg$c5;
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseHEX() {
      var s0;

      var key    = peg$currPos * 49 + 43,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c87.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDIGIT_OR_UNDER() {
      var s0, s1;

      var key    = peg$currPos * 49 + 44,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c89.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c90); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 95) {
          s1 = peg$c91;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c93();
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseASCII_BASIC() {
      var s0;

      var key    = peg$currPos * 49 + 45,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c94.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDIGITS() {
      var s0, s1, s2;

      var key    = peg$currPos * 49 + 46,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseDIGIT_OR_UNDER();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseDIGIT_OR_UNDER();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c96(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseESCAPED() {
      var s0, s1;

      var key    = peg$currPos * 49 + 47,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c97) {
        s1 = peg$c97;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c98); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c99();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c100) {
          s1 = peg$c100;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c102();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c104); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c105();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c106) {
              s1 = peg$c106;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c107); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c108();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c109) {
                s1 = peg$c109;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c110); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c111();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c112) {
                  s1 = peg$c112;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c113); }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c114();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c115) {
                    s1 = peg$c115;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c116); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c117();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseESCAPED_UNICODE();
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseESCAPED_UNICODE() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      var key    = peg$currPos * 49 + 48,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c118) {
        s1 = peg$c118;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c119); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseHEX();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseHEX();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseHEX();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseHEX();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseHEX();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseHEX();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseHEX();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseHEX();
                      if (s10 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c120(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c121) {
          s1 = peg$c121;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c122); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseHEX();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseHEX();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseHEX();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseHEX();
                if (s6 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c120(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }


      var nodes = [];

      function genError(err, line, col) {
        var ex = new Error(err);
        ex.line = line;
        ex.column = col;
        throw ex;
      }

      function addNode(node) {
        nodes.push(node);
      }

      function node(type, value, line, column, key) {
        var obj = { type: type, value: value, line: line(), column: column() };
        if (key) obj.key = key;
        return obj;
      }

      function convertCodePoint(str, line, col) {
        var num = parseInt("0x" + str);

        if (
          !isFinite(num) ||
          Math.floor(num) != num ||
          num < 0 ||
          num > 0x10FFFF ||
          (num > 0xD7FF && num < 0xE000)
        ) {
          genError("Invalid Unicode escape code: " + str, line, col);
        } else {
          return fromCodePoint(num);
        }
      }

      function fromCodePoint() {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return '';
        }
        var result = '';
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint);
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = (codePoint % 0x400) + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();


/***/ }),

/***/ 600:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Api: () => (/* reexport */ Api),
  FEDERATION_RESPONSE_MAX_SIZE: () => (/* reexport */ FEDERATION_RESPONSE_MAX_SIZE),
  Server: () => (/* reexport */ FederationServer)
});

// EXTERNAL MODULE: ./node_modules/@stellar/stellar-base/dist/stellar-base.min.js
var stellar_base_min = __webpack_require__(950);
// EXTERNAL MODULE: ./node_modules/urijs/src/URI.js
var URI = __webpack_require__(193);
var URI_default = /*#__PURE__*/__webpack_require__.n(URI);
// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(732);
// EXTERNAL MODULE: ./src/errors/index.ts + 5 modules
var errors = __webpack_require__(976);
// EXTERNAL MODULE: ./src/stellartoml/index.ts
var stellartoml = __webpack_require__(898);
// EXTERNAL MODULE: ./src/http-client/index.ts + 1 modules
var http_client = __webpack_require__(983);
;// ./src/federation/server.ts
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }






var FEDERATION_RESPONSE_MAX_SIZE = 100 * 1024;
var FederationServer = function () {
  function FederationServer(serverURL, domain) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, FederationServer);
    this.serverURL = URI_default()(serverURL);
    this.domain = domain;
    var allowHttp = typeof opts.allowHttp === "undefined" ? config/* Config */.T.isAllowHttp() : opts.allowHttp;
    this.timeout = typeof opts.timeout === "undefined" ? config/* Config */.T.getTimeout() : opts.timeout;
    if (this.serverURL.protocol() !== "https" && !allowHttp) {
      throw new Error("Cannot connect to insecure federation server");
    }
  }
  return _createClass(FederationServer, [{
    key: "resolveAddress",
    value: (function () {
      var _resolveAddress = _asyncToGenerator(_regenerator().m(function _callee(address) {
        var stellarAddress, url;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              stellarAddress = address;
              if (!(address.indexOf("*") < 0)) {
                _context.n = 2;
                break;
              }
              if (this.domain) {
                _context.n = 1;
                break;
              }
              return _context.a(2, Promise.reject(new Error("Unknown domain. Make sure `address` contains a domain (ex. `bob*stellar.org`) or pass `domain` parameter when instantiating the server object.")));
            case 1:
              stellarAddress = "".concat(address, "*").concat(this.domain);
            case 2:
              url = this.serverURL.query({
                type: "name",
                q: stellarAddress
              });
              return _context.a(2, this._sendRequest(url));
          }
        }, _callee, this);
      }));
      function resolveAddress(_x) {
        return _resolveAddress.apply(this, arguments);
      }
      return resolveAddress;
    }())
  }, {
    key: "resolveAccountId",
    value: (function () {
      var _resolveAccountId = _asyncToGenerator(_regenerator().m(function _callee2(accountId) {
        var url;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              url = this.serverURL.query({
                type: "id",
                q: accountId
              });
              return _context2.a(2, this._sendRequest(url));
          }
        }, _callee2, this);
      }));
      function resolveAccountId(_x2) {
        return _resolveAccountId.apply(this, arguments);
      }
      return resolveAccountId;
    }())
  }, {
    key: "resolveTransactionId",
    value: (function () {
      var _resolveTransactionId = _asyncToGenerator(_regenerator().m(function _callee3(transactionId) {
        var url;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              url = this.serverURL.query({
                type: "txid",
                q: transactionId
              });
              return _context3.a(2, this._sendRequest(url));
          }
        }, _callee3, this);
      }));
      function resolveTransactionId(_x3) {
        return _resolveTransactionId.apply(this, arguments);
      }
      return resolveTransactionId;
    }())
  }, {
    key: "_sendRequest",
    value: function () {
      var _sendRequest2 = _asyncToGenerator(_regenerator().m(function _callee4(url) {
        var timeout;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              timeout = this.timeout;
              return _context4.a(2, http_client/* httpClient */.ok.get(url.toString(), {
                maxContentLength: FEDERATION_RESPONSE_MAX_SIZE,
                timeout: timeout
              }).then(function (response) {
                if (typeof response.data.memo !== "undefined" && typeof response.data.memo !== "string") {
                  throw new Error("memo value should be of type string");
                }
                return response.data;
              }).catch(function (response) {
                if (response instanceof Error) {
                  if (response.message.match(/^maxContentLength size/)) {
                    throw new Error("federation response exceeds allowed size of ".concat(FEDERATION_RESPONSE_MAX_SIZE));
                  } else {
                    return Promise.reject(response);
                  }
                } else {
                  return Promise.reject(new errors/* BadResponseError */.nS("Server query failed. Server responded: ".concat(response.status, " ").concat(response.statusText), response.data));
                }
              }));
          }
        }, _callee4, this);
      }));
      function _sendRequest(_x4) {
        return _sendRequest2.apply(this, arguments);
      }
      return _sendRequest;
    }()
  }], [{
    key: "resolve",
    value: (function () {
      var _resolve = _asyncToGenerator(_regenerator().m(function _callee5(value) {
        var opts,
          addressParts,
          _addressParts,
          domain,
          federationServer,
          _args5 = arguments;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
              if (!(value.indexOf("*") < 0)) {
                _context5.n = 2;
                break;
              }
              if (stellar_base_min.StrKey.isValidEd25519PublicKey(value)) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2, Promise.reject(new Error("Invalid Account ID")));
            case 1:
              return _context5.a(2, Promise.resolve({
                account_id: value
              }));
            case 2:
              addressParts = value.split("*");
              _addressParts = _slicedToArray(addressParts, 2), domain = _addressParts[1];
              if (!(addressParts.length !== 2 || !domain)) {
                _context5.n = 3;
                break;
              }
              return _context5.a(2, Promise.reject(new Error("Invalid Stellar address")));
            case 3:
              _context5.n = 4;
              return FederationServer.createForDomain(domain, opts);
            case 4:
              federationServer = _context5.v;
              return _context5.a(2, federationServer.resolveAddress(value));
          }
        }, _callee5);
      }));
      function resolve(_x5) {
        return _resolve.apply(this, arguments);
      }
      return resolve;
    }())
  }, {
    key: "createForDomain",
    value: (function () {
      var _createForDomain = _asyncToGenerator(_regenerator().m(function _callee6(domain) {
        var opts,
          tomlObject,
          _args6 = arguments;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
              _context6.n = 1;
              return stellartoml.Resolver.resolve(domain, opts);
            case 1:
              tomlObject = _context6.v;
              if (tomlObject.FEDERATION_SERVER) {
                _context6.n = 2;
                break;
              }
              return _context6.a(2, Promise.reject(new Error("stellar.toml does not contain FEDERATION_SERVER field")));
            case 2:
              return _context6.a(2, new FederationServer(tomlObject.FEDERATION_SERVER, domain, opts));
          }
        }, _callee6);
      }));
      function createForDomain(_x6) {
        return _createForDomain.apply(this, arguments);
      }
      return createForDomain;
    }())
  }]);
}();
;// ./src/federation/api.ts
var Api;
;// ./src/federation/index.ts



/***/ }),

/***/ 680:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ assembleTransaction)
/* harmony export */ });
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(950);
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
/* harmony import */ var _parsers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(784);



function isSorobanTransaction(tx) {
  if (tx.operations.length !== 1) {
    return false;
  }
  switch (tx.operations[0].type) {
    case 'invokeHostFunction':
    case 'extendFootprintTtl':
    case 'restoreFootprint':
      return true;
    default:
      return false;
  }
}
function assembleTransaction(raw, simulation) {
  if ('innerTransaction' in raw) {
    return assembleTransaction(raw.innerTransaction, simulation);
  }
  if (!isSorobanTransaction(raw)) {
    throw new TypeError('unsupported transaction: must contain exactly one ' + 'invokeHostFunction, extendFootprintTtl, or restoreFootprint ' + 'operation');
  }
  var success = (0,_parsers__WEBPACK_IMPORTED_MODULE_2__/* .parseRawSimulation */ .jr)(simulation);
  if (!_api__WEBPACK_IMPORTED_MODULE_1__/* .Api */ .j.isSimulationSuccess(success)) {
    throw new Error("simulation incorrect: ".concat(JSON.stringify(success)));
  }
  var classicFeeNum = parseInt(raw.fee) || 0;
  var minResourceFeeNum = parseInt(success.minResourceFee) || 0;
  var txnBuilder = _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.TransactionBuilder.cloneFrom(raw, {
    fee: (classicFeeNum + minResourceFeeNum).toString(),
    sorobanData: success.transactionData.build(),
    networkPassphrase: raw.networkPassphrase
  });
  if (raw.operations[0].type === 'invokeHostFunction') {
    var _invokeOp$auth;
    txnBuilder.clearOperations();
    var invokeOp = raw.operations[0];
    var existingAuth = (_invokeOp$auth = invokeOp.auth) !== null && _invokeOp$auth !== void 0 ? _invokeOp$auth : [];
    txnBuilder.addOperation(_stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.Operation.invokeHostFunction({
      source: invokeOp.source,
      func: invokeOp.func,
      auth: existingAuth.length > 0 ? existingAuth : success.result.auth
    }));
  }
  return txnBuilder;
}

/***/ }),

/***/ 704:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */

(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if ( true && module.exports) {
    // Node
    module.exports = factory();
  } else if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else // removed by dead control flow
{}
}(this, function (root) {
  'use strict';

  // save current SecondLevelDomains variable, if any
  var _SecondLevelDomains = root && root.SecondLevelDomains;

  var SLD = {
    // list of known Second Level Domains
    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
    // ----
    // publicsuffix.org is more current and actually used by a couple of browsers internally.
    // downside is it also contains domains like "dyndns.org" - which is fine for the security
    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
    // ----
    list: {
      'ac':' com gov mil net org ',
      'ae':' ac co gov mil name net org pro sch ',
      'af':' com edu gov net org ',
      'al':' com edu gov mil net org ',
      'ao':' co ed gv it og pb ',
      'ar':' com edu gob gov int mil net org tur ',
      'at':' ac co gv or ',
      'au':' asn com csiro edu gov id net org ',
      'ba':' co com edu gov mil net org rs unbi unmo unsa untz unze ',
      'bb':' biz co com edu gov info net org store tv ',
      'bh':' biz cc com edu gov info net org ',
      'bn':' com edu gov net org ',
      'bo':' com edu gob gov int mil net org tv ',
      'br':' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
      'bs':' com edu gov net org ',
      'bz':' du et om ov rg ',
      'ca':' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
      'ck':' biz co edu gen gov info net org ',
      'cn':' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
      'co':' com edu gov mil net nom org ',
      'cr':' ac c co ed fi go or sa ',
      'cy':' ac biz com ekloges gov ltd name net org parliament press pro tm ',
      'do':' art com edu gob gov mil net org sld web ',
      'dz':' art asso com edu gov net org pol ',
      'ec':' com edu fin gov info med mil net org pro ',
      'eg':' com edu eun gov mil name net org sci ',
      'er':' com edu gov ind mil net org rochest w ',
      'es':' com edu gob nom org ',
      'et':' biz com edu gov info name net org ',
      'fj':' ac biz com info mil name net org pro ',
      'fk':' ac co gov net nom org ',
      'fr':' asso com f gouv nom prd presse tm ',
      'gg':' co net org ',
      'gh':' com edu gov mil org ',
      'gn':' ac com gov net org ',
      'gr':' com edu gov mil net org ',
      'gt':' com edu gob ind mil net org ',
      'gu':' com edu gov net org ',
      'hk':' com edu gov idv net org ',
      'hu':' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
      'id':' ac co go mil net or sch web ',
      'il':' ac co gov idf k12 muni net org ',
      'in':' ac co edu ernet firm gen gov i ind mil net nic org res ',
      'iq':' com edu gov i mil net org ',
      'ir':' ac co dnssec gov i id net org sch ',
      'it':' edu gov ',
      'je':' co net org ',
      'jo':' com edu gov mil name net org sch ',
      'jp':' ac ad co ed go gr lg ne or ',
      'ke':' ac co go info me mobi ne or sc ',
      'kh':' com edu gov mil net org per ',
      'ki':' biz com de edu gov info mob net org tel ',
      'km':' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
      'kn':' edu gov net org ',
      'kr':' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
      'kw':' com edu gov net org ',
      'ky':' com edu gov net org ',
      'kz':' com edu gov mil net org ',
      'lb':' com edu gov net org ',
      'lk':' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
      'lr':' com edu gov net org ',
      'lv':' asn com conf edu gov id mil net org ',
      'ly':' com edu gov id med net org plc sch ',
      'ma':' ac co gov m net org press ',
      'mc':' asso tm ',
      'me':' ac co edu gov its net org priv ',
      'mg':' com edu gov mil nom org prd tm ',
      'mk':' com edu gov inf name net org pro ',
      'ml':' com edu gov net org presse ',
      'mn':' edu gov org ',
      'mo':' com edu gov net org ',
      'mt':' com edu gov net org ',
      'mv':' aero biz com coop edu gov info int mil museum name net org pro ',
      'mw':' ac co com coop edu gov int museum net org ',
      'mx':' com edu gob net org ',
      'my':' com edu gov mil name net org sch ',
      'nf':' arts com firm info net other per rec store web ',
      'ng':' biz com edu gov mil mobi name net org sch ',
      'ni':' ac co com edu gob mil net nom org ',
      'np':' com edu gov mil net org ',
      'nr':' biz com edu gov info net org ',
      'om':' ac biz co com edu gov med mil museum net org pro sch ',
      'pe':' com edu gob mil net nom org sld ',
      'ph':' com edu gov i mil net ngo org ',
      'pk':' biz com edu fam gob gok gon gop gos gov net org web ',
      'pl':' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
      'pr':' ac biz com edu est gov info isla name net org pro prof ',
      'ps':' com edu gov net org plo sec ',
      'pw':' belau co ed go ne or ',
      'ro':' arts com firm info nom nt org rec store tm www ',
      'rs':' ac co edu gov in org ',
      'sb':' com edu gov net org ',
      'sc':' com edu gov net org ',
      'sh':' co com edu gov net nom org ',
      'sl':' com edu gov net org ',
      'st':' co com consulado edu embaixada gov mil net org principe saotome store ',
      'sv':' com edu gob org red ',
      'sz':' ac co org ',
      'tr':' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
      'tt':' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
      'tw':' club com ebiz edu game gov idv mil net org ',
      'mu':' ac co com gov net or org ',
      'mz':' ac co edu gov org ',
      'na':' co com ',
      'nz':' ac co cri geek gen govt health iwi maori mil net org parliament school ',
      'pa':' abo ac com edu gob ing med net nom org sld ',
      'pt':' com edu gov int net nome org publ ',
      'py':' com edu gov mil net org ',
      'qa':' com edu gov mil net org ',
      're':' asso com nom ',
      'ru':' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
      'rw':' ac co com edu gouv gov int mil net ',
      'sa':' com edu gov med net org pub sch ',
      'sd':' com edu gov info med net org tv ',
      'se':' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
      'sg':' com edu gov idn net org per ',
      'sn':' art com edu gouv org perso univ ',
      'sy':' com edu gov mil net news org ',
      'th':' ac co go in mi net or ',
      'tj':' ac biz co com edu go gov info int mil name net nic org test web ',
      'tn':' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
      'tz':' ac co go ne or ',
      'ua':' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
      'ug':' ac co go ne or org sc ',
      'uk':' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
      'us':' dni fed isa kids nsn ',
      'uy':' com edu gub mil net org ',
      've':' co com edu gob info mil net org web ',
      'vi':' co com k12 net org ',
      'vn':' ac biz com edu gov health info int name net org pro ',
      'ye':' co com gov ltd me net org plc ',
      'yu':' ac co edu gov org ',
      'za':' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
      'zm':' ac co com edu gov net org sch ',
      // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
      'com': 'ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ',
      'net': 'gb jp se uk ',
      'org': 'ae',
      'de': 'com '
    },
    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
    // in both performance and memory footprint. No initialization required.
    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
    // Following methods use lastIndexOf() rather than array.split() in order
    // to avoid any memory allocations.
    has: function(domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
        return false;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
        return false;
      }
      var sldList = SLD.list[domain.slice(tldOffset+1)];
      if (!sldList) {
        return false;
      }
      return sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') >= 0;
    },
    is: function(domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
        return false;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
      if (sldOffset >= 0) {
        return false;
      }
      var sldList = SLD.list[domain.slice(tldOffset+1)];
      if (!sldList) {
        return false;
      }
      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
    },
    get: function(domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
        return null;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
        return null;
      }
      var sldList = SLD.list[domain.slice(tldOffset+1)];
      if (!sldList) {
        return null;
      }
      if (sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') < 0) {
        return null;
      }
      return domain.slice(sldOffset+1);
    },
    noConflict: function(){
      if (root.SecondLevelDomains === this) {
        root.SecondLevelDomains = _SecondLevelDomains;
      }
      return this;
    }
  };

  return SLD;
}));


/***/ }),

/***/ 708:
/***/ ((module) => {

"use strict";

function compile(nodes) {
  var assignedPaths = [];
  var valueAssignments = [];
  var currentPath = "";
  var data = Object.create(null);
  var context = data;
  var arrayMode = false;

  return reduce(nodes);

  function reduce(nodes) {
    var node;
    for (var i = 0; i < nodes.length; i++) {
      node = nodes[i];
      switch (node.type) {
      case "Assign":
        assign(node);
        break;
      case "ObjectPath":
        setPath(node);
        break;
      case "ArrayPath":
        addTableArray(node);
        break;
      }
    }

    return data;
  }

  function genError(err, line, col) {
    var ex = new Error(err);
    ex.line = line;
    ex.column = col;
    throw ex;
  }

  function assign(node) {
    var key = node.key;
    var value = node.value;
    var line = node.line;
    var column = node.column;

    var fullPath;
    if (currentPath) {
      fullPath = currentPath + "." + key;
    } else {
      fullPath = key;
    }
    if (typeof context[key] !== "undefined") {
      genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
    }

    context[key] = reduceValueNode(value);

    if (!pathAssigned(fullPath)) {
      assignedPaths.push(fullPath);
      valueAssignments.push(fullPath);
    }
  }


  function pathAssigned(path) {
    return assignedPaths.indexOf(path) !== -1;
  }

  function reduceValueNode(node) {
    if (node.type === "Array") {
      return reduceArrayWithTypeChecking(node.value);
    } else if (node.type === "InlineTable") {
      return reduceInlineTableNode(node.value);
    } else {
      return node.value;
    }
  }

  function reduceInlineTableNode(values) {
    var obj = Object.create(null);
    for (var i = 0; i < values.length; i++) {
      var val = values[i];
      if (val.value.type === "InlineTable") {
        obj[val.key] = reduceInlineTableNode(val.value.value);
      } else if (val.type === "InlineTableValue") {
        obj[val.key] = reduceValueNode(val.value);
      }
    }

    return obj;
  }

  function setPath(node) {
    var path = node.value;
    var quotedPath = path.map(quoteDottedString).join(".");
    var line = node.line;
    var column = node.column;

    if (pathAssigned(quotedPath)) {
      genError("Cannot redefine existing key '" + path + "'.", line, column);
    }
    assignedPaths.push(quotedPath);
    context = deepRef(data, path, Object.create(null), line, column);
    currentPath = path;
  }

  function addTableArray(node) {
    var path = node.value;
    var quotedPath = path.map(quoteDottedString).join(".");
    var line = node.line;
    var column = node.column;

    if (!pathAssigned(quotedPath)) {
      assignedPaths.push(quotedPath);
    }
    assignedPaths = assignedPaths.filter(function(p) {
      return p.indexOf(quotedPath) !== 0;
    });
    assignedPaths.push(quotedPath);
    context = deepRef(data, path, [], line, column);
    currentPath = quotedPath;

    if (context instanceof Array) {
      var newObj = Object.create(null);
      context.push(newObj);
      context = newObj;
    } else {
      genError("Cannot redefine existing key '" + path + "'.", line, column);
    }
  }

  // Given a path 'a.b.c', create (as necessary) `start.a`,
  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.
  // If `a` or `b` are arrays and have items in them, the last item in the
  // array is used as the context for the next sub-path.
  function deepRef(start, keys, value, line, column) {
    var traversed = [];
    var traversedPath = "";
    var path = keys.join(".");
    var ctx = start;

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      traversed.push(key);
      traversedPath = traversed.join(".");
      if (typeof ctx[key] === "undefined") {
        if (i === keys.length - 1) {
          ctx[key] = value;
        } else {
          ctx[key] = Object.create(null);
        }
      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
        // already a non-object value at key, can't be used as part of a new path
        genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
      }

      ctx = ctx[key];
      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {
        ctx = ctx[ctx.length - 1];
      }
    }

    return ctx;
  }

  function reduceArrayWithTypeChecking(array) {
    // Ensure that all items in the array are of the same type
    var firstType = null;
    for (var i = 0; i < array.length; i++) {
      var node = array[i];
      if (firstType === null) {
        firstType = node.type;
      } else {
        if (node.type !== firstType) {
          genError("Cannot add value of type " + node.type + " to array of type " +
            firstType + ".", node.line, node.column);
        }
      }
    }

    // Recursively reduce array of nodes into array of the nodes' values
    return array.map(reduceValueNode);
  }

  function quoteDottedString(str) {
    if (str.indexOf(".") > -1) {
      return "\"" + str + "\"";
    } else {
      return str;
    }
  }
}

module.exports = {
  compile: compile
};


/***/ }),

/***/ 732:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ Config)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var defaultConfig = {
  allowHttp: false,
  timeout: 0
};
var config = _objectSpread({}, defaultConfig);
var Config = function () {
  function Config() {
    _classCallCheck(this, Config);
  }
  return _createClass(Config, null, [{
    key: "setAllowHttp",
    value: function setAllowHttp(value) {
      config.allowHttp = value;
    }
  }, {
    key: "setTimeout",
    value: function setTimeout(value) {
      config.timeout = value;
    }
  }, {
    key: "isAllowHttp",
    value: function isAllowHttp() {
      return config.allowHttp;
    }
  }, {
    key: "getTimeout",
    value: function getTimeout() {
      return config.timeout;
    }
  }, {
    key: "setDefault",
    value: function setDefault() {
      config = _objectSpread({}, defaultConfig);
    }
  }]);
}();


/***/ }),

/***/ 733:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AccountResponse: () => (/* reexport */ AccountResponse),
  AxiosClient: () => (/* reexport */ horizon_axios_client),
  HorizonApi: () => (/* reexport */ HorizonApi),
  SERVER_TIME_MAP: () => (/* reexport */ SERVER_TIME_MAP),
  Server: () => (/* reexport */ HorizonServer),
  ServerApi: () => (/* reexport */ ServerApi),
  "default": () => (/* binding */ horizon),
  getCurrentServerTime: () => (/* reexport */ getCurrentServerTime)
});

;// ./src/horizon/horizon_api.ts
var HorizonApi;
(function (_HorizonApi) {
  var LiquidityPoolType = function (LiquidityPoolType) {
    LiquidityPoolType["constantProduct"] = "constant_product";
    return LiquidityPoolType;
  }({});
  _HorizonApi.LiquidityPoolType = LiquidityPoolType;
  var OperationResponseType = function (OperationResponseType) {
    OperationResponseType["createAccount"] = "create_account";
    OperationResponseType["payment"] = "payment";
    OperationResponseType["pathPayment"] = "path_payment_strict_receive";
    OperationResponseType["createPassiveOffer"] = "create_passive_sell_offer";
    OperationResponseType["manageOffer"] = "manage_sell_offer";
    OperationResponseType["setOptions"] = "set_options";
    OperationResponseType["changeTrust"] = "change_trust";
    OperationResponseType["allowTrust"] = "allow_trust";
    OperationResponseType["accountMerge"] = "account_merge";
    OperationResponseType["inflation"] = "inflation";
    OperationResponseType["manageData"] = "manage_data";
    OperationResponseType["bumpSequence"] = "bump_sequence";
    OperationResponseType["manageBuyOffer"] = "manage_buy_offer";
    OperationResponseType["pathPaymentStrictSend"] = "path_payment_strict_send";
    OperationResponseType["createClaimableBalance"] = "create_claimable_balance";
    OperationResponseType["claimClaimableBalance"] = "claim_claimable_balance";
    OperationResponseType["beginSponsoringFutureReserves"] = "begin_sponsoring_future_reserves";
    OperationResponseType["endSponsoringFutureReserves"] = "end_sponsoring_future_reserves";
    OperationResponseType["revokeSponsorship"] = "revoke_sponsorship";
    OperationResponseType["clawback"] = "clawback";
    OperationResponseType["clawbackClaimableBalance"] = "clawback_claimable_balance";
    OperationResponseType["setTrustLineFlags"] = "set_trust_line_flags";
    OperationResponseType["liquidityPoolDeposit"] = "liquidity_pool_deposit";
    OperationResponseType["liquidityPoolWithdraw"] = "liquidity_pool_withdraw";
    OperationResponseType["invokeHostFunction"] = "invoke_host_function";
    OperationResponseType["bumpFootprintExpiration"] = "bump_footprint_expiration";
    OperationResponseType["restoreFootprint"] = "restore_footprint";
    return OperationResponseType;
  }({});
  _HorizonApi.OperationResponseType = OperationResponseType;
  var OperationResponseTypeI = function (OperationResponseTypeI) {
    OperationResponseTypeI[OperationResponseTypeI["createAccount"] = 0] = "createAccount";
    OperationResponseTypeI[OperationResponseTypeI["payment"] = 1] = "payment";
    OperationResponseTypeI[OperationResponseTypeI["pathPayment"] = 2] = "pathPayment";
    OperationResponseTypeI[OperationResponseTypeI["createPassiveOffer"] = 3] = "createPassiveOffer";
    OperationResponseTypeI[OperationResponseTypeI["manageOffer"] = 4] = "manageOffer";
    OperationResponseTypeI[OperationResponseTypeI["setOptions"] = 5] = "setOptions";
    OperationResponseTypeI[OperationResponseTypeI["changeTrust"] = 6] = "changeTrust";
    OperationResponseTypeI[OperationResponseTypeI["allowTrust"] = 7] = "allowTrust";
    OperationResponseTypeI[OperationResponseTypeI["accountMerge"] = 8] = "accountMerge";
    OperationResponseTypeI[OperationResponseTypeI["inflation"] = 9] = "inflation";
    OperationResponseTypeI[OperationResponseTypeI["manageData"] = 10] = "manageData";
    OperationResponseTypeI[OperationResponseTypeI["bumpSequence"] = 11] = "bumpSequence";
    OperationResponseTypeI[OperationResponseTypeI["manageBuyOffer"] = 12] = "manageBuyOffer";
    OperationResponseTypeI[OperationResponseTypeI["pathPaymentStrictSend"] = 13] = "pathPaymentStrictSend";
    OperationResponseTypeI[OperationResponseTypeI["createClaimableBalance"] = 14] = "createClaimableBalance";
    OperationResponseTypeI[OperationResponseTypeI["claimClaimableBalance"] = 15] = "claimClaimableBalance";
    OperationResponseTypeI[OperationResponseTypeI["beginSponsoringFutureReserves"] = 16] = "beginSponsoringFutureReserves";
    OperationResponseTypeI[OperationResponseTypeI["endSponsoringFutureReserves"] = 17] = "endSponsoringFutureReserves";
    OperationResponseTypeI[OperationResponseTypeI["revokeSponsorship"] = 18] = "revokeSponsorship";
    OperationResponseTypeI[OperationResponseTypeI["clawback"] = 19] = "clawback";
    OperationResponseTypeI[OperationResponseTypeI["clawbackClaimableBalance"] = 20] = "clawbackClaimableBalance";
    OperationResponseTypeI[OperationResponseTypeI["setTrustLineFlags"] = 21] = "setTrustLineFlags";
    OperationResponseTypeI[OperationResponseTypeI["liquidityPoolDeposit"] = 22] = "liquidityPoolDeposit";
    OperationResponseTypeI[OperationResponseTypeI["liquidityPoolWithdraw"] = 23] = "liquidityPoolWithdraw";
    OperationResponseTypeI[OperationResponseTypeI["invokeHostFunction"] = 24] = "invokeHostFunction";
    OperationResponseTypeI[OperationResponseTypeI["bumpFootprintExpiration"] = 25] = "bumpFootprintExpiration";
    OperationResponseTypeI[OperationResponseTypeI["restoreFootprint"] = 26] = "restoreFootprint";
    return OperationResponseTypeI;
  }({});
  _HorizonApi.OperationResponseTypeI = OperationResponseTypeI;
  ;
  var TransactionFailedResultCodes = function (TransactionFailedResultCodes) {
    TransactionFailedResultCodes["TX_FAILED"] = "tx_failed";
    TransactionFailedResultCodes["TX_BAD_SEQ"] = "tx_bad_seq";
    TransactionFailedResultCodes["TX_BAD_AUTH"] = "tx_bad_auth";
    TransactionFailedResultCodes["TX_BAD_AUTH_EXTRA"] = "tx_bad_auth_extra";
    TransactionFailedResultCodes["TX_FEE_BUMP_INNER_SUCCESS"] = "tx_fee_bump_inner_success";
    TransactionFailedResultCodes["TX_FEE_BUMP_INNER_FAILED"] = "tx_fee_bump_inner_failed";
    TransactionFailedResultCodes["TX_NOT_SUPPORTED"] = "tx_not_supported";
    TransactionFailedResultCodes["TX_SUCCESS"] = "tx_success";
    TransactionFailedResultCodes["TX_TOO_EARLY"] = "tx_too_early";
    TransactionFailedResultCodes["TX_TOO_LATE"] = "tx_too_late";
    TransactionFailedResultCodes["TX_MISSING_OPERATION"] = "tx_missing_operation";
    TransactionFailedResultCodes["TX_INSUFFICIENT_BALANCE"] = "tx_insufficient_balance";
    TransactionFailedResultCodes["TX_NO_SOURCE_ACCOUNT"] = "tx_no_source_account";
    TransactionFailedResultCodes["TX_INSUFFICIENT_FEE"] = "tx_insufficient_fee";
    TransactionFailedResultCodes["TX_INTERNAL_ERROR"] = "tx_internal_error";
    return TransactionFailedResultCodes;
  }({});
  _HorizonApi.TransactionFailedResultCodes = TransactionFailedResultCodes;
})(HorizonApi || (HorizonApi = {}));
;// ./src/horizon/types/effects.ts
var effects_EffectType = function (EffectType) {
  EffectType[EffectType["account_created"] = 0] = "account_created";
  EffectType[EffectType["account_removed"] = 1] = "account_removed";
  EffectType[EffectType["account_credited"] = 2] = "account_credited";
  EffectType[EffectType["account_debited"] = 3] = "account_debited";
  EffectType[EffectType["account_thresholds_updated"] = 4] = "account_thresholds_updated";
  EffectType[EffectType["account_home_domain_updated"] = 5] = "account_home_domain_updated";
  EffectType[EffectType["account_flags_updated"] = 6] = "account_flags_updated";
  EffectType[EffectType["account_inflation_destination_updated"] = 7] = "account_inflation_destination_updated";
  EffectType[EffectType["signer_created"] = 10] = "signer_created";
  EffectType[EffectType["signer_removed"] = 11] = "signer_removed";
  EffectType[EffectType["signer_updated"] = 12] = "signer_updated";
  EffectType[EffectType["trustline_created"] = 20] = "trustline_created";
  EffectType[EffectType["trustline_removed"] = 21] = "trustline_removed";
  EffectType[EffectType["trustline_updated"] = 22] = "trustline_updated";
  EffectType[EffectType["trustline_authorized"] = 23] = "trustline_authorized";
  EffectType[EffectType["trustline_deauthorized"] = 24] = "trustline_deauthorized";
  EffectType[EffectType["trustline_authorized_to_maintain_liabilities"] = 25] = "trustline_authorized_to_maintain_liabilities";
  EffectType[EffectType["trustline_flags_updated"] = 26] = "trustline_flags_updated";
  EffectType[EffectType["offer_created"] = 30] = "offer_created";
  EffectType[EffectType["offer_removed"] = 31] = "offer_removed";
  EffectType[EffectType["offer_updated"] = 32] = "offer_updated";
  EffectType[EffectType["trade"] = 33] = "trade";
  EffectType[EffectType["data_created"] = 40] = "data_created";
  EffectType[EffectType["data_removed"] = 41] = "data_removed";
  EffectType[EffectType["data_updated"] = 42] = "data_updated";
  EffectType[EffectType["sequence_bumped"] = 43] = "sequence_bumped";
  EffectType[EffectType["claimable_balance_created"] = 50] = "claimable_balance_created";
  EffectType[EffectType["claimable_balance_claimant_created"] = 51] = "claimable_balance_claimant_created";
  EffectType[EffectType["claimable_balance_claimed"] = 52] = "claimable_balance_claimed";
  EffectType[EffectType["account_sponsorship_created"] = 60] = "account_sponsorship_created";
  EffectType[EffectType["account_sponsorship_updated"] = 61] = "account_sponsorship_updated";
  EffectType[EffectType["account_sponsorship_removed"] = 62] = "account_sponsorship_removed";
  EffectType[EffectType["trustline_sponsorship_created"] = 63] = "trustline_sponsorship_created";
  EffectType[EffectType["trustline_sponsorship_updated"] = 64] = "trustline_sponsorship_updated";
  EffectType[EffectType["trustline_sponsorship_removed"] = 65] = "trustline_sponsorship_removed";
  EffectType[EffectType["data_sponsorship_created"] = 66] = "data_sponsorship_created";
  EffectType[EffectType["data_sponsorship_updated"] = 67] = "data_sponsorship_updated";
  EffectType[EffectType["data_sponsorship_removed"] = 68] = "data_sponsorship_removed";
  EffectType[EffectType["claimable_balance_sponsorship_created"] = 69] = "claimable_balance_sponsorship_created";
  EffectType[EffectType["claimable_balance_sponsorship_updated"] = 70] = "claimable_balance_sponsorship_updated";
  EffectType[EffectType["claimable_balance_sponsorship_removed"] = 71] = "claimable_balance_sponsorship_removed";
  EffectType[EffectType["signer_sponsorship_created"] = 72] = "signer_sponsorship_created";
  EffectType[EffectType["signer_sponsorship_updated"] = 73] = "signer_sponsorship_updated";
  EffectType[EffectType["signer_sponsorship_removed"] = 74] = "signer_sponsorship_removed";
  EffectType[EffectType["claimable_balance_clawed_back"] = 80] = "claimable_balance_clawed_back";
  EffectType[EffectType["liquidity_pool_deposited"] = 90] = "liquidity_pool_deposited";
  EffectType[EffectType["liquidity_pool_withdrew"] = 91] = "liquidity_pool_withdrew";
  EffectType[EffectType["liquidity_pool_trade"] = 92] = "liquidity_pool_trade";
  EffectType[EffectType["liquidity_pool_created"] = 93] = "liquidity_pool_created";
  EffectType[EffectType["liquidity_pool_removed"] = 94] = "liquidity_pool_removed";
  EffectType[EffectType["liquidity_pool_revoked"] = 95] = "liquidity_pool_revoked";
  EffectType[EffectType["contract_credited"] = 96] = "contract_credited";
  EffectType[EffectType["contract_debited"] = 97] = "contract_debited";
  return EffectType;
}({});
;// ./src/horizon/server_api.ts


var ServerApi;
(function (_ServerApi) {
  var EffectType = _ServerApi.EffectType = effects_EffectType;
  var TradeType = function (TradeType) {
    TradeType["all"] = "all";
    TradeType["liquidityPools"] = "liquidity_pool";
    TradeType["orderbook"] = "orderbook";
    return TradeType;
  }({});
  _ServerApi.TradeType = TradeType;
  var OperationResponseType = HorizonApi.OperationResponseType;
  var OperationResponseTypeI = HorizonApi.OperationResponseTypeI;
})(ServerApi || (ServerApi = {}));
// EXTERNAL MODULE: ./node_modules/@stellar/stellar-base/dist/stellar-base.min.js
var stellar_base_min = __webpack_require__(950);
;// ./src/horizon/account_response.ts
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var AccountResponse = function () {
  function AccountResponse(response) {
    var _this = this;
    _classCallCheck(this, AccountResponse);
    this._baseAccount = new stellar_base_min.Account(response.account_id, response.sequence);
    Object.entries(response).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      _this[key] = value;
    });
  }
  return _createClass(AccountResponse, [{
    key: "accountId",
    value: function accountId() {
      return this._baseAccount.accountId();
    }
  }, {
    key: "sequenceNumber",
    value: function sequenceNumber() {
      return this._baseAccount.sequenceNumber();
    }
  }, {
    key: "incrementSequenceNumber",
    value: function incrementSequenceNumber() {
      this._baseAccount.incrementSequenceNumber();
      this.sequence = this._baseAccount.sequenceNumber();
    }
  }]);
}();
;// ./node_modules/bignumber.js/bignumber.mjs
/*
 *      bignumber.js v9.3.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


var
  isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
  mathceil = Math.ceil,
  mathfloor = Math.floor,

  bignumberError = '[BigNumber Error] ',
  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

  BASE = 1e14,
  LOG_BASE = 14,
  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  SQRT_BASE = 1e7,

  // EDITABLE
  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
  // the arguments to toExponential, toFixed, toFormat, and toPrecision.
  MAX = 1E9;                                   // 0 to MAX_INT32


/*
 * Create and return a BigNumber constructor.
 */
function clone(configObject) {
  var div, convertBase, parseNumeric,
    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
    ONE = new BigNumber(1),


    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


    // The default values below must be integers within the inclusive ranges stated.
    // The values can also be changed at run-time using BigNumber.set.

    // The maximum number of decimal places for operations involving division.
    DECIMAL_PLACES = 20,                     // 0 to MAX

    // The rounding mode used when rounding to the above decimal places, and when using
    // toExponential, toFixed, toFormat and toPrecision, and round (default value).
    // UP         0 Away from zero.
    // DOWN       1 Towards zero.
    // CEIL       2 Towards +Infinity.
    // FLOOR      3 Towards -Infinity.
    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    ROUNDING_MODE = 4,                       // 0 to 8

    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

    // The exponent value at and beneath which toString returns exponential notation.
    // Number type: -7
    TO_EXP_NEG = -7,                         // 0 to -MAX

    // The exponent value at and above which toString returns exponential notation.
    // Number type: 21
    TO_EXP_POS = 21,                         // 0 to MAX

    // RANGE : [MIN_EXP, MAX_EXP]

    // The minimum exponent value, beneath which underflow to zero occurs.
    // Number type: -324  (5e-324)
    MIN_EXP = -1e7,                          // -1 to -MAX

    // The maximum exponent value, above which overflow to Infinity occurs.
    // Number type:  308  (1.7976931348623157e+308)
    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
    MAX_EXP = 1e7,                           // 1 to MAX

    // Whether to use cryptographically-secure random number generation, if available.
    CRYPTO = false,                          // true or false

    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP        0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN      1 The remainder has the same sign as the dividend.
    //             This modulo mode is commonly known as 'truncated division' and is
    //             equivalent to (a % n) in JavaScript.
    // FLOOR     3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
    //             The remainder is always positive.
    //
    // The truncated division, floored division, Euclidian division and IEEE 754 remainder
    // modes are commonly used for the modulus operation.
    // Although the other rounding modes can also be used, they may not give useful results.
    MODULO_MODE = 1,                         // 0 to 9

    // The maximum number of significant digits of the result of the exponentiatedBy operation.
    // If POW_PRECISION is 0, there will be unlimited significant digits.
    POW_PRECISION = 0,                       // 0 to MAX

    // The format specification used by the BigNumber.prototype.toFormat method.
    FORMAT = {
      prefix: '',
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ',',
      decimalSeparator: '.',
      fractionGroupSize: 0,
      fractionGroupSeparator: '\xA0',        // non-breaking space
      suffix: ''
    },

    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
    // '-', '.', whitespace, or repeated character.
    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
    alphabetHasNormalDecimalDigits = true;


  //------------------------------------------------------------------------------------------


  // CONSTRUCTOR


  /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */
  function BigNumber(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str,
      x = this;

    // Enable constructor call without `new`.
    if (!(x instanceof BigNumber)) return new BigNumber(v, b);

    if (b == null) {

      if (v && v._isBigNumber === true) {
        x.s = v.s;

        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }

        return;
      }

      if ((isNum = typeof v == 'number') && v * 0 == 0) {

        // Use `1 / n` to handle minus zero also.
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;

        // Fast path for integers, where n < 2147483648 (2**31).
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++);

          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }

          return;
        }

        str = String(v);
      } else {

        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

      // Exponential form?
      if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {

        // Integer.
        e = str.length;
      }

    } else {

      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
      intCheck(b, 2, ALPHABET.length, 'Base');

      // Allow exponential notation to be used with base 10 argument, while
      // also rounding to DECIMAL_PLACES as with other bases.
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }

      str = String(v);

      if (isNum = typeof v == 'number') {

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
          throw Error
           (tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }

      alphabet = ALPHABET.slice(0, b);
      e = i = 0;

      // Check that str is a valid base b number.
      // Don't use RegExp, so alphabet can contain special characters.
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == '.') {

            // If '.' is not the first character and it has not be found before.
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {

            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }

          return parseNumeric(x, String(v), isNum, b);
        }
      }

      // Prevent later check for length on converted number.
      isNum = false;
      str = convertBase(str, b, 10, x.s);

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
      else e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(--len) === 48;);

    if (str = str.slice(i, ++len)) {
      len -= i;

      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
      if (isNum && BigNumber.DEBUG &&
        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error
           (tooManyDigits + (x.s * v));
      }

       // Overflow?
      if ((e = e - i - 1) > MAX_EXP) {

        // Infinity.
        x.c = x.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first element of the coefficient array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;  // i < 1

        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));

          for (len -= LOG_BASE; i < len;) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }

          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }

        for (; i--; str += '0');
        x.c.push(+str);
      }
    } else {

      // Zero.
      x.c = [x.e = 0];
    }
  }


  // CONSTRUCTOR PROPERTIES


  BigNumber.clone = clone;

  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;


  /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                       not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */
  BigNumber.config = BigNumber.set = function (obj) {
    var p, v;

    if (obj != null) {

      if (typeof obj == 'object') {

        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }

        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }

        // EXPONENTIAL_AT {number|number[]}
        // Integer, -MAX to MAX inclusive or
        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }

        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
        if (obj.hasOwnProperty(p = 'RANGE')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error
               (bignumberError + p + ' cannot be zero: ' + v);
            }
          }
        }

        // CRYPTO {boolean} true or false.
        // '[BigNumber Error] CRYPTO not true or false: {v}'
        // '[BigNumber Error] crypto unavailable'
        if (obj.hasOwnProperty(p = 'CRYPTO')) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto &&
               (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error
                 (bignumberError + 'crypto unavailable');
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error
             (bignumberError + p + ' not true or false: ' + v);
          }
        }

        // MODULO_MODE {number} Integer, 0 to 9 inclusive.
        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }

        // POW_PRECISION {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }

        // FORMAT {object}
        // '[BigNumber Error] FORMAT not an object: {v}'
        if (obj.hasOwnProperty(p = 'FORMAT')) {
          v = obj[p];
          if (typeof v == 'object') FORMAT = v;
          else throw Error
           (bignumberError + p + ' not an object: ' + v);
        }

        // ALPHABET {string}
        // '[BigNumber Error] ALPHABET invalid: {v}'
        if (obj.hasOwnProperty(p = 'ALPHABET')) {
          v = obj[p];

          // Disallow if less than two characters,
          // or if it contains '+', '-', '.', whitespace, or a repeated character.
          if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
            ALPHABET = v;
          } else {
            throw Error
             (bignumberError + p + ' invalid: ' + v);
          }
        }

      } else {

        // '[BigNumber Error] Object expected: {v}'
        throw Error
         (bignumberError + 'Object expected: ' + obj);
      }
    }

    return {
      DECIMAL_PLACES: DECIMAL_PLACES,
      ROUNDING_MODE: ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO: CRYPTO,
      MODULO_MODE: MODULO_MODE,
      POW_PRECISION: POW_PRECISION,
      FORMAT: FORMAT,
      ALPHABET: ALPHABET
    };
  };


  /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */
  BigNumber.isBigNumber = function (v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;

    var i, n,
      c = v.c,
      e = v.e,
      s = v.s;

    out: if ({}.toString.call(c) == '[object Array]') {

      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

        // If the first element is zero, the BigNumber value must be zero.
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }

        // Calculate number of digits that c[0] should have, based on the exponent.
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;

        // Calculate number of digits of c[0].
        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
        if (String(c[0]).length == i) {

          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }

          // Last element cannot be zero, unless it is the only element.
          if (n !== 0) return true;
        }
      }

    // Infinity/NaN
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }

    throw Error
      (bignumberError + 'Invalid BigNumber: ' + v);
  };


  /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.maximum = BigNumber.max = function () {
    return maxOrMin(arguments, -1);
  };


  /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.minimum = BigNumber.min = function () {
    return maxOrMin(arguments, 1);
  };


  /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */
  BigNumber.random = (function () {
    var pow2_53 = 0x20000000000000;

    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
    // Check if Math.random() produces more than 32 bits of randomness.
    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
     ? function () { return mathfloor(Math.random() * pow2_53); }
     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
       (Math.random() * 0x800000 | 0); };

    return function (dp) {
      var a, b, e, k, v,
        i = 0,
        c = [],
        rand = new BigNumber(ONE);

      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);

      k = mathceil(dp / LOG_BASE);

      if (CRYPTO) {

        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {

          a = crypto.getRandomValues(new Uint32Array(k *= 2));

          for (; i < k;) {

            // 53 bits:
            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
            //                                     11111 11111111 11111111
            // 0x20000 is 2^21.
            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

            // Rejection sampling:
            // 0 <= v < 9007199254740992
            // Probability that v >= 9e15, is
            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {

              // 0 <= v <= 8999999999999999
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;

        // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {

          // buffer
          a = crypto.randomBytes(k *= 7);

          for (; i < k;) {

            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
            // 0x100000000 is 2^32, 0x1000000 is 2^24
            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
            // 0 <= v < 9007199254740992
            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {

              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error
           (bignumberError + 'crypto unavailable');
        }
      }

      // Use Math.random.
      if (!CRYPTO) {

        for (; i < k;) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }

      k = c[--i];
      dp %= LOG_BASE;

      // Convert trailing digits to zeros according to dp.
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }

      // Remove trailing elements which are zero.
      for (; c[i] === 0; c.pop(), i--);

      // Zero?
      if (i < 0) {
        c = [e = 0];
      } else {

        // Remove leading elements which are zero and adjust exponent accordingly.
        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

        // Count the digits of the first element of c to determine leading zeros, and...
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

        // adjust the exponent accordingly.
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }

      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();


   /*
   * Return a BigNumber whose value is the sum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.sum = function () {
    var i = 1,
      args = arguments,
      sum = new BigNumber(args[0]);
    for (; i < args.length;) sum = sum.plus(args[i++]);
    return sum;
  };


  // PRIVATE FUNCTIONS


  // Called by BigNumber and BigNumber.prototype.toString.
  convertBase = (function () {
    var decimal = '0123456789';

    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        len = str.length;

      for (; i < len;) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

        arr[0] += alphabet.indexOf(str.charAt(i++));

        for (j = 0; j < arr.length; j++) {

          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    }

    // Convert a numeric string of baseIn to a numeric string of baseOut.
    // If the caller is toString, we are converting from base 10 to baseOut.
    // If the caller is BigNumber, we are converting from baseIn to base 10.
    return function (str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y,
        i = str.indexOf('.'),
        dp = DECIMAL_PLACES,
        rm = ROUNDING_MODE;

      // Non-integer.
      if (i >= 0) {
        k = POW_PRECISION;

        // Unlimited precision.
        POW_PRECISION = 0;
        str = str.replace('.', '');
        y = new BigNumber(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;

        // Convert str as if an integer, then restore the fraction part by dividing the
        // result by its base raised to a power.

        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
         10, baseOut, decimal);
        y.e = y.c.length;
      }

      // Convert the number as integer.

      xc = toBaseOut(str, baseIn, baseOut, callerIsToString
       ? (alphabet = ALPHABET, decimal)
       : (alphabet = decimal, ALPHABET));

      // xc now represents str as an integer and converted to baseOut. e is the exponent.
      e = k = xc.length;

      // Remove trailing zeros.
      for (; xc[--k] == 0; xc.pop());

      // Zero?
      if (!xc[0]) return alphabet.charAt(0);

      // Does str represent an integer? If so, no need for the division.
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;

        // The sign is needed for correct rounding.
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }

      // xc now represents str converted to baseOut.

      // The index of the rounding digit.
      d = e + dp + 1;

      // The rounding digit: the digit to the right of the digit that may be rounded up.
      i = xc[d];

      // Look at the rounding digits and mode to determine whether to round up.

      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;

      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
             rm == (x.s < 0 ? 8 : 7));

      // If the index of the rounding digit is not greater than zero, or xc represents
      // zero, then the result of the base conversion is zero or, if rounding up, a value
      // such as 0.00001.
      if (d < 1 || !xc[0]) {

        // 1^-dp or 0
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {

        // Truncate xc to the required number of decimal places.
        xc.length = d;

        // Round up?
        if (r) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (--baseOut; ++xc[--d] > baseOut;) {
            xc[d] = 0;

            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }

        // Determine trailing zeros.
        for (k = xc.length; !xc[--k];);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

        // Add leading zeros, decimal point and trailing zeros as required.
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }

      // The caller will add the sign.
      return str;
    };
  })();


  // Perform division in the specified base. Called by div and convertBase.
  div = (function () {

    // Assume non-zero x and k.
    function multiply(x, k, base) {
      var m, temp, xlo, xhi,
        carry = 0,
        i = x.length,
        klo = k % SQRT_BASE,
        khi = k / SQRT_BASE | 0;

      for (x = x.slice(); i--;) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }

      if (carry) x = [carry].concat(x);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, cmp;

      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {

        for (i = cmp = 0; i < aL; i++) {

          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return cmp;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1; a.splice(0, 1));
    }

    // x: dividend, y: divisor.
    return function (x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
        yL, yz,
        s = x.s == y.s ? 1 : -1,
        xc = x.c,
        yc = y.c;

      // Either NaN, Infinity or 0?
      if (!xc || !xc[0] || !yc || !yc[0]) {

        return new BigNumber(

         // Return NaN if either NaN, or both Infinity or 0.
         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

          // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0
       );
      }

      q = new BigNumber(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;

      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }

      // Result exponent may be one less then the current value of e.
      // The coefficients of the BigNumbers from convertBase may have trailing zeros.
      for (i = 0; yc[i] == (xc[i] || 0); i++);

      if (yc[i] > (xc[i] || 0)) e--;

      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;

        // Normalise xc and yc so highest order digit of yc is >= base / 2.

        n = mathfloor(base / (yc[0] + 1));

        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }

        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;

        // Add zeros to make remainder as long as divisor.
        for (; remL < yL; rem[remL++] = 0);
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        // Not necessary, but to prevent trial digit n > base, when using base 3.
        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

        do {
          n = 0;

          // Compare divisor and remainder.
          cmp = compare(yc, rem, yL, remL);

          // If divisor < remainder.
          if (cmp < 0) {

            // Calculate trial digit, n.

            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

            // n is how many times the divisor goes into the current remainder.
            n = mathfloor(rem0 / yc0);

            //  Algorithm:
            //  product = divisor multiplied by trial digit (n).
            //  Compare product and remainder.
            //  If product is greater than remainder:
            //    Subtract divisor from product, decrement trial digit.
            //  Subtract product from remainder.
            //  If product was less than remainder at the last compare:
            //    Compare new remainder and divisor.
            //    If remainder is greater than divisor:
            //      Subtract divisor from remainder, increment trial digit.

            if (n > 1) {

              // n may be > base only when base is 3.
              if (n >= base) n = base - 1;

              // product = divisor * trial digit.
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;

              // Compare product and remainder.
              // If product > remainder then trial digit n too high.
              // n is 1 too high about 5% of the time, and is not known to have
              // ever been more than 1 too high.
              while (compare(prod, rem, prodL, remL) == 1) {
                n--;

                // Subtract divisor from product.
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {

              // n is 0 or 1, cmp is -1.
              // If n is 0, there is no need to compare yc and rem again below,
              // so change cmp to 1 to avoid it.
              // If n is 1, leave cmp as -1, so yc and rem are compared again.
              if (n == 0) {

                // divisor < remainder, so n must be at least 1.
                cmp = n = 1;
              }

              // product = divisor
              prod = yc.slice();
              prodL = prod.length;
            }

            if (prodL < remL) prod = [0].concat(prod);

            // Subtract product from remainder.
            subtract(rem, prod, remL, base);
            remL = rem.length;

             // If product was < remainder.
            if (cmp == -1) {

              // Compare divisor and new remainder.
              // If divisor < new remainder, subtract divisor from remainder.
              // Trial digit n too low.
              // n is 1 too low about 5% of the time, and very rarely 2 too low.
              while (compare(yc, rem, yL, remL) < 1) {
                n++;

                // Subtract divisor from remainder.
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          } // else cmp === 1 and n will be 0

          // Add the next digit, n, to the result array.
          qc[i++] = n;

          // Update the remainder.
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);

        more = rem[0] != null;

        // Leading zero?
        if (!qc[0]) qc.splice(0, 1);
      }

      if (base == BASE) {

        // To calculate q.e, first get the number of digits of qc[0].
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

      // Caller is convertBase.
      } else {
        q.e = e;
        q.r = +more;
      }

      return q;
    };
  })();


  /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;

    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);

    if (!n.c) return n.toString();

    c0 = n.c[0];
    ne = n.e;

    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
       ? toExponential(str, ne)
       : toFixedPoint(str, ne, '0');
    } else {
      n = round(new BigNumber(n), i, rm);

      // n.e may have changed if the value was rounded up.
      e = n.e;

      str = coeffToString(n.c);
      len = str.length;

      // toPrecision returns exponential notation if the number of significant digits
      // specified is less than the number of digits necessary to represent the integer
      // part of the value in fixed-point notation.

      // Exponential notation.
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

        // Append zeros?
        for (; len < i; str += '0', len++);
        str = toExponential(str, e);

      // Fixed-point notation.
      } else {
        i -= ne + (id === 2 && e > ne);
        str = toFixedPoint(str, e, '0');

        // Append zeros?
        if (e + 1 > len) {
          if (--i > 0) for (str += '.'; i--; str += '0');
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += '.';
            for (; i--; str += '0');
          }
        }
      }
    }

    return n.s < 0 && c0 ? '-' + str : str;
  }


  // Handle BigNumber.max and BigNumber.min.
  // If any number is NaN, return NaN.
  function maxOrMin(args, n) {
    var k, y,
      i = 1,
      x = new BigNumber(args[0]);

    for (; i < args.length; i++) {
      y = new BigNumber(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */
  function normalise(n, c, e) {
    var i = 1,
      j = c.length;

     // Remove trailing zeros.
    for (; !c[--j]; c.pop());

    // Calculate the base 10 exponent. First get the number of digits of c[0].
    for (j = c[0]; j >= 10; j /= 10, i++);

    // Overflow?
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

      // Infinity.
      n.c = n.e = null;

    // Underflow?
    } else if (e < MIN_EXP) {

      // Zero.
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }

    return n;
  }


  // Handle values that fail the validity test in BigNumber.
  parseNumeric = (function () {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      dotAfter = /^([^.]+)\.$/,
      dotBefore = /^\.([^.]+)$/,
      isInfinityOrNaN = /^-?(Infinity|NaN)$/,
      whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

    return function (x, str, isNum, b) {
      var base,
        s = isNum ? str : str.replace(whitespaceOrPlus, '');

      // No exception on ±Infinity or NaN.
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {

          // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
          s = s.replace(basePrefix, function (m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
            return !b || b == base ? p1 : m;
          });

          if (b) {
            base = b;

            // E.g. '1.' to '1', '.1' to '0.1'
            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
          }

          if (str != s) return new BigNumber(s, base);
        }

        // '[BigNumber Error] Not a number: {n}'
        // '[BigNumber Error] Not a base {b} number: {n}'
        if (BigNumber.DEBUG) {
          throw Error
            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
        }

        // NaN
        x.s = null;
      }

      x.c = x.e = null;
    }
  })();


  /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd,
      xc = x.c,
      pows10 = POWS_TEN;

    // if x is not Infinity or NaN...
    if (xc) {

      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
      // n is a base 1e14 number, the value of the element of array x.c containing rd.
      // ni is the index of n within x.c.
      // d is the number of digits of n.
      // i is the index of rd within n including leading zeros.
      // j is the actual index of rd within n (if < 0, rd is a leading zero).
      out: {

        // Get the number of digits of the first element of xc.
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
        i = sd - d;

        // If the rounding digit is in the first element of xc...
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];

          // Get the rounding digit at index j of n.
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);

          if (ni >= xc.length) {

            if (r) {

              // Needed by sqrt.
              for (; xc.length <= ni; xc.push(0));
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];

            // Get the number of digits of n.
            for (d = 1; k >= 10; k /= 10, d++);

            // Get the index of rd within n.
            i %= LOG_BASE;

            // Get the index of rd within n, adjusted for leading zeros.
            // The number of leading zeros of n is given by LOG_BASE - d.
            j = i - LOG_BASE + d;

            // Get the rounding digit at index j of n.
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }

        r = r || sd < 0 ||

        // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

        r = rm < 4
         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
           rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xc[0]) {
          xc.length = 0;

          if (r) {

            // Convert sd to decimal places.
            sd -= x.e + 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {

            // Zero.
            xc[0] = x.e = 0;
          }

          return x;
        }

        // Remove excess digits.
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];

          // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of n.
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }

        // Round up?
        if (r) {

          for (; ;) {

            // If the digit to be rounded up is in the first element of xc...
            if (ni == 0) {

              // i will be the length of xc[0] before k is added.
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++);

              // if i != k the length has increased.
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }

              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }

        // Remove trailing zeros.
        for (i = xc.length; xc[--i] === 0; xc.pop());
      }

      // Overflow? Infinity.
      if (x.e > MAX_EXP) {
        x.c = x.e = null;

      // Underflow? Zero.
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }

    return x;
  }


  function valueOf(n) {
    var str,
      e = n.e;

    if (e === null) return n.toString();

    str = coeffToString(n.c);

    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
      ? toExponential(str, e)
      : toFixedPoint(str, e, '0');

    return n.s < 0 ? '-' + str : str;
  }


  // PROTOTYPE/INSTANCE METHODS


  /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */
  P.absoluteValue = P.abs = function () {
    var x = new BigNumber(this);
    if (x.s < 0) x.s = 1;
    return x;
  };


  /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */
  P.comparedTo = function (y, b) {
    return compare(this, new BigNumber(y, b));
  };


  /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.decimalPlaces = P.dp = function (dp, rm) {
    var c, n, v,
      x = this;

    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), dp + x.e + 1, rm);
    }

    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last number.
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
    if (n < 0) n = 0;

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.dividedBy = P.div = function (y, b) {
    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };


  /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */
  P.dividedToIntegerBy = P.idiv = function (y, b) {
    return div(this, new BigNumber(y, b), 0, 1);
  };


  /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */
  P.exponentiatedBy = P.pow = function (n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
      x = this;

    n = new BigNumber(n);

    // Allow NaN and ±Infinity, but not other non-integers.
    if (n.c && !n.isInteger()) {
      throw Error
        (bignumberError + 'Exponent not an integer: ' + valueOf(n));
    }

    if (m != null) m = new BigNumber(m);

    // Exponent of MAX_SAFE_INTEGER is 15.
    nIsBig = n.e > 14;

    // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

      // The sign of the result of pow when x is negative depends on the evenness of n.
      // If +n overflows to ±Infinity, the evenness of n would be not be known.
      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }

    nIsNeg = n.s < 0;

    if (m) {

      // x % m returns NaN if abs(m) is zero, or m is NaN.
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

      isModExp = !nIsNeg && x.isInteger() && m.isInteger();

      if (isModExp) x = x.mod(m);

    // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
    // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
      // [1, 240000000]
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
      // [80000000000000]  [99999750000000]
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

      // If x is negative and n is odd, k = -0, else k = 0.
      k = x.s < 0 && isOdd(n) ? -0 : 0;

      // If x >= 1, k = ±Infinity.
      if (x.e > -1) k = 1 / k;

      // If n is negative return ±0, else return ±Infinity.
      return new BigNumber(nIsNeg ? 1 / k : k);

    } else if (POW_PRECISION) {

      // Truncating each coefficient array to a length of k after each multiplication
      // equates to truncating significant digits to POW_PRECISION + [28, 41],
      // i.e. there will be a minimum of 28 guard digits retained.
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }

    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }

    y = new BigNumber(ONE);

    // Performs 54 loop iterations for n of 9007199254740991.
    for (; ;) {

      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;

        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
        }
      }

      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);

        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }

      x = x.times(x);

      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
      }
    }

    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);

    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */
  P.integerValue = function (rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };


  /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isEqualTo = P.eq = function (y, b) {
    return compare(this, new BigNumber(y, b)) === 0;
  };


  /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */
  P.isFinite = function () {
    return !!this.c;
  };


  /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isGreaterThan = P.gt = function (y, b) {
    return compare(this, new BigNumber(y, b)) > 0;
  };


  /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

  };


  /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */
  P.isInteger = function () {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };


  /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isLessThan = P.lt = function (y, b) {
    return compare(this, new BigNumber(y, b)) < 0;
  };


  /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isLessThanOrEqualTo = P.lte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
  };


  /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */
  P.isNegative = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */
  P.isPositive = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */
  P.isZero = function () {
    return !!this.c && this.c[0] == 0;
  };


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */
  P.minus = function (y, b) {
    var i, j, t, xLTy,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Either Infinity?
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

      // Either zero?
      if (!xc[0] || !yc[0]) {

        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
         ROUNDING_MODE == 3 ? -0 : 0);
      }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Determine which is the bigger number.
    if (a = xe - ye) {

      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }

      t.reverse();

      // Prepend zeros to equalise exponents.
      for (b = a; b--; t.push(0));
      t.reverse();
    } else {

      // Exponents equal. Check digit by digit.
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

      for (a = b = 0; b < j; b++) {

        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }

    // x < y? Point xc to the array of the bigger number.
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }

    b = (j = yc.length) - (i = xc.length);

    // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
    if (b > 0) for (; b--; xc[i++] = 0);
    b = BASE - 1;

    // Subtract yc from xc.
    for (; j > a;) {

      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b);
        --xc[i];
        xc[j] += BASE;
      }

      xc[j] -= yc[j];
    }

    // Remove leading zeros and adjust exponent accordingly.
    for (; xc[0] == 0; xc.splice(0, 1), --ye);

    // Zero?
    if (!xc[0]) {

      // Following IEEE 754 (2008) 6.3,
      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }

    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
    // for finite x and y.
    return normalise(y, xc, ye);
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */
  P.modulo = P.mod = function (y, b) {
    var q, s,
      x = this;

    y = new BigNumber(y, b);

    // Return NaN if x is Infinity or NaN, or y is NaN or zero.
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN);

    // Return x if y is Infinity or x is zero.
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber(x);
    }

    if (MODULO_MODE == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // r = x - qy    where  0 <= r < abs(y)
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }

    y = x.minus(q.times(y));

    // To match JavaScript %, ensure sign of zero is sign of dividend.
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

    return y;
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */
  P.multipliedBy = P.times = function (y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
      base, sqrtBase,
      x = this,
      xc = x.c,
      yc = (y = new BigNumber(y, b)).c;

    // Either NaN, ±Infinity or ±0?
    if (!xc || !yc || !xc[0] || !yc[0]) {

      // Return NaN if either is NaN, or one is 0 and the other is Infinity.
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;

        // Return ±Infinity if either is ±Infinity.
        if (!xc || !yc) {
          y.c = y.e = null;

        // Return ±0 if either is ±0.
        } else {
          y.c = [0];
          y.e = 0;
        }
      }

      return y;
    }

    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;

    // Ensure xc points to longer array and xcL to its length.
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }

    // Initialise the result array with zeros.
    for (i = xcL + ycL, zc = []; i--; zc.push(0));

    base = BASE;
    sqrtBase = SQRT_BASE;

    for (i = ycL; --i >= 0;) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;

      for (k = xcL, j = i + k; j > i;) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }

      zc[j] = c;
    }

    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }

    return normalise(y, zc, e);
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */
  P.negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */
  P.plus = function (y, b) {
    var t,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
     if (a != b) {
      y.s = -b;
      return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Return ±Infinity if either ±Infinity.
      if (!xc || !yc) return new BigNumber(a / 0);

      // Either zero?
      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }

      t.reverse();
      for (; a--; t.push(0));
      t.reverse();
    }

    a = xc.length;
    b = yc.length;

    // Point xc to the longer array, and b to the shorter length.
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }

    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
    for (a = 0; b;) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }

    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    // ye = MAX_EXP + 1 possible
    return normalise(y, xc, ye);
  };


  /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.precision = P.sd = function (sd, rm) {
    var c, n, v,
      x = this;

    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), sd, rm);
    }

    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if (v = c[v]) {

      // Subtract the number of trailing zeros of the last element.
      for (; v % 10 == 0; v /= 10, n--);

      // Add the number of digits of the first element.
      for (v = c[0]; v >= 10; v /= 10, n++);
    }

    if (sd && x.e + 1 > n) n = x.e + 1;

    return n;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */
  P.shiftedBy = function (k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times('1e' + k);
  };


  /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, r, rep, t,
      x = this,
      c = x.c,
      s = x.s,
      e = x.e,
      dp = DECIMAL_PLACES + 4,
      half = new BigNumber('0.5');

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }

    // Initial estimate.
    s = Math.sqrt(+valueOf(x));

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + '');
    }

    // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;

      // Newton-Raphson iteration.
      for (; ;) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));

        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

          // The exponent of r may here be one less than the final result exponent,
          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
          // are indexed correctly.
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
          // iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the
            // exact result as the nines may infinitely repeat.
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            dp += 4;
            s += 4;
            rep = 1;
          } else {

            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
            // result. If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }
    }

    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };


  /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toExponential = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toFixed = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */
  P.toFormat = function (dp, rm, format) {
    var str,
      x = this;

    if (format == null) {
      if (dp != null && rm && typeof rm == 'object') {
        format = rm;
        rm = null;
      } else if (dp && typeof dp == 'object') {
        format = dp;
        dp = rm = null;
      } else {
        format = FORMAT;
      }
    } else if (typeof format != 'object') {
      throw Error
        (bignumberError + 'Argument not an object: ' + format);
    }

    str = x.toFixed(dp, rm);

    if (x.c) {
      var i,
        arr = str.split('.'),
        g1 = +format.groupSize,
        g2 = +format.secondaryGroupSize,
        groupSeparator = format.groupSeparator || '',
        intPart = arr[0],
        fractionPart = arr[1],
        isNeg = x.s < 0,
        intDigits = isNeg ? intPart.slice(1) : intPart,
        len = intDigits.length;

      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }

      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = '-' + intPart;
      }

      str = fractionPart
       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
        ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
         '$&' + (format.fractionGroupSeparator || ''))
        : fractionPart)
       : intPart;
    }

    return (format.prefix || '') + str + (format.suffix || '');
  };


  /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */
  P.toFraction = function (md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
      x = this,
      xc = x.c;

    if (md != null) {
      n = new BigNumber(md);

      // Throw if md is less than one or is not an integer, unless it is Infinity.
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error
          (bignumberError + 'Argument ' +
            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
      }
    }

    if (!xc) return new BigNumber(x);

    d = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc);

    // Determine initial denominator.
    // d is a power of 10 and the minimum max denominator that specifies the value exactly.
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s);

    // n0 = d1 = 0
    n0.c[0] = 0;

    for (; ;)  {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }

    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;

    // Determine which fraction is closer to x, n0/d0 or n1/d1
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

    MAX_EXP = exp;

    return r;
  };


  /*
   * Return the value of this BigNumber converted to a number primitive.
   */
  P.toNumber = function () {
    return +valueOf(this);
  };


  /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.toPrecision = function (sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };


  /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */
  P.toString = function (b) {
    var str,
      n = this,
      s = n.s,
      e = n.e;

    // Infinity or NaN?
    if (e === null) {
      if (s) {
        str = 'Infinity';
        if (s < 0) str = '-' + str;
      } else {
        str = 'NaN';
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS
         ? toExponential(coeffToString(n.c), e)
         : toFixedPoint(coeffToString(n.c), e, '0');
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, '0');
      } else {
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
      }

      if (s < 0 && n.c[0]) str = '-' + str;
    }

    return str;
  };


  /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */
  P.valueOf = P.toJSON = function () {
    return valueOf(this);
  };


  P._isBigNumber = true;

  P[Symbol.toStringTag] = 'BigNumber';

  // Node.js v10.12.0+
  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;

  if (configObject != null) BigNumber.set(configObject);

  return BigNumber;
}


// PRIVATE HELPER FUNCTIONS

// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}


// Return a coefficient array as a string of base 10 digits.
function coeffToString(a) {
  var s, z,
    i = 1,
    j = a.length,
    r = a[0] + '';

  for (; i < j;) {
    s = a[i++] + '';
    z = LOG_BASE - s.length;
    for (; z--; s = '0' + s);
    r += s;
  }

  // Determine trailing zeros.
  for (j = r.length; r.charCodeAt(--j) === 48;);

  return r.slice(0, j + 1 || 1);
}


// Compare the value of BigNumbers x and y.
function compare(x, y) {
  var a, b,
    xc = x.c,
    yc = y.c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either NaN?
  if (!i || !j) return null;

  a = xc && !xc[0];
  b = yc && !yc[0];

  // Either zero?
  if (a || b) return a ? b ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  a = i < 0;
  b = k == l;

  // Either Infinity?
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

  // Compare exponents.
  if (!b) return k > l ^ a ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

  // Compare lengths.
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}


/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error
     (bignumberError + (name || 'Argument') + (typeof n == 'number'
       ? n < min || n > max ? ' out of range: ' : ' not an integer: '
       : ' not a primitive number: ') + String(n));
  }
}


// Assumes finite n.
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}


function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
   (e < 0 ? 'e' : 'e+') + e;
}


function toFixedPoint(str, e, z) {
  var len, zs;

  // Negative exponent?
  if (e < 0) {

    // Prepend zeros.
    for (zs = z + '.'; ++e; zs += z);
    str = zs + str;

  // Positive exponent
  } else {
    len = str.length;

    // Append zeros.
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z);
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + '.' + str.slice(e);
    }
  }

  return str;
}


// EXPORT


var BigNumber = clone();

/* harmony default export */ const bignumber = (BigNumber);

// EXTERNAL MODULE: ./node_modules/urijs/src/URI.js
var URI = __webpack_require__(193);
var URI_default = /*#__PURE__*/__webpack_require__.n(URI);
// EXTERNAL MODULE: ./node_modules/urijs/src/URITemplate.js
var URITemplate = __webpack_require__(127);
var URITemplate_default = /*#__PURE__*/__webpack_require__.n(URITemplate);
// EXTERNAL MODULE: ./src/errors/index.ts + 5 modules
var errors = __webpack_require__(976);
// EXTERNAL MODULE: ./src/http-client/index.ts + 1 modules
var http_client = __webpack_require__(983);
;// ./src/horizon/horizon_axios_client.ts
function horizon_axios_client_typeof(o) { "@babel/helpers - typeof"; return horizon_axios_client_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, horizon_axios_client_typeof(o); }


var version = "14.1.1";
var SERVER_TIME_MAP = {};
var AxiosClient = (0,http_client/* create */.vt)({
  headers: {
    "X-Client-Name": "js-stellar-sdk",
    "X-Client-Version": version
  }
});
function toSeconds(ms) {
  return Math.floor(ms / 1000);
}
AxiosClient.interceptors.response.use(function (response) {
  var hostname = URI_default()(response.config.url).hostname();
  var serverTime = 0;
  if (response.headers instanceof Headers) {
    var dateHeader = response.headers.get('date');
    if (dateHeader) {
      serverTime = toSeconds(Date.parse(dateHeader));
    }
  } else if (horizon_axios_client_typeof(response.headers) === 'object' && 'date' in response.headers) {
    var headers = response.headers;
    if (typeof headers.date === 'string') {
      serverTime = toSeconds(Date.parse(headers.date));
    }
  }
  var localTimeRecorded = toSeconds(new Date().getTime());
  if (!Number.isNaN(serverTime)) {
    SERVER_TIME_MAP[hostname] = {
      serverTime: serverTime,
      localTimeRecorded: localTimeRecorded
    };
  }
  return response;
});
/* harmony default export */ const horizon_axios_client = (AxiosClient);
function getCurrentServerTime(hostname) {
  var entry = SERVER_TIME_MAP[hostname];
  if (!entry || !entry.localTimeRecorded || !entry.serverTime) {
    return null;
  }
  var serverTime = entry.serverTime,
    localTimeRecorded = entry.localTimeRecorded;
  var currentTime = toSeconds(new Date().getTime());
  if (currentTime - localTimeRecorded > 60 * 5) {
    return null;
  }
  return currentTime - localTimeRecorded + serverTime;
}
;// ./src/horizon/call_builder.ts
function call_builder_typeof(o) { "@babel/helpers - typeof"; return call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, call_builder_typeof(o); }
function _regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, call_builder_toPropertyKey(o.key), o); } }
function call_builder_createClass(e, r, t) { return r && call_builder_defineProperties(e.prototype, r), t && call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function call_builder_toPropertyKey(t) { var i = call_builder_toPrimitive(t, "string"); return "symbol" == call_builder_typeof(i) ? i : i + ""; }
function call_builder_toPrimitive(t, r) { if ("object" != call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var JOINABLE = ["transaction"];
var anyGlobal = (/* unused pure expression or super */ null && (__webpack_require__.g));
var EventSource;
if (false) // removed by dead control flow
{ var _ref, _anyGlobal$EventSourc, _anyGlobal$window; }
var CallBuilder = function () {
  function CallBuilder(serverUrl) {
    var neighborRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    call_builder_classCallCheck(this, CallBuilder);
    this.url = serverUrl.clone();
    this.filter = [];
    this.originalSegments = this.url.segment() || [];
    this.neighborRoot = neighborRoot;
  }
  return call_builder_createClass(CallBuilder, [{
    key: "call",
    value: function call() {
      var _this = this;
      this.checkFilter();
      return this._sendNormalRequest(this.url).then(function (r) {
        return _this._parseResponse(r);
      });
    }
  }, {
    key: "stream",
    value: function stream() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (EventSource === undefined) {
        throw new Error("Streaming requires eventsource to be enabled. If you need this functionality, compile with USE_EVENTSOURCE=true.");
      }
      this.checkFilter();
      this.url.setQuery("X-Client-Name", "js-stellar-sdk");
      this.url.setQuery("X-Client-Version", version);
      var es;
      var timeout;
      var createTimeout = function createTimeout() {
        timeout = setTimeout(function () {
          var _es;
          (_es = es) === null || _es === void 0 || _es.close();
          es = _createEventSource();
        }, options.reconnectTimeout || 15 * 1000);
      };
      var _createEventSource = function createEventSource() {
        try {
          es = new EventSource(_this2.url.toString());
        } catch (err) {
          if (options.onerror) {
            options.onerror(err);
          }
        }
        createTimeout();
        if (!es) {
          return es;
        }
        var closed = false;
        var onClose = function onClose() {
          if (closed) {
            return;
          }
          clearTimeout(timeout);
          es.close();
          _createEventSource();
          closed = true;
        };
        var onMessage = function onMessage(message) {
          if (message.type === "close") {
            onClose();
            return;
          }
          var result = message.data ? _this2._parseRecord(JSON.parse(message.data)) : message;
          if (result.paging_token) {
            _this2.url.setQuery("cursor", result.paging_token);
          }
          clearTimeout(timeout);
          createTimeout();
          if (typeof options.onmessage !== "undefined") {
            options.onmessage(result);
          }
        };
        var onError = function onError(error) {
          if (options.onerror) {
            options.onerror(error);
          }
        };
        if (es.addEventListener) {
          es.addEventListener("message", onMessage.bind(_this2));
          es.addEventListener("error", onError.bind(_this2));
          es.addEventListener("close", onClose.bind(_this2));
        } else {
          es.onmessage = onMessage.bind(_this2);
          es.onerror = onError.bind(_this2);
        }
        return es;
      };
      _createEventSource();
      return function () {
        var _es2;
        clearTimeout(timeout);
        (_es2 = es) === null || _es2 === void 0 || _es2.close();
      };
    }
  }, {
    key: "cursor",
    value: function cursor(_cursor) {
      this.url.setQuery("cursor", _cursor);
      return this;
    }
  }, {
    key: "limit",
    value: function limit(recordsNumber) {
      this.url.setQuery("limit", recordsNumber.toString());
      return this;
    }
  }, {
    key: "order",
    value: function order(direction) {
      this.url.setQuery("order", direction);
      return this;
    }
  }, {
    key: "join",
    value: function join(include) {
      this.url.setQuery("join", include);
      return this;
    }
  }, {
    key: "forEndpoint",
    value: function forEndpoint(endpoint, param) {
      if (this.neighborRoot === "") {
        throw new Error("Invalid usage: neighborRoot not set in constructor");
      }
      this.filter.push([endpoint, param, this.neighborRoot]);
      return this;
    }
  }, {
    key: "checkFilter",
    value: function checkFilter() {
      if (this.filter.length >= 2) {
        throw new errors/* BadRequestError */.v7("Too many filters specified", this.filter);
      }
      if (this.filter.length === 1) {
        var newSegment = this.originalSegments.concat(this.filter[0]);
        this.url.segment(newSegment);
      }
    }
  }, {
    key: "_requestFnForLink",
    value: function _requestFnForLink(link) {
      var _this3 = this;
      return _asyncToGenerator(_regenerator().m(function _callee() {
        var opts,
          uri,
          template,
          r,
          _args = arguments;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              opts = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              if (link.templated) {
                template = URITemplate_default()(link.href);
                uri = URI_default()(template.expand(opts));
              } else {
                uri = URI_default()(link.href);
              }
              _context.n = 1;
              return _this3._sendNormalRequest(uri);
            case 1:
              r = _context.v;
              return _context.a(2, _this3._parseResponse(r));
          }
        }, _callee);
      }));
    }
  }, {
    key: "_parseRecord",
    value: function _parseRecord(json) {
      var _this4 = this;
      if (!json._links) {
        return json;
      }
      Object.keys(json._links).forEach(function (key) {
        var n = json._links[key];
        var included = false;
        if (typeof json[key] !== "undefined") {
          json["".concat(key, "_attr")] = json[key];
          included = true;
        }
        if (included && JOINABLE.indexOf(key) >= 0) {
          var record = _this4._parseRecord(json[key]);
          json[key] = _asyncToGenerator(_regenerator().m(function _callee2() {
            return _regenerator().w(function (_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  return _context2.a(2, record);
              }
            }, _callee2);
          }));
        } else {
          json[key] = _this4._requestFnForLink(n);
        }
      });
      return json;
    }
  }, {
    key: "_sendNormalRequest",
    value: function () {
      var _sendNormalRequest2 = _asyncToGenerator(_regenerator().m(function _callee3(initialUrl) {
        var url;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              url = initialUrl;
              if (url.authority() === "") {
                url = url.authority(this.url.authority());
              }
              if (url.protocol() === "") {
                url = url.protocol(this.url.protocol());
              }
              return _context3.a(2, AxiosClient.get(url.toString()).then(function (response) {
                return response.data;
              }).catch(this._handleNetworkError));
          }
        }, _callee3, this);
      }));
      function _sendNormalRequest(_x) {
        return _sendNormalRequest2.apply(this, arguments);
      }
      return _sendNormalRequest;
    }()
  }, {
    key: "_parseResponse",
    value: function _parseResponse(json) {
      if (json._embedded && json._embedded.records) {
        return this._toCollectionPage(json);
      }
      return this._parseRecord(json);
    }
  }, {
    key: "_toCollectionPage",
    value: function _toCollectionPage(json) {
      var _this5 = this;
      for (var i = 0; i < json._embedded.records.length; i += 1) {
        json._embedded.records[i] = this._parseRecord(json._embedded.records[i]);
      }
      return {
        records: json._embedded.records,
        next: function () {
          var _next2 = _asyncToGenerator(_regenerator().m(function _callee4() {
            var r;
            return _regenerator().w(function (_context4) {
              while (1) switch (_context4.n) {
                case 0:
                  _context4.n = 1;
                  return _this5._sendNormalRequest(URI_default()(json._links.next.href));
                case 1:
                  r = _context4.v;
                  return _context4.a(2, _this5._toCollectionPage(r));
              }
            }, _callee4);
          }));
          function next() {
            return _next2.apply(this, arguments);
          }
          return next;
        }(),
        prev: function () {
          var _prev = _asyncToGenerator(_regenerator().m(function _callee5() {
            var r;
            return _regenerator().w(function (_context5) {
              while (1) switch (_context5.n) {
                case 0:
                  _context5.n = 1;
                  return _this5._sendNormalRequest(URI_default()(json._links.prev.href));
                case 1:
                  r = _context5.v;
                  return _context5.a(2, _this5._toCollectionPage(r));
              }
            }, _callee5);
          }));
          function prev() {
            return _prev.apply(this, arguments);
          }
          return prev;
        }()
      };
    }
  }, {
    key: "_handleNetworkError",
    value: (function () {
      var _handleNetworkError2 = _asyncToGenerator(_regenerator().m(function _callee6(error) {
        var _error$response$statu, _error$response$statu2;
        var _t;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              if (!(error.response && error.response.status)) {
                _context6.n = 4;
                break;
              }
              _t = error.response.status;
              _context6.n = _t === 404 ? 1 : 2;
              break;
            case 1:
              return _context6.a(2, Promise.reject(new errors/* NotFoundError */.m_((_error$response$statu = error.response.statusText) !== null && _error$response$statu !== void 0 ? _error$response$statu : "Not Found", error.response.data)));
            case 2:
              return _context6.a(2, Promise.reject(new errors/* NetworkError */.Dr((_error$response$statu2 = error.response.statusText) !== null && _error$response$statu2 !== void 0 ? _error$response$statu2 : "Unknown", error.response.data)));
            case 3:
              _context6.n = 5;
              break;
            case 4:
              return _context6.a(2, Promise.reject(new Error(error.message)));
            case 5:
              return _context6.a(2);
          }
        }, _callee6);
      }));
      function _handleNetworkError(_x2) {
        return _handleNetworkError2.apply(this, arguments);
      }
      return _handleNetworkError;
    }())
  }]);
}();
// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(732);
;// ./src/horizon/account_call_builder.ts
function account_call_builder_typeof(o) { "@babel/helpers - typeof"; return account_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, account_call_builder_typeof(o); }
function account_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function account_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, account_call_builder_toPropertyKey(o.key), o); } }
function account_call_builder_createClass(e, r, t) { return r && account_call_builder_defineProperties(e.prototype, r), t && account_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function account_call_builder_toPropertyKey(t) { var i = account_call_builder_toPrimitive(t, "string"); return "symbol" == account_call_builder_typeof(i) ? i : i + ""; }
function account_call_builder_toPrimitive(t, r) { if ("object" != account_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != account_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == account_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var AccountCallBuilder = function (_CallBuilder) {
  function AccountCallBuilder(serverUrl) {
    var _this;
    account_call_builder_classCallCheck(this, AccountCallBuilder);
    _this = _callSuper(this, AccountCallBuilder, [serverUrl]);
    _this.url.segment("accounts");
    return _this;
  }
  _inherits(AccountCallBuilder, _CallBuilder);
  return account_call_builder_createClass(AccountCallBuilder, [{
    key: "accountId",
    value: function accountId(id) {
      var builder = new CallBuilder(this.url.clone());
      builder.filter.push([id]);
      return builder;
    }
  }, {
    key: "forSigner",
    value: function forSigner(id) {
      this.url.setQuery("signer", id);
      return this;
    }
  }, {
    key: "forAsset",
    value: function forAsset(asset) {
      this.url.setQuery("asset", "".concat(asset));
      return this;
    }
  }, {
    key: "sponsor",
    value: function sponsor(id) {
      this.url.setQuery("sponsor", id);
      return this;
    }
  }, {
    key: "forLiquidityPool",
    value: function forLiquidityPool(id) {
      this.url.setQuery("liquidity_pool", id);
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/assets_call_builder.ts
function assets_call_builder_typeof(o) { "@babel/helpers - typeof"; return assets_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, assets_call_builder_typeof(o); }
function assets_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function assets_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, assets_call_builder_toPropertyKey(o.key), o); } }
function assets_call_builder_createClass(e, r, t) { return r && assets_call_builder_defineProperties(e.prototype, r), t && assets_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function assets_call_builder_toPropertyKey(t) { var i = assets_call_builder_toPrimitive(t, "string"); return "symbol" == assets_call_builder_typeof(i) ? i : i + ""; }
function assets_call_builder_toPrimitive(t, r) { if ("object" != assets_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != assets_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function assets_call_builder_callSuper(t, o, e) { return o = assets_call_builder_getPrototypeOf(o), assets_call_builder_possibleConstructorReturn(t, assets_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], assets_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function assets_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == assets_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return assets_call_builder_assertThisInitialized(t); }
function assets_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function assets_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (assets_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function assets_call_builder_getPrototypeOf(t) { return assets_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, assets_call_builder_getPrototypeOf(t); }
function assets_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && assets_call_builder_setPrototypeOf(t, e); }
function assets_call_builder_setPrototypeOf(t, e) { return assets_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, assets_call_builder_setPrototypeOf(t, e); }

var AssetsCallBuilder = function (_CallBuilder) {
  function AssetsCallBuilder(serverUrl) {
    var _this;
    assets_call_builder_classCallCheck(this, AssetsCallBuilder);
    _this = assets_call_builder_callSuper(this, AssetsCallBuilder, [serverUrl]);
    _this.url.segment("assets");
    return _this;
  }
  assets_call_builder_inherits(AssetsCallBuilder, _CallBuilder);
  return assets_call_builder_createClass(AssetsCallBuilder, [{
    key: "forCode",
    value: function forCode(value) {
      this.url.setQuery("asset_code", value);
      return this;
    }
  }, {
    key: "forIssuer",
    value: function forIssuer(value) {
      this.url.setQuery("asset_issuer", value);
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/claimable_balances_call_builder.ts
function claimable_balances_call_builder_typeof(o) { "@babel/helpers - typeof"; return claimable_balances_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, claimable_balances_call_builder_typeof(o); }
function claimable_balances_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function claimable_balances_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, claimable_balances_call_builder_toPropertyKey(o.key), o); } }
function claimable_balances_call_builder_createClass(e, r, t) { return r && claimable_balances_call_builder_defineProperties(e.prototype, r), t && claimable_balances_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function claimable_balances_call_builder_toPropertyKey(t) { var i = claimable_balances_call_builder_toPrimitive(t, "string"); return "symbol" == claimable_balances_call_builder_typeof(i) ? i : i + ""; }
function claimable_balances_call_builder_toPrimitive(t, r) { if ("object" != claimable_balances_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != claimable_balances_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function claimable_balances_call_builder_callSuper(t, o, e) { return o = claimable_balances_call_builder_getPrototypeOf(o), claimable_balances_call_builder_possibleConstructorReturn(t, claimable_balances_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], claimable_balances_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function claimable_balances_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == claimable_balances_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return claimable_balances_call_builder_assertThisInitialized(t); }
function claimable_balances_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function claimable_balances_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (claimable_balances_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function claimable_balances_call_builder_getPrototypeOf(t) { return claimable_balances_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, claimable_balances_call_builder_getPrototypeOf(t); }
function claimable_balances_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && claimable_balances_call_builder_setPrototypeOf(t, e); }
function claimable_balances_call_builder_setPrototypeOf(t, e) { return claimable_balances_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, claimable_balances_call_builder_setPrototypeOf(t, e); }

var ClaimableBalanceCallBuilder = function (_CallBuilder) {
  function ClaimableBalanceCallBuilder(serverUrl) {
    var _this;
    claimable_balances_call_builder_classCallCheck(this, ClaimableBalanceCallBuilder);
    _this = claimable_balances_call_builder_callSuper(this, ClaimableBalanceCallBuilder, [serverUrl]);
    _this.url.segment("claimable_balances");
    return _this;
  }
  claimable_balances_call_builder_inherits(ClaimableBalanceCallBuilder, _CallBuilder);
  return claimable_balances_call_builder_createClass(ClaimableBalanceCallBuilder, [{
    key: "claimableBalance",
    value: function claimableBalance(claimableBalanceId) {
      var builder = new CallBuilder(this.url.clone());
      builder.filter.push([claimableBalanceId]);
      return builder;
    }
  }, {
    key: "sponsor",
    value: function sponsor(_sponsor) {
      this.url.setQuery("sponsor", _sponsor);
      return this;
    }
  }, {
    key: "claimant",
    value: function claimant(_claimant) {
      this.url.setQuery("claimant", _claimant);
      return this;
    }
  }, {
    key: "asset",
    value: function asset(_asset) {
      this.url.setQuery("asset", _asset.toString());
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/effect_call_builder.ts
function effect_call_builder_typeof(o) { "@babel/helpers - typeof"; return effect_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, effect_call_builder_typeof(o); }
function effect_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function effect_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, effect_call_builder_toPropertyKey(o.key), o); } }
function effect_call_builder_createClass(e, r, t) { return r && effect_call_builder_defineProperties(e.prototype, r), t && effect_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function effect_call_builder_toPropertyKey(t) { var i = effect_call_builder_toPrimitive(t, "string"); return "symbol" == effect_call_builder_typeof(i) ? i : i + ""; }
function effect_call_builder_toPrimitive(t, r) { if ("object" != effect_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != effect_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function effect_call_builder_callSuper(t, o, e) { return o = effect_call_builder_getPrototypeOf(o), effect_call_builder_possibleConstructorReturn(t, effect_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], effect_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function effect_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == effect_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return effect_call_builder_assertThisInitialized(t); }
function effect_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function effect_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (effect_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function effect_call_builder_getPrototypeOf(t) { return effect_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, effect_call_builder_getPrototypeOf(t); }
function effect_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && effect_call_builder_setPrototypeOf(t, e); }
function effect_call_builder_setPrototypeOf(t, e) { return effect_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, effect_call_builder_setPrototypeOf(t, e); }

var EffectCallBuilder = function (_CallBuilder) {
  function EffectCallBuilder(serverUrl) {
    var _this;
    effect_call_builder_classCallCheck(this, EffectCallBuilder);
    _this = effect_call_builder_callSuper(this, EffectCallBuilder, [serverUrl, "effects"]);
    _this.url.segment("effects");
    return _this;
  }
  effect_call_builder_inherits(EffectCallBuilder, _CallBuilder);
  return effect_call_builder_createClass(EffectCallBuilder, [{
    key: "forAccount",
    value: function forAccount(accountId) {
      return this.forEndpoint("accounts", accountId);
    }
  }, {
    key: "forLedger",
    value: function forLedger(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    }
  }, {
    key: "forTransaction",
    value: function forTransaction(transactionId) {
      return this.forEndpoint("transactions", transactionId);
    }
  }, {
    key: "forOperation",
    value: function forOperation(operationId) {
      return this.forEndpoint("operations", operationId);
    }
  }, {
    key: "forLiquidityPool",
    value: function forLiquidityPool(poolId) {
      return this.forEndpoint("liquidity_pools", poolId);
    }
  }]);
}(CallBuilder);
;// ./src/horizon/friendbot_builder.ts
function friendbot_builder_typeof(o) { "@babel/helpers - typeof"; return friendbot_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, friendbot_builder_typeof(o); }
function friendbot_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, friendbot_builder_toPropertyKey(o.key), o); } }
function friendbot_builder_createClass(e, r, t) { return r && friendbot_builder_defineProperties(e.prototype, r), t && friendbot_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function friendbot_builder_toPropertyKey(t) { var i = friendbot_builder_toPrimitive(t, "string"); return "symbol" == friendbot_builder_typeof(i) ? i : i + ""; }
function friendbot_builder_toPrimitive(t, r) { if ("object" != friendbot_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != friendbot_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function friendbot_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function friendbot_builder_callSuper(t, o, e) { return o = friendbot_builder_getPrototypeOf(o), friendbot_builder_possibleConstructorReturn(t, friendbot_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], friendbot_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function friendbot_builder_possibleConstructorReturn(t, e) { if (e && ("object" == friendbot_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return friendbot_builder_assertThisInitialized(t); }
function friendbot_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function friendbot_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (friendbot_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function friendbot_builder_getPrototypeOf(t) { return friendbot_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, friendbot_builder_getPrototypeOf(t); }
function friendbot_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && friendbot_builder_setPrototypeOf(t, e); }
function friendbot_builder_setPrototypeOf(t, e) { return friendbot_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, friendbot_builder_setPrototypeOf(t, e); }

var FriendbotBuilder = function (_CallBuilder) {
  function FriendbotBuilder(serverUrl, address) {
    var _this;
    friendbot_builder_classCallCheck(this, FriendbotBuilder);
    _this = friendbot_builder_callSuper(this, FriendbotBuilder, [serverUrl]);
    _this.url.segment("friendbot");
    _this.url.setQuery("addr", address);
    return _this;
  }
  friendbot_builder_inherits(FriendbotBuilder, _CallBuilder);
  return friendbot_builder_createClass(FriendbotBuilder);
}(CallBuilder);
;// ./src/horizon/ledger_call_builder.ts
function ledger_call_builder_typeof(o) { "@babel/helpers - typeof"; return ledger_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, ledger_call_builder_typeof(o); }
function ledger_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function ledger_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, ledger_call_builder_toPropertyKey(o.key), o); } }
function ledger_call_builder_createClass(e, r, t) { return r && ledger_call_builder_defineProperties(e.prototype, r), t && ledger_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function ledger_call_builder_toPropertyKey(t) { var i = ledger_call_builder_toPrimitive(t, "string"); return "symbol" == ledger_call_builder_typeof(i) ? i : i + ""; }
function ledger_call_builder_toPrimitive(t, r) { if ("object" != ledger_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != ledger_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function ledger_call_builder_callSuper(t, o, e) { return o = ledger_call_builder_getPrototypeOf(o), ledger_call_builder_possibleConstructorReturn(t, ledger_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], ledger_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function ledger_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == ledger_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return ledger_call_builder_assertThisInitialized(t); }
function ledger_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function ledger_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (ledger_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function ledger_call_builder_getPrototypeOf(t) { return ledger_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, ledger_call_builder_getPrototypeOf(t); }
function ledger_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && ledger_call_builder_setPrototypeOf(t, e); }
function ledger_call_builder_setPrototypeOf(t, e) { return ledger_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, ledger_call_builder_setPrototypeOf(t, e); }

var LedgerCallBuilder = function (_CallBuilder) {
  function LedgerCallBuilder(serverUrl) {
    var _this;
    ledger_call_builder_classCallCheck(this, LedgerCallBuilder);
    _this = ledger_call_builder_callSuper(this, LedgerCallBuilder, [serverUrl]);
    _this.url.segment("ledgers");
    return _this;
  }
  ledger_call_builder_inherits(LedgerCallBuilder, _CallBuilder);
  return ledger_call_builder_createClass(LedgerCallBuilder, [{
    key: "ledger",
    value: function ledger(sequence) {
      this.filter.push(["ledgers", sequence.toString()]);
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/liquidity_pool_call_builder.ts
function liquidity_pool_call_builder_typeof(o) { "@babel/helpers - typeof"; return liquidity_pool_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, liquidity_pool_call_builder_typeof(o); }
function liquidity_pool_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function liquidity_pool_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, liquidity_pool_call_builder_toPropertyKey(o.key), o); } }
function liquidity_pool_call_builder_createClass(e, r, t) { return r && liquidity_pool_call_builder_defineProperties(e.prototype, r), t && liquidity_pool_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function liquidity_pool_call_builder_toPropertyKey(t) { var i = liquidity_pool_call_builder_toPrimitive(t, "string"); return "symbol" == liquidity_pool_call_builder_typeof(i) ? i : i + ""; }
function liquidity_pool_call_builder_toPrimitive(t, r) { if ("object" != liquidity_pool_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != liquidity_pool_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function liquidity_pool_call_builder_callSuper(t, o, e) { return o = liquidity_pool_call_builder_getPrototypeOf(o), liquidity_pool_call_builder_possibleConstructorReturn(t, liquidity_pool_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], liquidity_pool_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function liquidity_pool_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == liquidity_pool_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return liquidity_pool_call_builder_assertThisInitialized(t); }
function liquidity_pool_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function liquidity_pool_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (liquidity_pool_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function liquidity_pool_call_builder_getPrototypeOf(t) { return liquidity_pool_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, liquidity_pool_call_builder_getPrototypeOf(t); }
function liquidity_pool_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && liquidity_pool_call_builder_setPrototypeOf(t, e); }
function liquidity_pool_call_builder_setPrototypeOf(t, e) { return liquidity_pool_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, liquidity_pool_call_builder_setPrototypeOf(t, e); }

var LiquidityPoolCallBuilder = function (_CallBuilder) {
  function LiquidityPoolCallBuilder(serverUrl) {
    var _this;
    liquidity_pool_call_builder_classCallCheck(this, LiquidityPoolCallBuilder);
    _this = liquidity_pool_call_builder_callSuper(this, LiquidityPoolCallBuilder, [serverUrl]);
    _this.url.segment("liquidity_pools");
    return _this;
  }
  liquidity_pool_call_builder_inherits(LiquidityPoolCallBuilder, _CallBuilder);
  return liquidity_pool_call_builder_createClass(LiquidityPoolCallBuilder, [{
    key: "forAssets",
    value: function forAssets() {
      for (var _len = arguments.length, assets = new Array(_len), _key = 0; _key < _len; _key++) {
        assets[_key] = arguments[_key];
      }
      var assetList = assets.map(function (asset) {
        return asset.toString();
      }).join(",");
      this.url.setQuery("reserves", assetList);
      return this;
    }
  }, {
    key: "forAccount",
    value: function forAccount(id) {
      this.url.setQuery("account", id);
      return this;
    }
  }, {
    key: "liquidityPoolId",
    value: function liquidityPoolId(id) {
      if (!id.match(/[a-fA-F0-9]{64}/)) {
        throw new TypeError("".concat(id, " does not look like a liquidity pool ID"));
      }
      var builder = new CallBuilder(this.url.clone());
      builder.filter.push([id.toLowerCase()]);
      return builder;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/offer_call_builder.ts
function offer_call_builder_typeof(o) { "@babel/helpers - typeof"; return offer_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, offer_call_builder_typeof(o); }
function offer_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function offer_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, offer_call_builder_toPropertyKey(o.key), o); } }
function offer_call_builder_createClass(e, r, t) { return r && offer_call_builder_defineProperties(e.prototype, r), t && offer_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function offer_call_builder_toPropertyKey(t) { var i = offer_call_builder_toPrimitive(t, "string"); return "symbol" == offer_call_builder_typeof(i) ? i : i + ""; }
function offer_call_builder_toPrimitive(t, r) { if ("object" != offer_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != offer_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function offer_call_builder_callSuper(t, o, e) { return o = offer_call_builder_getPrototypeOf(o), offer_call_builder_possibleConstructorReturn(t, offer_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], offer_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function offer_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == offer_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return offer_call_builder_assertThisInitialized(t); }
function offer_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function offer_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (offer_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function offer_call_builder_getPrototypeOf(t) { return offer_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, offer_call_builder_getPrototypeOf(t); }
function offer_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && offer_call_builder_setPrototypeOf(t, e); }
function offer_call_builder_setPrototypeOf(t, e) { return offer_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, offer_call_builder_setPrototypeOf(t, e); }

var OfferCallBuilder = function (_CallBuilder) {
  function OfferCallBuilder(serverUrl) {
    var _this;
    offer_call_builder_classCallCheck(this, OfferCallBuilder);
    _this = offer_call_builder_callSuper(this, OfferCallBuilder, [serverUrl, "offers"]);
    _this.url.segment("offers");
    return _this;
  }
  offer_call_builder_inherits(OfferCallBuilder, _CallBuilder);
  return offer_call_builder_createClass(OfferCallBuilder, [{
    key: "offer",
    value: function offer(offerId) {
      var builder = new CallBuilder(this.url.clone());
      builder.filter.push([offerId]);
      return builder;
    }
  }, {
    key: "forAccount",
    value: function forAccount(id) {
      return this.forEndpoint("accounts", id);
    }
  }, {
    key: "buying",
    value: function buying(asset) {
      if (!asset.isNative()) {
        this.url.setQuery("buying_asset_type", asset.getAssetType());
        this.url.setQuery("buying_asset_code", asset.getCode());
        this.url.setQuery("buying_asset_issuer", asset.getIssuer());
      } else {
        this.url.setQuery("buying_asset_type", "native");
      }
      return this;
    }
  }, {
    key: "selling",
    value: function selling(asset) {
      if (!asset.isNative()) {
        this.url.setQuery("selling_asset_type", asset.getAssetType());
        this.url.setQuery("selling_asset_code", asset.getCode());
        this.url.setQuery("selling_asset_issuer", asset.getIssuer());
      } else {
        this.url.setQuery("selling_asset_type", "native");
      }
      return this;
    }
  }, {
    key: "sponsor",
    value: function sponsor(id) {
      this.url.setQuery("sponsor", id);
      return this;
    }
  }, {
    key: "seller",
    value: function seller(_seller) {
      this.url.setQuery("seller", _seller);
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/operation_call_builder.ts
function operation_call_builder_typeof(o) { "@babel/helpers - typeof"; return operation_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, operation_call_builder_typeof(o); }
function operation_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function operation_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, operation_call_builder_toPropertyKey(o.key), o); } }
function operation_call_builder_createClass(e, r, t) { return r && operation_call_builder_defineProperties(e.prototype, r), t && operation_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function operation_call_builder_toPropertyKey(t) { var i = operation_call_builder_toPrimitive(t, "string"); return "symbol" == operation_call_builder_typeof(i) ? i : i + ""; }
function operation_call_builder_toPrimitive(t, r) { if ("object" != operation_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != operation_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function operation_call_builder_callSuper(t, o, e) { return o = operation_call_builder_getPrototypeOf(o), operation_call_builder_possibleConstructorReturn(t, operation_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], operation_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function operation_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == operation_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return operation_call_builder_assertThisInitialized(t); }
function operation_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function operation_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (operation_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function operation_call_builder_getPrototypeOf(t) { return operation_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, operation_call_builder_getPrototypeOf(t); }
function operation_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && operation_call_builder_setPrototypeOf(t, e); }
function operation_call_builder_setPrototypeOf(t, e) { return operation_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, operation_call_builder_setPrototypeOf(t, e); }

var OperationCallBuilder = function (_CallBuilder) {
  function OperationCallBuilder(serverUrl) {
    var _this;
    operation_call_builder_classCallCheck(this, OperationCallBuilder);
    _this = operation_call_builder_callSuper(this, OperationCallBuilder, [serverUrl, "operations"]);
    _this.url.segment("operations");
    return _this;
  }
  operation_call_builder_inherits(OperationCallBuilder, _CallBuilder);
  return operation_call_builder_createClass(OperationCallBuilder, [{
    key: "operation",
    value: function operation(operationId) {
      var builder = new CallBuilder(this.url.clone());
      builder.filter.push([operationId]);
      return builder;
    }
  }, {
    key: "forAccount",
    value: function forAccount(accountId) {
      return this.forEndpoint("accounts", accountId);
    }
  }, {
    key: "forClaimableBalance",
    value: function forClaimableBalance(claimableBalanceId) {
      return this.forEndpoint("claimable_balances", claimableBalanceId);
    }
  }, {
    key: "forLedger",
    value: function forLedger(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    }
  }, {
    key: "forTransaction",
    value: function forTransaction(transactionId) {
      return this.forEndpoint("transactions", transactionId);
    }
  }, {
    key: "forLiquidityPool",
    value: function forLiquidityPool(poolId) {
      return this.forEndpoint("liquidity_pools", poolId);
    }
  }, {
    key: "includeFailed",
    value: function includeFailed(value) {
      this.url.setQuery("include_failed", value.toString());
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/orderbook_call_builder.ts
function orderbook_call_builder_typeof(o) { "@babel/helpers - typeof"; return orderbook_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, orderbook_call_builder_typeof(o); }
function orderbook_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, orderbook_call_builder_toPropertyKey(o.key), o); } }
function orderbook_call_builder_createClass(e, r, t) { return r && orderbook_call_builder_defineProperties(e.prototype, r), t && orderbook_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function orderbook_call_builder_toPropertyKey(t) { var i = orderbook_call_builder_toPrimitive(t, "string"); return "symbol" == orderbook_call_builder_typeof(i) ? i : i + ""; }
function orderbook_call_builder_toPrimitive(t, r) { if ("object" != orderbook_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != orderbook_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function orderbook_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function orderbook_call_builder_callSuper(t, o, e) { return o = orderbook_call_builder_getPrototypeOf(o), orderbook_call_builder_possibleConstructorReturn(t, orderbook_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], orderbook_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function orderbook_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == orderbook_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return orderbook_call_builder_assertThisInitialized(t); }
function orderbook_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function orderbook_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (orderbook_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function orderbook_call_builder_getPrototypeOf(t) { return orderbook_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, orderbook_call_builder_getPrototypeOf(t); }
function orderbook_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && orderbook_call_builder_setPrototypeOf(t, e); }
function orderbook_call_builder_setPrototypeOf(t, e) { return orderbook_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, orderbook_call_builder_setPrototypeOf(t, e); }

var OrderbookCallBuilder = function (_CallBuilder) {
  function OrderbookCallBuilder(serverUrl, selling, buying) {
    var _this;
    orderbook_call_builder_classCallCheck(this, OrderbookCallBuilder);
    _this = orderbook_call_builder_callSuper(this, OrderbookCallBuilder, [serverUrl]);
    _this.url.segment("order_book");
    if (!selling.isNative()) {
      _this.url.setQuery("selling_asset_type", selling.getAssetType());
      _this.url.setQuery("selling_asset_code", selling.getCode());
      _this.url.setQuery("selling_asset_issuer", selling.getIssuer());
    } else {
      _this.url.setQuery("selling_asset_type", "native");
    }
    if (!buying.isNative()) {
      _this.url.setQuery("buying_asset_type", buying.getAssetType());
      _this.url.setQuery("buying_asset_code", buying.getCode());
      _this.url.setQuery("buying_asset_issuer", buying.getIssuer());
    } else {
      _this.url.setQuery("buying_asset_type", "native");
    }
    return _this;
  }
  orderbook_call_builder_inherits(OrderbookCallBuilder, _CallBuilder);
  return orderbook_call_builder_createClass(OrderbookCallBuilder);
}(CallBuilder);
;// ./src/horizon/payment_call_builder.ts
function payment_call_builder_typeof(o) { "@babel/helpers - typeof"; return payment_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, payment_call_builder_typeof(o); }
function payment_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function payment_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, payment_call_builder_toPropertyKey(o.key), o); } }
function payment_call_builder_createClass(e, r, t) { return r && payment_call_builder_defineProperties(e.prototype, r), t && payment_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function payment_call_builder_toPropertyKey(t) { var i = payment_call_builder_toPrimitive(t, "string"); return "symbol" == payment_call_builder_typeof(i) ? i : i + ""; }
function payment_call_builder_toPrimitive(t, r) { if ("object" != payment_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != payment_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function payment_call_builder_callSuper(t, o, e) { return o = payment_call_builder_getPrototypeOf(o), payment_call_builder_possibleConstructorReturn(t, payment_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], payment_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function payment_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == payment_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return payment_call_builder_assertThisInitialized(t); }
function payment_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function payment_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (payment_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function payment_call_builder_getPrototypeOf(t) { return payment_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, payment_call_builder_getPrototypeOf(t); }
function payment_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && payment_call_builder_setPrototypeOf(t, e); }
function payment_call_builder_setPrototypeOf(t, e) { return payment_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, payment_call_builder_setPrototypeOf(t, e); }

var PaymentCallBuilder = function (_CallBuilder) {
  function PaymentCallBuilder(serverUrl) {
    var _this;
    payment_call_builder_classCallCheck(this, PaymentCallBuilder);
    _this = payment_call_builder_callSuper(this, PaymentCallBuilder, [serverUrl, "payments"]);
    _this.url.segment("payments");
    return _this;
  }
  payment_call_builder_inherits(PaymentCallBuilder, _CallBuilder);
  return payment_call_builder_createClass(PaymentCallBuilder, [{
    key: "forAccount",
    value: function forAccount(accountId) {
      return this.forEndpoint("accounts", accountId);
    }
  }, {
    key: "forLedger",
    value: function forLedger(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    }
  }, {
    key: "forTransaction",
    value: function forTransaction(transactionId) {
      return this.forEndpoint("transactions", transactionId);
    }
  }, {
    key: "includeFailed",
    value: function includeFailed(value) {
      this.url.setQuery("include_failed", value.toString());
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/strict_receive_path_call_builder.ts
function strict_receive_path_call_builder_typeof(o) { "@babel/helpers - typeof"; return strict_receive_path_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, strict_receive_path_call_builder_typeof(o); }
function strict_receive_path_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, strict_receive_path_call_builder_toPropertyKey(o.key), o); } }
function strict_receive_path_call_builder_createClass(e, r, t) { return r && strict_receive_path_call_builder_defineProperties(e.prototype, r), t && strict_receive_path_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function strict_receive_path_call_builder_toPropertyKey(t) { var i = strict_receive_path_call_builder_toPrimitive(t, "string"); return "symbol" == strict_receive_path_call_builder_typeof(i) ? i : i + ""; }
function strict_receive_path_call_builder_toPrimitive(t, r) { if ("object" != strict_receive_path_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != strict_receive_path_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function strict_receive_path_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function strict_receive_path_call_builder_callSuper(t, o, e) { return o = strict_receive_path_call_builder_getPrototypeOf(o), strict_receive_path_call_builder_possibleConstructorReturn(t, strict_receive_path_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], strict_receive_path_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function strict_receive_path_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == strict_receive_path_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return strict_receive_path_call_builder_assertThisInitialized(t); }
function strict_receive_path_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function strict_receive_path_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (strict_receive_path_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function strict_receive_path_call_builder_getPrototypeOf(t) { return strict_receive_path_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, strict_receive_path_call_builder_getPrototypeOf(t); }
function strict_receive_path_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && strict_receive_path_call_builder_setPrototypeOf(t, e); }
function strict_receive_path_call_builder_setPrototypeOf(t, e) { return strict_receive_path_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, strict_receive_path_call_builder_setPrototypeOf(t, e); }

var StrictReceivePathCallBuilder = function (_CallBuilder) {
  function StrictReceivePathCallBuilder(serverUrl, source, destinationAsset, destinationAmount) {
    var _this;
    strict_receive_path_call_builder_classCallCheck(this, StrictReceivePathCallBuilder);
    _this = strict_receive_path_call_builder_callSuper(this, StrictReceivePathCallBuilder, [serverUrl]);
    _this.url.segment("paths/strict-receive");
    if (typeof source === "string") {
      _this.url.setQuery("source_account", source);
    } else {
      var assets = source.map(function (asset) {
        if (asset.isNative()) {
          return "native";
        }
        return "".concat(asset.getCode(), ":").concat(asset.getIssuer());
      }).join(",");
      _this.url.setQuery("source_assets", assets);
    }
    _this.url.setQuery("destination_amount", destinationAmount);
    if (!destinationAsset.isNative()) {
      _this.url.setQuery("destination_asset_type", destinationAsset.getAssetType());
      _this.url.setQuery("destination_asset_code", destinationAsset.getCode());
      _this.url.setQuery("destination_asset_issuer", destinationAsset.getIssuer());
    } else {
      _this.url.setQuery("destination_asset_type", "native");
    }
    return _this;
  }
  strict_receive_path_call_builder_inherits(StrictReceivePathCallBuilder, _CallBuilder);
  return strict_receive_path_call_builder_createClass(StrictReceivePathCallBuilder);
}(CallBuilder);
;// ./src/horizon/strict_send_path_call_builder.ts
function strict_send_path_call_builder_typeof(o) { "@babel/helpers - typeof"; return strict_send_path_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, strict_send_path_call_builder_typeof(o); }
function strict_send_path_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, strict_send_path_call_builder_toPropertyKey(o.key), o); } }
function strict_send_path_call_builder_createClass(e, r, t) { return r && strict_send_path_call_builder_defineProperties(e.prototype, r), t && strict_send_path_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function strict_send_path_call_builder_toPropertyKey(t) { var i = strict_send_path_call_builder_toPrimitive(t, "string"); return "symbol" == strict_send_path_call_builder_typeof(i) ? i : i + ""; }
function strict_send_path_call_builder_toPrimitive(t, r) { if ("object" != strict_send_path_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != strict_send_path_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function strict_send_path_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function strict_send_path_call_builder_callSuper(t, o, e) { return o = strict_send_path_call_builder_getPrototypeOf(o), strict_send_path_call_builder_possibleConstructorReturn(t, strict_send_path_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], strict_send_path_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function strict_send_path_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == strict_send_path_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return strict_send_path_call_builder_assertThisInitialized(t); }
function strict_send_path_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function strict_send_path_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (strict_send_path_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function strict_send_path_call_builder_getPrototypeOf(t) { return strict_send_path_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, strict_send_path_call_builder_getPrototypeOf(t); }
function strict_send_path_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && strict_send_path_call_builder_setPrototypeOf(t, e); }
function strict_send_path_call_builder_setPrototypeOf(t, e) { return strict_send_path_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, strict_send_path_call_builder_setPrototypeOf(t, e); }

var StrictSendPathCallBuilder = function (_CallBuilder) {
  function StrictSendPathCallBuilder(serverUrl, sourceAsset, sourceAmount, destination) {
    var _this;
    strict_send_path_call_builder_classCallCheck(this, StrictSendPathCallBuilder);
    _this = strict_send_path_call_builder_callSuper(this, StrictSendPathCallBuilder, [serverUrl]);
    _this.url.segment("paths/strict-send");
    if (sourceAsset.isNative()) {
      _this.url.setQuery("source_asset_type", "native");
    } else {
      _this.url.setQuery("source_asset_type", sourceAsset.getAssetType());
      _this.url.setQuery("source_asset_code", sourceAsset.getCode());
      _this.url.setQuery("source_asset_issuer", sourceAsset.getIssuer());
    }
    _this.url.setQuery("source_amount", sourceAmount);
    if (typeof destination === "string") {
      _this.url.setQuery("destination_account", destination);
    } else {
      var assets = destination.map(function (asset) {
        if (asset.isNative()) {
          return "native";
        }
        return "".concat(asset.getCode(), ":").concat(asset.getIssuer());
      }).join(",");
      _this.url.setQuery("destination_assets", assets);
    }
    return _this;
  }
  strict_send_path_call_builder_inherits(StrictSendPathCallBuilder, _CallBuilder);
  return strict_send_path_call_builder_createClass(StrictSendPathCallBuilder);
}(CallBuilder);
;// ./src/horizon/trade_aggregation_call_builder.ts
function trade_aggregation_call_builder_typeof(o) { "@babel/helpers - typeof"; return trade_aggregation_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, trade_aggregation_call_builder_typeof(o); }
function trade_aggregation_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function trade_aggregation_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, trade_aggregation_call_builder_toPropertyKey(o.key), o); } }
function trade_aggregation_call_builder_createClass(e, r, t) { return r && trade_aggregation_call_builder_defineProperties(e.prototype, r), t && trade_aggregation_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function trade_aggregation_call_builder_toPropertyKey(t) { var i = trade_aggregation_call_builder_toPrimitive(t, "string"); return "symbol" == trade_aggregation_call_builder_typeof(i) ? i : i + ""; }
function trade_aggregation_call_builder_toPrimitive(t, r) { if ("object" != trade_aggregation_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != trade_aggregation_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function trade_aggregation_call_builder_callSuper(t, o, e) { return o = trade_aggregation_call_builder_getPrototypeOf(o), trade_aggregation_call_builder_possibleConstructorReturn(t, trade_aggregation_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], trade_aggregation_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function trade_aggregation_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == trade_aggregation_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return trade_aggregation_call_builder_assertThisInitialized(t); }
function trade_aggregation_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function trade_aggregation_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (trade_aggregation_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function trade_aggregation_call_builder_getPrototypeOf(t) { return trade_aggregation_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, trade_aggregation_call_builder_getPrototypeOf(t); }
function trade_aggregation_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && trade_aggregation_call_builder_setPrototypeOf(t, e); }
function trade_aggregation_call_builder_setPrototypeOf(t, e) { return trade_aggregation_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, trade_aggregation_call_builder_setPrototypeOf(t, e); }


var allowedResolutions = [60000, 300000, 900000, 3600000, 86400000, 604800000];
var TradeAggregationCallBuilder = function (_CallBuilder) {
  function TradeAggregationCallBuilder(serverUrl, base, counter, start_time, end_time, resolution, offset) {
    var _this;
    trade_aggregation_call_builder_classCallCheck(this, TradeAggregationCallBuilder);
    _this = trade_aggregation_call_builder_callSuper(this, TradeAggregationCallBuilder, [serverUrl]);
    _this.url.segment("trade_aggregations");
    if (!base.isNative()) {
      _this.url.setQuery("base_asset_type", base.getAssetType());
      _this.url.setQuery("base_asset_code", base.getCode());
      _this.url.setQuery("base_asset_issuer", base.getIssuer());
    } else {
      _this.url.setQuery("base_asset_type", "native");
    }
    if (!counter.isNative()) {
      _this.url.setQuery("counter_asset_type", counter.getAssetType());
      _this.url.setQuery("counter_asset_code", counter.getCode());
      _this.url.setQuery("counter_asset_issuer", counter.getIssuer());
    } else {
      _this.url.setQuery("counter_asset_type", "native");
    }
    if (typeof start_time !== "number" || typeof end_time !== "number") {
      throw new errors/* BadRequestError */.v7("Invalid time bounds", [start_time, end_time]);
    } else {
      _this.url.setQuery("start_time", start_time.toString());
      _this.url.setQuery("end_time", end_time.toString());
    }
    if (!_this.isValidResolution(resolution)) {
      throw new errors/* BadRequestError */.v7("Invalid resolution", resolution);
    } else {
      _this.url.setQuery("resolution", resolution.toString());
    }
    if (!_this.isValidOffset(offset, resolution)) {
      throw new errors/* BadRequestError */.v7("Invalid offset", offset);
    } else {
      _this.url.setQuery("offset", offset.toString());
    }
    return _this;
  }
  trade_aggregation_call_builder_inherits(TradeAggregationCallBuilder, _CallBuilder);
  return trade_aggregation_call_builder_createClass(TradeAggregationCallBuilder, [{
    key: "isValidResolution",
    value: function isValidResolution(resolution) {
      return allowedResolutions.some(function (allowed) {
        return allowed === resolution;
      });
    }
  }, {
    key: "isValidOffset",
    value: function isValidOffset(offset, resolution) {
      var hour = 3600000;
      return !(offset > resolution || offset >= 24 * hour || offset % hour !== 0);
    }
  }]);
}(CallBuilder);
;// ./src/horizon/trades_call_builder.ts
function trades_call_builder_typeof(o) { "@babel/helpers - typeof"; return trades_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, trades_call_builder_typeof(o); }
function trades_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function trades_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, trades_call_builder_toPropertyKey(o.key), o); } }
function trades_call_builder_createClass(e, r, t) { return r && trades_call_builder_defineProperties(e.prototype, r), t && trades_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function trades_call_builder_toPropertyKey(t) { var i = trades_call_builder_toPrimitive(t, "string"); return "symbol" == trades_call_builder_typeof(i) ? i : i + ""; }
function trades_call_builder_toPrimitive(t, r) { if ("object" != trades_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != trades_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function trades_call_builder_callSuper(t, o, e) { return o = trades_call_builder_getPrototypeOf(o), trades_call_builder_possibleConstructorReturn(t, trades_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], trades_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function trades_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == trades_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return trades_call_builder_assertThisInitialized(t); }
function trades_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function trades_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (trades_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function trades_call_builder_getPrototypeOf(t) { return trades_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, trades_call_builder_getPrototypeOf(t); }
function trades_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && trades_call_builder_setPrototypeOf(t, e); }
function trades_call_builder_setPrototypeOf(t, e) { return trades_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, trades_call_builder_setPrototypeOf(t, e); }

var TradesCallBuilder = function (_CallBuilder) {
  function TradesCallBuilder(serverUrl) {
    var _this;
    trades_call_builder_classCallCheck(this, TradesCallBuilder);
    _this = trades_call_builder_callSuper(this, TradesCallBuilder, [serverUrl, "trades"]);
    _this.url.segment("trades");
    return _this;
  }
  trades_call_builder_inherits(TradesCallBuilder, _CallBuilder);
  return trades_call_builder_createClass(TradesCallBuilder, [{
    key: "forAssetPair",
    value: function forAssetPair(base, counter) {
      if (!base.isNative()) {
        this.url.setQuery("base_asset_type", base.getAssetType());
        this.url.setQuery("base_asset_code", base.getCode());
        this.url.setQuery("base_asset_issuer", base.getIssuer());
      } else {
        this.url.setQuery("base_asset_type", "native");
      }
      if (!counter.isNative()) {
        this.url.setQuery("counter_asset_type", counter.getAssetType());
        this.url.setQuery("counter_asset_code", counter.getCode());
        this.url.setQuery("counter_asset_issuer", counter.getIssuer());
      } else {
        this.url.setQuery("counter_asset_type", "native");
      }
      return this;
    }
  }, {
    key: "forOffer",
    value: function forOffer(offerId) {
      this.url.setQuery("offer_id", offerId);
      return this;
    }
  }, {
    key: "forType",
    value: function forType(tradeType) {
      this.url.setQuery("trade_type", tradeType);
      return this;
    }
  }, {
    key: "forAccount",
    value: function forAccount(accountId) {
      return this.forEndpoint("accounts", accountId);
    }
  }, {
    key: "forLiquidityPool",
    value: function forLiquidityPool(liquidityPoolId) {
      return this.forEndpoint("liquidity_pools", liquidityPoolId);
    }
  }]);
}(CallBuilder);
;// ./src/horizon/transaction_call_builder.ts
function transaction_call_builder_typeof(o) { "@babel/helpers - typeof"; return transaction_call_builder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, transaction_call_builder_typeof(o); }
function transaction_call_builder_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function transaction_call_builder_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, transaction_call_builder_toPropertyKey(o.key), o); } }
function transaction_call_builder_createClass(e, r, t) { return r && transaction_call_builder_defineProperties(e.prototype, r), t && transaction_call_builder_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function transaction_call_builder_toPropertyKey(t) { var i = transaction_call_builder_toPrimitive(t, "string"); return "symbol" == transaction_call_builder_typeof(i) ? i : i + ""; }
function transaction_call_builder_toPrimitive(t, r) { if ("object" != transaction_call_builder_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != transaction_call_builder_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function transaction_call_builder_callSuper(t, o, e) { return o = transaction_call_builder_getPrototypeOf(o), transaction_call_builder_possibleConstructorReturn(t, transaction_call_builder_isNativeReflectConstruct() ? Reflect.construct(o, e || [], transaction_call_builder_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function transaction_call_builder_possibleConstructorReturn(t, e) { if (e && ("object" == transaction_call_builder_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return transaction_call_builder_assertThisInitialized(t); }
function transaction_call_builder_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function transaction_call_builder_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (transaction_call_builder_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function transaction_call_builder_getPrototypeOf(t) { return transaction_call_builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, transaction_call_builder_getPrototypeOf(t); }
function transaction_call_builder_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && transaction_call_builder_setPrototypeOf(t, e); }
function transaction_call_builder_setPrototypeOf(t, e) { return transaction_call_builder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, transaction_call_builder_setPrototypeOf(t, e); }

var TransactionCallBuilder = function (_CallBuilder) {
  function TransactionCallBuilder(serverUrl) {
    var _this;
    transaction_call_builder_classCallCheck(this, TransactionCallBuilder);
    _this = transaction_call_builder_callSuper(this, TransactionCallBuilder, [serverUrl, "transactions"]);
    _this.url.segment("transactions");
    return _this;
  }
  transaction_call_builder_inherits(TransactionCallBuilder, _CallBuilder);
  return transaction_call_builder_createClass(TransactionCallBuilder, [{
    key: "transaction",
    value: function transaction(transactionId) {
      var builder = new CallBuilder(this.url.clone());
      builder.filter.push([transactionId]);
      return builder;
    }
  }, {
    key: "forAccount",
    value: function forAccount(accountId) {
      return this.forEndpoint("accounts", accountId);
    }
  }, {
    key: "forClaimableBalance",
    value: function forClaimableBalance(claimableBalanceId) {
      return this.forEndpoint("claimable_balances", claimableBalanceId);
    }
  }, {
    key: "forLedger",
    value: function forLedger(sequence) {
      return this.forEndpoint("ledgers", sequence.toString());
    }
  }, {
    key: "forLiquidityPool",
    value: function forLiquidityPool(poolId) {
      return this.forEndpoint("liquidity_pools", poolId);
    }
  }, {
    key: "includeFailed",
    value: function includeFailed(value) {
      this.url.setQuery("include_failed", value.toString());
      return this;
    }
  }]);
}(CallBuilder);
;// ./src/horizon/server.ts
function server_typeof(o) { "@babel/helpers - typeof"; return server_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, server_typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = server_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function server_regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return server_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (server_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, server_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, server_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), server_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", server_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), server_regeneratorDefine2(u), server_regeneratorDefine2(u, o, "Generator"), server_regeneratorDefine2(u, n, function () { return this; }), server_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (server_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function server_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } server_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { server_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, server_regeneratorDefine2(e, r, n, t); }
function server_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function server_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { server_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { server_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function server_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function server_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, server_toPropertyKey(o.key), o); } }
function server_createClass(e, r, t) { return r && server_defineProperties(e.prototype, r), t && server_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function server_toPropertyKey(t) { var i = server_toPrimitive(t, "string"); return "symbol" == server_typeof(i) ? i : i + ""; }
function server_toPrimitive(t, r) { if ("object" != server_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != server_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
























var SUBMIT_TRANSACTION_TIMEOUT = 60 * 1000;
var STROOPS_IN_LUMEN = 10000000;
var ACCOUNT_REQUIRES_MEMO = "MQ==";
function getAmountInLumens(amt) {
  return new bignumber(amt).div(STROOPS_IN_LUMEN).toString();
}
var HorizonServer = function () {
  function HorizonServer(serverURL) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    server_classCallCheck(this, HorizonServer);
    this.serverURL = URI_default()(serverURL);
    var allowHttp = typeof opts.allowHttp === "undefined" ? config/* Config */.T.isAllowHttp() : opts.allowHttp;
    var customHeaders = {};
    if (opts.appName) {
      customHeaders["X-App-Name"] = opts.appName;
    }
    if (opts.appVersion) {
      customHeaders["X-App-Version"] = opts.appVersion;
    }
    if (opts.authToken) {
      customHeaders["X-Auth-Token"] = opts.authToken;
    }
    if (opts.headers) {
      Object.assign(customHeaders, opts.headers);
    }
    if (Object.keys(customHeaders).length > 0) {
      horizon_axios_client.interceptors.request.use(function (config) {
        config.headers = config.headers || {};
        config.headers = Object.assign(config.headers, customHeaders);
        return config;
      });
    }
    if (this.serverURL.protocol() !== "https" && !allowHttp) {
      throw new Error("Cannot connect to insecure horizon server");
    }
  }
  return server_createClass(HorizonServer, [{
    key: "fetchTimebounds",
    value: (function () {
      var _fetchTimebounds = server_asyncToGenerator(server_regenerator().m(function _callee(seconds) {
        var _isRetry,
          currentTime,
          _args = arguments;
        return server_regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              _isRetry = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
              currentTime = getCurrentServerTime(this.serverURL.hostname());
              if (!currentTime) {
                _context.n = 1;
                break;
              }
              return _context.a(2, {
                minTime: 0,
                maxTime: currentTime + seconds
              });
            case 1:
              if (!_isRetry) {
                _context.n = 2;
                break;
              }
              return _context.a(2, {
                minTime: 0,
                maxTime: Math.floor(new Date().getTime() / 1000) + seconds
              });
            case 2:
              _context.n = 3;
              return horizon_axios_client.get(URI_default()(this.serverURL).toString());
            case 3:
              return _context.a(2, this.fetchTimebounds(seconds, true));
          }
        }, _callee, this);
      }));
      function fetchTimebounds(_x) {
        return _fetchTimebounds.apply(this, arguments);
      }
      return fetchTimebounds;
    }())
  }, {
    key: "fetchBaseFee",
    value: (function () {
      var _fetchBaseFee = server_asyncToGenerator(server_regenerator().m(function _callee2() {
        var response;
        return server_regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return this.feeStats();
            case 1:
              response = _context2.v;
              return _context2.a(2, parseInt(response.last_ledger_base_fee, 10) || 100);
          }
        }, _callee2, this);
      }));
      function fetchBaseFee() {
        return _fetchBaseFee.apply(this, arguments);
      }
      return fetchBaseFee;
    }())
  }, {
    key: "feeStats",
    value: (function () {
      var _feeStats = server_asyncToGenerator(server_regenerator().m(function _callee3() {
        var cb;
        return server_regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              cb = new CallBuilder(URI_default()(this.serverURL));
              cb.filter.push(["fee_stats"]);
              return _context3.a(2, cb.call());
          }
        }, _callee3, this);
      }));
      function feeStats() {
        return _feeStats.apply(this, arguments);
      }
      return feeStats;
    }())
  }, {
    key: "root",
    value: (function () {
      var _root = server_asyncToGenerator(server_regenerator().m(function _callee4() {
        var cb;
        return server_regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              cb = new CallBuilder(URI_default()(this.serverURL));
              return _context4.a(2, cb.call());
          }
        }, _callee4, this);
      }));
      function root() {
        return _root.apply(this, arguments);
      }
      return root;
    }())
  }, {
    key: "submitTransaction",
    value: (function () {
      var _submitTransaction = server_asyncToGenerator(server_regenerator().m(function _callee5(transaction) {
        var opts,
          tx,
          _args5 = arguments;
        return server_regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {
                skipMemoRequiredCheck: false
              };
              if (opts.skipMemoRequiredCheck) {
                _context5.n = 1;
                break;
              }
              _context5.n = 1;
              return this.checkMemoRequired(transaction);
            case 1:
              tx = encodeURIComponent(transaction.toEnvelope().toXDR().toString("base64"));
              return _context5.a(2, horizon_axios_client.post(URI_default()(this.serverURL).segment("transactions").toString(), "tx=".concat(tx), {
                timeout: SUBMIT_TRANSACTION_TIMEOUT,
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
                }
              }).then(function (response) {
                if (!response.data.result_xdr) {
                  return response.data;
                }
                var responseXDR = stellar_base_min.xdr.TransactionResult.fromXDR(response.data.result_xdr, "base64");
                var results = responseXDR.result().value();
                var offerResults;
                var hasManageOffer;
                if (results.length) {
                  offerResults = results.map(function (result, i) {
                    if (result.value().switch().name !== "manageBuyOffer" && result.value().switch().name !== "manageSellOffer") {
                      return null;
                    }
                    hasManageOffer = true;
                    var amountBought = new bignumber(0);
                    var amountSold = new bignumber(0);
                    var offerSuccess = result.value().value().success();
                    var offersClaimed = offerSuccess.offersClaimed().map(function (offerClaimedAtom) {
                      var offerClaimed = offerClaimedAtom.value();
                      var sellerId = "";
                      switch (offerClaimedAtom.switch()) {
                        case stellar_base_min.xdr.ClaimAtomType.claimAtomTypeV0():
                          sellerId = stellar_base_min.StrKey.encodeEd25519PublicKey(offerClaimed.sellerEd25519());
                          break;
                        case stellar_base_min.xdr.ClaimAtomType.claimAtomTypeOrderBook():
                          sellerId = stellar_base_min.StrKey.encodeEd25519PublicKey(offerClaimed.sellerId().ed25519());
                          break;
                        default:
                          throw new Error("Invalid offer result type: ".concat(offerClaimedAtom.switch()));
                      }
                      var claimedOfferAmountBought = new bignumber(offerClaimed.amountBought().toString());
                      var claimedOfferAmountSold = new bignumber(offerClaimed.amountSold().toString());
                      amountBought = amountBought.plus(claimedOfferAmountSold);
                      amountSold = amountSold.plus(claimedOfferAmountBought);
                      var sold = stellar_base_min.Asset.fromOperation(offerClaimed.assetSold());
                      var bought = stellar_base_min.Asset.fromOperation(offerClaimed.assetBought());
                      var assetSold = {
                        type: sold.getAssetType(),
                        assetCode: sold.getCode(),
                        issuer: sold.getIssuer()
                      };
                      var assetBought = {
                        type: bought.getAssetType(),
                        assetCode: bought.getCode(),
                        issuer: bought.getIssuer()
                      };
                      return {
                        sellerId: sellerId,
                        offerId: offerClaimed.offerId().toString(),
                        assetSold: assetSold,
                        amountSold: getAmountInLumens(claimedOfferAmountSold),
                        assetBought: assetBought,
                        amountBought: getAmountInLumens(claimedOfferAmountBought)
                      };
                    });
                    var effect = offerSuccess.offer().switch().name;
                    var currentOffer;
                    if (typeof offerSuccess.offer().value === "function" && offerSuccess.offer().value()) {
                      var offerXDR = offerSuccess.offer().value();
                      currentOffer = {
                        offerId: offerXDR.offerId().toString(),
                        selling: {},
                        buying: {},
                        amount: getAmountInLumens(offerXDR.amount().toString()),
                        price: {
                          n: offerXDR.price().n(),
                          d: offerXDR.price().d()
                        }
                      };
                      var selling = stellar_base_min.Asset.fromOperation(offerXDR.selling());
                      currentOffer.selling = {
                        type: selling.getAssetType(),
                        assetCode: selling.getCode(),
                        issuer: selling.getIssuer()
                      };
                      var buying = stellar_base_min.Asset.fromOperation(offerXDR.buying());
                      currentOffer.buying = {
                        type: buying.getAssetType(),
                        assetCode: buying.getCode(),
                        issuer: buying.getIssuer()
                      };
                    }
                    return {
                      offersClaimed: offersClaimed,
                      effect: effect,
                      operationIndex: i,
                      currentOffer: currentOffer,
                      amountBought: getAmountInLumens(amountBought),
                      amountSold: getAmountInLumens(amountSold),
                      isFullyOpen: !offersClaimed.length && effect !== "manageOfferDeleted",
                      wasPartiallyFilled: !!offersClaimed.length && effect !== "manageOfferDeleted",
                      wasImmediatelyFilled: !!offersClaimed.length && effect === "manageOfferDeleted",
                      wasImmediatelyDeleted: !offersClaimed.length && effect === "manageOfferDeleted"
                    };
                  }).filter(function (result) {
                    return !!result;
                  });
                }
                return _objectSpread(_objectSpread({}, response.data), {}, {
                  offerResults: hasManageOffer ? offerResults : undefined
                });
              }).catch(function (response) {
                if (response instanceof Error) {
                  return Promise.reject(response);
                }
                return Promise.reject(new errors/* BadResponseError */.nS("Transaction submission failed. Server responded: ".concat(response.status, " ").concat(response.statusText), response.data));
              }));
          }
        }, _callee5, this);
      }));
      function submitTransaction(_x2) {
        return _submitTransaction.apply(this, arguments);
      }
      return submitTransaction;
    }())
  }, {
    key: "submitAsyncTransaction",
    value: (function () {
      var _submitAsyncTransaction = server_asyncToGenerator(server_regenerator().m(function _callee6(transaction) {
        var opts,
          tx,
          _args6 = arguments;
        return server_regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {
                skipMemoRequiredCheck: false
              };
              if (opts.skipMemoRequiredCheck) {
                _context6.n = 1;
                break;
              }
              _context6.n = 1;
              return this.checkMemoRequired(transaction);
            case 1:
              tx = encodeURIComponent(transaction.toEnvelope().toXDR().toString("base64"));
              return _context6.a(2, horizon_axios_client.post(URI_default()(this.serverURL).segment("transactions_async").toString(), "tx=".concat(tx), {
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
                }
              }).then(function (response) {
                return response.data;
              }).catch(function (response) {
                if (response instanceof Error) {
                  return Promise.reject(response);
                }
                return Promise.reject(new errors/* BadResponseError */.nS("Transaction submission failed. Server responded: ".concat(response.status, " ").concat(response.statusText), response.data));
              }));
          }
        }, _callee6, this);
      }));
      function submitAsyncTransaction(_x3) {
        return _submitAsyncTransaction.apply(this, arguments);
      }
      return submitAsyncTransaction;
    }())
  }, {
    key: "accounts",
    value: function accounts() {
      return new AccountCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "claimableBalances",
    value: function claimableBalances() {
      return new ClaimableBalanceCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "ledgers",
    value: function ledgers() {
      return new LedgerCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "transactions",
    value: function transactions() {
      return new TransactionCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "offers",
    value: function offers() {
      return new OfferCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "orderbook",
    value: function orderbook(selling, buying) {
      return new OrderbookCallBuilder(URI_default()(this.serverURL), selling, buying);
    }
  }, {
    key: "trades",
    value: function trades() {
      return new TradesCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "operations",
    value: function operations() {
      return new OperationCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "liquidityPools",
    value: function liquidityPools() {
      return new LiquidityPoolCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "strictReceivePaths",
    value: function strictReceivePaths(source, destinationAsset, destinationAmount) {
      return new StrictReceivePathCallBuilder(URI_default()(this.serverURL), source, destinationAsset, destinationAmount);
    }
  }, {
    key: "strictSendPaths",
    value: function strictSendPaths(sourceAsset, sourceAmount, destination) {
      return new StrictSendPathCallBuilder(URI_default()(this.serverURL), sourceAsset, sourceAmount, destination);
    }
  }, {
    key: "payments",
    value: function payments() {
      return new PaymentCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "effects",
    value: function effects() {
      return new EffectCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "friendbot",
    value: function friendbot(address) {
      return new FriendbotBuilder(URI_default()(this.serverURL), address);
    }
  }, {
    key: "assets",
    value: function assets() {
      return new AssetsCallBuilder(URI_default()(this.serverURL));
    }
  }, {
    key: "loadAccount",
    value: (function () {
      var _loadAccount = server_asyncToGenerator(server_regenerator().m(function _callee7(accountId) {
        var res;
        return server_regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              _context7.n = 1;
              return this.accounts().accountId(accountId).call();
            case 1:
              res = _context7.v;
              return _context7.a(2, new AccountResponse(res));
          }
        }, _callee7, this);
      }));
      function loadAccount(_x4) {
        return _loadAccount.apply(this, arguments);
      }
      return loadAccount;
    }())
  }, {
    key: "tradeAggregation",
    value: function tradeAggregation(base, counter, start_time, end_time, resolution, offset) {
      return new TradeAggregationCallBuilder(URI_default()(this.serverURL), base, counter, start_time, end_time, resolution, offset);
    }
  }, {
    key: "checkMemoRequired",
    value: (function () {
      var _checkMemoRequired = server_asyncToGenerator(server_regenerator().m(function _callee8(transaction) {
        var destinations, i, operation, destination, account, _t, _t2;
        return server_regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              if (transaction instanceof stellar_base_min.FeeBumpTransaction) {
                transaction = transaction.innerTransaction;
              }
              if (!(transaction.memo.type !== "none")) {
                _context8.n = 1;
                break;
              }
              return _context8.a(2);
            case 1:
              destinations = new Set();
              i = 0;
            case 2:
              if (!(i < transaction.operations.length)) {
                _context8.n = 14;
                break;
              }
              operation = transaction.operations[i];
              _t = operation.type;
              _context8.n = _t === "payment" ? 3 : _t === "pathPaymentStrictReceive" ? 3 : _t === "pathPaymentStrictSend" ? 3 : _t === "accountMerge" ? 3 : 4;
              break;
            case 3:
              return _context8.a(3, 5);
            case 4:
              return _context8.a(3, 13);
            case 5:
              destination = operation.destination;
              if (!destinations.has(destination)) {
                _context8.n = 6;
                break;
              }
              return _context8.a(3, 13);
            case 6:
              destinations.add(destination);
              if (!destination.startsWith("M")) {
                _context8.n = 7;
                break;
              }
              return _context8.a(3, 13);
            case 7:
              _context8.p = 7;
              _context8.n = 8;
              return this.loadAccount(destination);
            case 8:
              account = _context8.v;
              if (!(account.data_attr["config.memo_required"] === ACCOUNT_REQUIRES_MEMO)) {
                _context8.n = 9;
                break;
              }
              throw new errors/* AccountRequiresMemoError */.Cu("account requires memo", destination, i);
            case 9:
              _context8.n = 13;
              break;
            case 10:
              _context8.p = 10;
              _t2 = _context8.v;
              if (!(_t2 instanceof errors/* AccountRequiresMemoError */.Cu)) {
                _context8.n = 11;
                break;
              }
              throw _t2;
            case 11:
              if (_t2 instanceof errors/* NotFoundError */.m_) {
                _context8.n = 12;
                break;
              }
              throw _t2;
            case 12:
              return _context8.a(3, 13);
            case 13:
              i += 1;
              _context8.n = 2;
              break;
            case 14:
              return _context8.a(2);
          }
        }, _callee8, this, [[7, 10]]);
      }));
      function checkMemoRequired(_x5) {
        return _checkMemoRequired.apply(this, arguments);
      }
      return checkMemoRequired;
    }())
  }]);
}();
;// ./src/horizon/index.ts
/* module decorator */ module = __webpack_require__.hmd(module);





/* harmony default export */ const horizon = (module.exports);

/***/ }),

/***/ 784:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $D: () => (/* binding */ parseRawLedgerEntries),
/* harmony export */   Af: () => (/* binding */ parseRawSendTransaction),
/* harmony export */   WC: () => (/* binding */ parseTransactionInfo),
/* harmony export */   fG: () => (/* binding */ parseRawEvents),
/* harmony export */   jr: () => (/* binding */ parseRawSimulation),
/* harmony export */   tR: () => (/* binding */ parseRawTransactions)
/* harmony export */ });
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(950);
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


function parseRawSendTransaction(raw) {
  var errorResultXdr = raw.errorResultXdr,
    diagnosticEventsXdr = raw.diagnosticEventsXdr;
  delete raw.errorResultXdr;
  delete raw.diagnosticEventsXdr;
  if (errorResultXdr) {
    return _objectSpread(_objectSpread(_objectSpread({}, raw), diagnosticEventsXdr !== undefined && diagnosticEventsXdr.length > 0 && {
      diagnosticEvents: diagnosticEventsXdr.map(function (evt) {
        return _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.DiagnosticEvent.fromXDR(evt, 'base64');
      })
    }), {}, {
      errorResult: _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.TransactionResult.fromXDR(errorResultXdr, 'base64')
    });
  }
  return _objectSpread({}, raw);
}
function parseTransactionInfo(raw) {
  var _raw$events$contractE, _raw$events, _raw$events$transacti, _raw$events2;
  var meta = _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.TransactionMeta.fromXDR(raw.resultMetaXdr, 'base64');
  var info = {
    ledger: raw.ledger,
    createdAt: raw.createdAt,
    applicationOrder: raw.applicationOrder,
    feeBump: raw.feeBump,
    envelopeXdr: _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.TransactionEnvelope.fromXDR(raw.envelopeXdr, 'base64'),
    resultXdr: _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.TransactionResult.fromXDR(raw.resultXdr, 'base64'),
    resultMetaXdr: meta,
    events: {
      contractEventsXdr: ((_raw$events$contractE = (_raw$events = raw.events) === null || _raw$events === void 0 ? void 0 : _raw$events.contractEventsXdr) !== null && _raw$events$contractE !== void 0 ? _raw$events$contractE : []).map(function (lst) {
        return lst.map(function (e) {
          return _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.ContractEvent.fromXDR(e, "base64");
        });
      }),
      transactionEventsXdr: ((_raw$events$transacti = (_raw$events2 = raw.events) === null || _raw$events2 === void 0 ? void 0 : _raw$events2.transactionEventsXdr) !== null && _raw$events$transacti !== void 0 ? _raw$events$transacti : []).map(function (e) {
        return _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.TransactionEvent.fromXDR(e, "base64");
      })
    }
  };
  switch (meta.switch()) {
    case 3:
    case 4:
      var metaV = meta.value();
      if (metaV.sorobanMeta() !== null) {
        var _metaV$sorobanMeta$re, _metaV$sorobanMeta;
        info.returnValue = (_metaV$sorobanMeta$re = (_metaV$sorobanMeta = metaV.sorobanMeta()) === null || _metaV$sorobanMeta === void 0 ? void 0 : _metaV$sorobanMeta.returnValue()) !== null && _metaV$sorobanMeta$re !== void 0 ? _metaV$sorobanMeta$re : undefined;
      }
  }
  if (raw.diagnosticEventsXdr) {
    info.diagnosticEventsXdr = raw.diagnosticEventsXdr.map(function (e) {
      return _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.DiagnosticEvent.fromXDR(e, 'base64');
    });
  }
  return info;
}
function parseRawTransactions(r) {
  return _objectSpread({
    status: r.status,
    txHash: r.txHash
  }, parseTransactionInfo(r));
}
function parseRawEvents(raw) {
  var _raw$events3;
  return {
    latestLedger: raw.latestLedger,
    oldestLedger: raw.oldestLedger,
    latestLedgerCloseTime: raw.latestLedgerCloseTime,
    oldestLedgerCloseTime: raw.oldestLedgerCloseTime,
    cursor: raw.cursor,
    events: ((_raw$events3 = raw.events) !== null && _raw$events3 !== void 0 ? _raw$events3 : []).map(function (evt) {
      var clone = _objectSpread({}, evt);
      delete clone.contractId;
      return _objectSpread(_objectSpread(_objectSpread({}, clone), evt.contractId !== '' && {
        contractId: new _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.Contract(evt.contractId)
      }), {}, {
        topic: evt.topic.map(function (topic) {
          return _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.ScVal.fromXDR(topic, 'base64');
        }),
        value: _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.ScVal.fromXDR(evt.value, 'base64')
      });
    })
  };
}
function parseRawLedgerEntries(raw) {
  var _raw$entries;
  return {
    latestLedger: raw.latestLedger,
    entries: ((_raw$entries = raw.entries) !== null && _raw$entries !== void 0 ? _raw$entries : []).map(function (rawEntry) {
      if (!rawEntry.key || !rawEntry.xdr) {
        throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(rawEntry)));
      }
      return _objectSpread({
        lastModifiedLedgerSeq: rawEntry.lastModifiedLedgerSeq,
        key: _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.LedgerKey.fromXDR(rawEntry.key, 'base64'),
        val: _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.LedgerEntryData.fromXDR(rawEntry.xdr, 'base64')
      }, rawEntry.liveUntilLedgerSeq !== undefined && {
        liveUntilLedgerSeq: rawEntry.liveUntilLedgerSeq
      });
    })
  };
}
function parseSuccessful(sim, partial) {
  var _sim$results$length, _sim$results, _sim$stateChanges$len, _sim$stateChanges, _sim$stateChanges2;
  var success = _objectSpread(_objectSpread(_objectSpread({}, partial), {}, {
    transactionData: new _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.SorobanDataBuilder(sim.transactionData),
    minResourceFee: sim.minResourceFee
  }, ((_sim$results$length = (_sim$results = sim.results) === null || _sim$results === void 0 ? void 0 : _sim$results.length) !== null && _sim$results$length !== void 0 ? _sim$results$length : 0 > 0) && {
    result: sim.results.map(function (row) {
      var _row$auth;
      return {
        auth: ((_row$auth = row.auth) !== null && _row$auth !== void 0 ? _row$auth : []).map(function (entry) {
          return _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.SorobanAuthorizationEntry.fromXDR(entry, 'base64');
        }),
        retval: row.xdr ? _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.ScVal.fromXDR(row.xdr, 'base64') : _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.ScVal.scvVoid()
      };
    })[0]
  }), ((_sim$stateChanges$len = (_sim$stateChanges = sim.stateChanges) === null || _sim$stateChanges === void 0 ? void 0 : _sim$stateChanges.length) !== null && _sim$stateChanges$len !== void 0 ? _sim$stateChanges$len : 0 > 0) && {
    stateChanges: (_sim$stateChanges2 = sim.stateChanges) === null || _sim$stateChanges2 === void 0 ? void 0 : _sim$stateChanges2.map(function (entryChange) {
      return {
        type: entryChange.type,
        key: _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.LedgerKey.fromXDR(entryChange.key, 'base64'),
        before: entryChange.before ? _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.LedgerEntry.fromXDR(entryChange.before, 'base64') : null,
        after: entryChange.after ? _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.LedgerEntry.fromXDR(entryChange.after, 'base64') : null
      };
    })
  });
  if (!sim.restorePreamble || sim.restorePreamble.transactionData === '') {
    return success;
  }
  return _objectSpread(_objectSpread({}, success), {}, {
    restorePreamble: {
      minResourceFee: sim.restorePreamble.minResourceFee,
      transactionData: new _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.SorobanDataBuilder(sim.restorePreamble.transactionData)
    }
  });
}
function parseRawSimulation(sim) {
  var _sim$events$map, _sim$events;
  var looksRaw = _api__WEBPACK_IMPORTED_MODULE_1__/* .Api */ .j.isSimulationRaw(sim);
  if (!looksRaw) {
    return sim;
  }
  var base = {
    _parsed: true,
    id: sim.id,
    latestLedger: sim.latestLedger,
    events: (_sim$events$map = (_sim$events = sim.events) === null || _sim$events === void 0 ? void 0 : _sim$events.map(function (evt) {
      return _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_0__.xdr.DiagnosticEvent.fromXDR(evt, 'base64');
    })) !== null && _sim$events$map !== void 0 ? _sim$events$map : []
  };
  if (typeof sim.error === 'string') {
    return _objectSpread(_objectSpread({}, base), {}, {
      error: sim.error
    });
  }
  return parseSuccessful(sim, base);
}

/***/ }),

/***/ 861:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(287)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 898:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Api: () => (/* binding */ Api),
/* harmony export */   Resolver: () => (/* binding */ Resolver),
/* harmony export */   STELLAR_TOML_MAX_SIZE: () => (/* binding */ STELLAR_TOML_MAX_SIZE)
/* harmony export */ });
/* harmony import */ var toml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(293);
/* harmony import */ var toml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(toml__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _http_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(983);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(732);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var STELLAR_TOML_MAX_SIZE = 100 * 1024;
var CancelToken = _http_client__WEBPACK_IMPORTED_MODULE_1__/* .httpClient */ .ok.CancelToken;
var Resolver = function () {
  function Resolver() {
    _classCallCheck(this, Resolver);
  }
  return _createClass(Resolver, null, [{
    key: "resolve",
    value: (function () {
      var _resolve = _asyncToGenerator(_regenerator().m(function _callee(domain) {
        var _opts$allowedRedirect;
        var opts,
          allowHttp,
          timeout,
          protocol,
          _args = arguments;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              allowHttp = typeof opts.allowHttp === "undefined" ? _config__WEBPACK_IMPORTED_MODULE_2__/* .Config */ .T.isAllowHttp() : opts.allowHttp;
              timeout = typeof opts.timeout === "undefined" ? _config__WEBPACK_IMPORTED_MODULE_2__/* .Config */ .T.getTimeout() : opts.timeout;
              protocol = allowHttp ? "http" : "https";
              return _context.a(2, _http_client__WEBPACK_IMPORTED_MODULE_1__/* .httpClient */ .ok.get("".concat(protocol, "://").concat(domain, "/.well-known/stellar.toml"), {
                maxRedirects: (_opts$allowedRedirect = opts.allowedRedirects) !== null && _opts$allowedRedirect !== void 0 ? _opts$allowedRedirect : 0,
                maxContentLength: STELLAR_TOML_MAX_SIZE,
                cancelToken: timeout ? new CancelToken(function (cancel) {
                  return setTimeout(function () {
                    return cancel("timeout of ".concat(timeout, "ms exceeded"));
                  }, timeout);
                }) : undefined,
                timeout: timeout
              }).then(function (response) {
                try {
                  var tomlObject = toml__WEBPACK_IMPORTED_MODULE_0___default().parse(response.data);
                  return Promise.resolve(tomlObject);
                } catch (e) {
                  return Promise.reject(new Error("stellar.toml is invalid - Parsing error on line ".concat(e.line, ", column ").concat(e.column, ": ").concat(e.message)));
                }
              }).catch(function (err) {
                if (err.message.match(/^maxContentLength size/)) {
                  throw new Error("stellar.toml file exceeds allowed size of ".concat(STELLAR_TOML_MAX_SIZE));
                } else {
                  throw err;
                }
              }));
          }
        }, _callee);
      }));
      function resolve(_x) {
        return _resolve.apply(this, arguments);
      }
      return resolve;
    }())
  }]);
}();
var Api;

/***/ }),

/***/ 924:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StellarBase: () => (/* reexport module object */ _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   httpClient: () => (/* reexport safe */ _http_client__WEBPACK_IMPORTED_MODULE_0__.ok)
/* harmony export */ });
/* harmony import */ var _http_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(983);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(356);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _index__WEBPACK_IMPORTED_MODULE_1__) if(["default","StellarBase","httpClient"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _index__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(950);
/* harmony import */ var _stellar_stellar_base__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_stellar_stellar_base__WEBPACK_IMPORTED_MODULE_2__);
/* module decorator */ module = __webpack_require__.hmd(module);





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);

/***/ }),

/***/ 950:
/***/ ((module) => {

/*! For license information please see stellar-base.min.js.LICENSE.txt */
!function(e,t){ true?module.exports=t():0}(self,()=>(()=>{var e={41:(e,t,r)=>{"use strict";var n=r(655),o=r(8068),i=r(9675),a=r(5795);e.exports=function(e,t,r){if(!e||"object"!=typeof e&&"function"!=typeof e)throw new i("`obj` must be an object or a function`");if("string"!=typeof t&&"symbol"!=typeof t)throw new i("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!=typeof arguments[3]&&null!==arguments[3])throw new i("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!=typeof arguments[4]&&null!==arguments[4])throw new i("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!=typeof arguments[5]&&null!==arguments[5])throw new i("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!=typeof arguments[6])throw new i("`loose`, if provided, must be a boolean");var s=arguments.length>3?arguments[3]:null,u=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,l=arguments.length>6&&arguments[6],f=!!a&&a(e,t);if(n)n(e,t,{configurable:null===c&&f?f.configurable:!c,enumerable:null===s&&f?f.enumerable:!s,value:r,writable:null===u&&f?f.writable:!u});else{if(!l&&(s||u||c))throw new o("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");e[t]=r}}},76:e=>{"use strict";e.exports=Function.prototype.call},251:(e,t)=>{t.read=function(e,t,r,n,o){var i,a,s=8*o-n-1,u=(1<<s)-1,c=u>>1,l=-7,f=r?o-1:0,p=r?-1:1,d=e[t+f];for(f+=p,i=d&(1<<-l)-1,d>>=-l,l+=s;l>0;i=256*i+e[t+f],f+=p,l-=8);for(a=i&(1<<-l)-1,i>>=-l,l+=n;l>0;a=256*a+e[t+f],f+=p,l-=8);if(0===i)i=1-c;else{if(i===u)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,n),i-=c}return(d?-1:1)*a*Math.pow(2,i-n)},t.write=function(e,t,r,n,o,i){var a,s,u,c=8*i-o-1,l=(1<<c)-1,f=l>>1,p=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:i-1,h=n?1:-1,y=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=l):(a=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-a))<1&&(a--,u*=2),(t+=a+f>=1?p/u:p*Math.pow(2,1-f))*u>=2&&(a++,u/=2),a+f>=l?(s=0,a=l):a+f>=1?(s=(t*u-1)*Math.pow(2,o),a+=f):(s=t*Math.pow(2,f-1)*Math.pow(2,o),a=0));o>=8;e[r+d]=255&s,d+=h,s/=256,o-=8);for(a=a<<o|s,c+=o;c>0;e[r+d]=255&a,d+=h,a/=256,c-=8);e[r+d-h]|=128*y}},392:(e,t,r)=>{"use strict";var n=r(2861).Buffer,o=r(5377);function i(e,t){this._block=n.alloc(e),this._finalSize=t,this._blockSize=e,this._len=0}i.prototype.update=function(e,t){e=o(e,t||"utf8");for(var r=this._block,n=this._blockSize,i=e.length,a=this._len,s=0;s<i;){for(var u=a%n,c=Math.min(i-s,n-u),l=0;l<c;l++)r[u+l]=e[s+l];s+=c,(a+=c)%n===0&&this._update(r)}return this._len+=i,this},i.prototype.digest=function(e){var t=this._len%this._blockSize;this._block[t]=128,this._block.fill(0,t+1),t>=this._finalSize&&(this._update(this._block),this._block.fill(0));var r=8*this._len;if(r<=4294967295)this._block.writeUInt32BE(r,this._blockSize-4);else{var n=(4294967295&r)>>>0,o=(r-n)/4294967296;this._block.writeUInt32BE(o,this._blockSize-8),this._block.writeUInt32BE(n,this._blockSize-4)}this._update(this._block);var i=this._hash();return e?i.toString(e):i},i.prototype._update=function(){throw new Error("_update must be implemented by subclass")},e.exports=i},414:e=>{"use strict";e.exports=Math.round},448:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Account:()=>vo,Address:()=>On,Asset:()=>yr,AuthClawbackEnabledFlag:()=>Fn,AuthImmutableFlag:()=>Ln,AuthRequiredFlag:()=>Un,AuthRevocableFlag:()=>Nn,BASE_FEE:()=>Mo,Claimant:()=>an,Contract:()=>Qo,FeeBumpTransaction:()=>ho,Hyper:()=>n.Hyper,Int128:()=>ki,Int256:()=>Ci,Keypair:()=>lr,LiquidityPoolAsset:()=>tn,LiquidityPoolFeeV18:()=>vr,LiquidityPoolId:()=>ln,Memo:()=>Wn,MemoHash:()=>$n,MemoID:()=>zn,MemoNone:()=>Hn,MemoReturn:()=>Gn,MemoText:()=>Xn,MuxedAccount:()=>Eo,Networks:()=>Ko,Operation:()=>jn,ScInt:()=>Hi,SignerKey:()=>Io,Soroban:()=>Wo,SorobanDataBuilder:()=>Oo,StrKey:()=>tr,TimeoutInfinite:()=>Do,Transaction:()=>oo,TransactionBase:()=>Ar,TransactionBuilder:()=>Vo,Uint128:()=>si,Uint256:()=>yi,UnsignedHyper:()=>n.UnsignedHyper,XdrLargeInt:()=>Li,authorizeEntry:()=>la,authorizeInvocation:()=>pa,buildInvocationTree:()=>ma,cereal:()=>a,decodeAddressToMuxedAccount:()=>pn,default:()=>ba,encodeMuxedAccount:()=>hn,encodeMuxedAccountToAddress:()=>dn,extractBaseAddress:()=>yn,getLiquidityPoolId:()=>br,hash:()=>u,humanizeEvents:()=>oa,nativeToScVal:()=>Ji,scValToBigInt:()=>zi,scValToNative:()=>Qi,sign:()=>qt,verify:()=>Kt,walkInvocationTree:()=>ga,xdr:()=>i});var n=r(3740),o=n.config(function(e){var t=1024;e.typedef("Value",e.varOpaque()),e.struct("ScpBallot",[["counter",e.lookup("Uint32")],["value",e.lookup("Value")]]),e.enum("ScpStatementType",{scpStPrepare:0,scpStConfirm:1,scpStExternalize:2,scpStNominate:3}),e.struct("ScpNomination",[["quorumSetHash",e.lookup("Hash")],["votes",e.varArray(e.lookup("Value"),2147483647)],["accepted",e.varArray(e.lookup("Value"),2147483647)]]),e.struct("ScpStatementPrepare",[["quorumSetHash",e.lookup("Hash")],["ballot",e.lookup("ScpBallot")],["prepared",e.option(e.lookup("ScpBallot"))],["preparedPrime",e.option(e.lookup("ScpBallot"))],["nC",e.lookup("Uint32")],["nH",e.lookup("Uint32")]]),e.struct("ScpStatementConfirm",[["ballot",e.lookup("ScpBallot")],["nPrepared",e.lookup("Uint32")],["nCommit",e.lookup("Uint32")],["nH",e.lookup("Uint32")],["quorumSetHash",e.lookup("Hash")]]),e.struct("ScpStatementExternalize",[["commit",e.lookup("ScpBallot")],["nH",e.lookup("Uint32")],["commitQuorumSetHash",e.lookup("Hash")]]),e.union("ScpStatementPledges",{switchOn:e.lookup("ScpStatementType"),switchName:"type",switches:[["scpStPrepare","prepare"],["scpStConfirm","confirm"],["scpStExternalize","externalize"],["scpStNominate","nominate"]],arms:{prepare:e.lookup("ScpStatementPrepare"),confirm:e.lookup("ScpStatementConfirm"),externalize:e.lookup("ScpStatementExternalize"),nominate:e.lookup("ScpNomination")}}),e.struct("ScpStatement",[["nodeId",e.lookup("NodeId")],["slotIndex",e.lookup("Uint64")],["pledges",e.lookup("ScpStatementPledges")]]),e.struct("ScpEnvelope",[["statement",e.lookup("ScpStatement")],["signature",e.lookup("Signature")]]),e.struct("ScpQuorumSet",[["threshold",e.lookup("Uint32")],["validators",e.varArray(e.lookup("NodeId"),2147483647)],["innerSets",e.varArray(e.lookup("ScpQuorumSet"),2147483647)]]),e.typedef("Thresholds",e.opaque(4)),e.typedef("String32",e.string(32)),e.typedef("String64",e.string(64)),e.typedef("SequenceNumber",e.lookup("Int64")),e.typedef("DataValue",e.varOpaque(64)),e.typedef("AssetCode4",e.opaque(4)),e.typedef("AssetCode12",e.opaque(12)),e.enum("AssetType",{assetTypeNative:0,assetTypeCreditAlphanum4:1,assetTypeCreditAlphanum12:2,assetTypePoolShare:3}),e.union("AssetCode",{switchOn:e.lookup("AssetType"),switchName:"type",switches:[["assetTypeCreditAlphanum4","assetCode4"],["assetTypeCreditAlphanum12","assetCode12"]],arms:{assetCode4:e.lookup("AssetCode4"),assetCode12:e.lookup("AssetCode12")}}),e.struct("AlphaNum4",[["assetCode",e.lookup("AssetCode4")],["issuer",e.lookup("AccountId")]]),e.struct("AlphaNum12",[["assetCode",e.lookup("AssetCode12")],["issuer",e.lookup("AccountId")]]),e.union("Asset",{switchOn:e.lookup("AssetType"),switchName:"type",switches:[["assetTypeNative",e.void()],["assetTypeCreditAlphanum4","alphaNum4"],["assetTypeCreditAlphanum12","alphaNum12"]],arms:{alphaNum4:e.lookup("AlphaNum4"),alphaNum12:e.lookup("AlphaNum12")}}),e.struct("Price",[["n",e.lookup("Int32")],["d",e.lookup("Int32")]]),e.struct("Liabilities",[["buying",e.lookup("Int64")],["selling",e.lookup("Int64")]]),e.enum("ThresholdIndices",{thresholdMasterWeight:0,thresholdLow:1,thresholdMed:2,thresholdHigh:3}),e.enum("LedgerEntryType",{account:0,trustline:1,offer:2,data:3,claimableBalance:4,liquidityPool:5,contractData:6,contractCode:7,configSetting:8,ttl:9}),e.struct("Signer",[["key",e.lookup("SignerKey")],["weight",e.lookup("Uint32")]]),e.enum("AccountFlags",{authRequiredFlag:1,authRevocableFlag:2,authImmutableFlag:4,authClawbackEnabledFlag:8}),e.const("MASK_ACCOUNT_FLAGS",7),e.const("MASK_ACCOUNT_FLAGS_V17",15),e.const("MAX_SIGNERS",20),e.typedef("SponsorshipDescriptor",e.option(e.lookup("AccountId"))),e.struct("AccountEntryExtensionV3",[["ext",e.lookup("ExtensionPoint")],["seqLedger",e.lookup("Uint32")],["seqTime",e.lookup("TimePoint")]]),e.union("AccountEntryExtensionV2Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[3,"v3"]],arms:{v3:e.lookup("AccountEntryExtensionV3")}}),e.struct("AccountEntryExtensionV2",[["numSponsored",e.lookup("Uint32")],["numSponsoring",e.lookup("Uint32")],["signerSponsoringIDs",e.varArray(e.lookup("SponsorshipDescriptor"),e.lookup("MAX_SIGNERS"))],["ext",e.lookup("AccountEntryExtensionV2Ext")]]),e.union("AccountEntryExtensionV1Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[2,"v2"]],arms:{v2:e.lookup("AccountEntryExtensionV2")}}),e.struct("AccountEntryExtensionV1",[["liabilities",e.lookup("Liabilities")],["ext",e.lookup("AccountEntryExtensionV1Ext")]]),e.union("AccountEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("AccountEntryExtensionV1")}}),e.struct("AccountEntry",[["accountId",e.lookup("AccountId")],["balance",e.lookup("Int64")],["seqNum",e.lookup("SequenceNumber")],["numSubEntries",e.lookup("Uint32")],["inflationDest",e.option(e.lookup("AccountId"))],["flags",e.lookup("Uint32")],["homeDomain",e.lookup("String32")],["thresholds",e.lookup("Thresholds")],["signers",e.varArray(e.lookup("Signer"),e.lookup("MAX_SIGNERS"))],["ext",e.lookup("AccountEntryExt")]]),e.enum("TrustLineFlags",{authorizedFlag:1,authorizedToMaintainLiabilitiesFlag:2,trustlineClawbackEnabledFlag:4}),e.const("MASK_TRUSTLINE_FLAGS",1),e.const("MASK_TRUSTLINE_FLAGS_V13",3),e.const("MASK_TRUSTLINE_FLAGS_V17",7),e.enum("LiquidityPoolType",{liquidityPoolConstantProduct:0}),e.union("TrustLineAsset",{switchOn:e.lookup("AssetType"),switchName:"type",switches:[["assetTypeNative",e.void()],["assetTypeCreditAlphanum4","alphaNum4"],["assetTypeCreditAlphanum12","alphaNum12"],["assetTypePoolShare","liquidityPoolId"]],arms:{alphaNum4:e.lookup("AlphaNum4"),alphaNum12:e.lookup("AlphaNum12"),liquidityPoolId:e.lookup("PoolId")}}),e.union("TrustLineEntryExtensionV2Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("TrustLineEntryExtensionV2",[["liquidityPoolUseCount",e.lookup("Int32")],["ext",e.lookup("TrustLineEntryExtensionV2Ext")]]),e.union("TrustLineEntryV1Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[2,"v2"]],arms:{v2:e.lookup("TrustLineEntryExtensionV2")}}),e.struct("TrustLineEntryV1",[["liabilities",e.lookup("Liabilities")],["ext",e.lookup("TrustLineEntryV1Ext")]]),e.union("TrustLineEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("TrustLineEntryV1")}}),e.struct("TrustLineEntry",[["accountId",e.lookup("AccountId")],["asset",e.lookup("TrustLineAsset")],["balance",e.lookup("Int64")],["limit",e.lookup("Int64")],["flags",e.lookup("Uint32")],["ext",e.lookup("TrustLineEntryExt")]]),e.enum("OfferEntryFlags",{passiveFlag:1}),e.const("MASK_OFFERENTRY_FLAGS",1),e.union("OfferEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("OfferEntry",[["sellerId",e.lookup("AccountId")],["offerId",e.lookup("Int64")],["selling",e.lookup("Asset")],["buying",e.lookup("Asset")],["amount",e.lookup("Int64")],["price",e.lookup("Price")],["flags",e.lookup("Uint32")],["ext",e.lookup("OfferEntryExt")]]),e.union("DataEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("DataEntry",[["accountId",e.lookup("AccountId")],["dataName",e.lookup("String64")],["dataValue",e.lookup("DataValue")],["ext",e.lookup("DataEntryExt")]]),e.enum("ClaimPredicateType",{claimPredicateUnconditional:0,claimPredicateAnd:1,claimPredicateOr:2,claimPredicateNot:3,claimPredicateBeforeAbsoluteTime:4,claimPredicateBeforeRelativeTime:5}),e.union("ClaimPredicate",{switchOn:e.lookup("ClaimPredicateType"),switchName:"type",switches:[["claimPredicateUnconditional",e.void()],["claimPredicateAnd","andPredicates"],["claimPredicateOr","orPredicates"],["claimPredicateNot","notPredicate"],["claimPredicateBeforeAbsoluteTime","absBefore"],["claimPredicateBeforeRelativeTime","relBefore"]],arms:{andPredicates:e.varArray(e.lookup("ClaimPredicate"),2),orPredicates:e.varArray(e.lookup("ClaimPredicate"),2),notPredicate:e.option(e.lookup("ClaimPredicate")),absBefore:e.lookup("Int64"),relBefore:e.lookup("Int64")}}),e.enum("ClaimantType",{claimantTypeV0:0}),e.struct("ClaimantV0",[["destination",e.lookup("AccountId")],["predicate",e.lookup("ClaimPredicate")]]),e.union("Claimant",{switchOn:e.lookup("ClaimantType"),switchName:"type",switches:[["claimantTypeV0","v0"]],arms:{v0:e.lookup("ClaimantV0")}}),e.enum("ClaimableBalanceFlags",{claimableBalanceClawbackEnabledFlag:1}),e.const("MASK_CLAIMABLE_BALANCE_FLAGS",1),e.union("ClaimableBalanceEntryExtensionV1Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("ClaimableBalanceEntryExtensionV1",[["ext",e.lookup("ClaimableBalanceEntryExtensionV1Ext")],["flags",e.lookup("Uint32")]]),e.union("ClaimableBalanceEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("ClaimableBalanceEntryExtensionV1")}}),e.struct("ClaimableBalanceEntry",[["balanceId",e.lookup("ClaimableBalanceId")],["claimants",e.varArray(e.lookup("Claimant"),10)],["asset",e.lookup("Asset")],["amount",e.lookup("Int64")],["ext",e.lookup("ClaimableBalanceEntryExt")]]),e.struct("LiquidityPoolConstantProductParameters",[["assetA",e.lookup("Asset")],["assetB",e.lookup("Asset")],["fee",e.lookup("Int32")]]),e.struct("LiquidityPoolEntryConstantProduct",[["params",e.lookup("LiquidityPoolConstantProductParameters")],["reserveA",e.lookup("Int64")],["reserveB",e.lookup("Int64")],["totalPoolShares",e.lookup("Int64")],["poolSharesTrustLineCount",e.lookup("Int64")]]),e.union("LiquidityPoolEntryBody",{switchOn:e.lookup("LiquidityPoolType"),switchName:"type",switches:[["liquidityPoolConstantProduct","constantProduct"]],arms:{constantProduct:e.lookup("LiquidityPoolEntryConstantProduct")}}),e.struct("LiquidityPoolEntry",[["liquidityPoolId",e.lookup("PoolId")],["body",e.lookup("LiquidityPoolEntryBody")]]),e.enum("ContractDataDurability",{temporary:0,persistent:1}),e.struct("ContractDataEntry",[["ext",e.lookup("ExtensionPoint")],["contract",e.lookup("ScAddress")],["key",e.lookup("ScVal")],["durability",e.lookup("ContractDataDurability")],["val",e.lookup("ScVal")]]),e.struct("ContractCodeCostInputs",[["ext",e.lookup("ExtensionPoint")],["nInstructions",e.lookup("Uint32")],["nFunctions",e.lookup("Uint32")],["nGlobals",e.lookup("Uint32")],["nTableEntries",e.lookup("Uint32")],["nTypes",e.lookup("Uint32")],["nDataSegments",e.lookup("Uint32")],["nElemSegments",e.lookup("Uint32")],["nImports",e.lookup("Uint32")],["nExports",e.lookup("Uint32")],["nDataSegmentBytes",e.lookup("Uint32")]]),e.struct("ContractCodeEntryV1",[["ext",e.lookup("ExtensionPoint")],["costInputs",e.lookup("ContractCodeCostInputs")]]),e.union("ContractCodeEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("ContractCodeEntryV1")}}),e.struct("ContractCodeEntry",[["ext",e.lookup("ContractCodeEntryExt")],["hash",e.lookup("Hash")],["code",e.varOpaque()]]),e.struct("TtlEntry",[["keyHash",e.lookup("Hash")],["liveUntilLedgerSeq",e.lookup("Uint32")]]),e.union("LedgerEntryExtensionV1Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("LedgerEntryExtensionV1",[["sponsoringId",e.lookup("SponsorshipDescriptor")],["ext",e.lookup("LedgerEntryExtensionV1Ext")]]),e.union("LedgerEntryData",{switchOn:e.lookup("LedgerEntryType"),switchName:"type",switches:[["account","account"],["trustline","trustLine"],["offer","offer"],["data","data"],["claimableBalance","claimableBalance"],["liquidityPool","liquidityPool"],["contractData","contractData"],["contractCode","contractCode"],["configSetting","configSetting"],["ttl","ttl"]],arms:{account:e.lookup("AccountEntry"),trustLine:e.lookup("TrustLineEntry"),offer:e.lookup("OfferEntry"),data:e.lookup("DataEntry"),claimableBalance:e.lookup("ClaimableBalanceEntry"),liquidityPool:e.lookup("LiquidityPoolEntry"),contractData:e.lookup("ContractDataEntry"),contractCode:e.lookup("ContractCodeEntry"),configSetting:e.lookup("ConfigSettingEntry"),ttl:e.lookup("TtlEntry")}}),e.union("LedgerEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("LedgerEntryExtensionV1")}}),e.struct("LedgerEntry",[["lastModifiedLedgerSeq",e.lookup("Uint32")],["data",e.lookup("LedgerEntryData")],["ext",e.lookup("LedgerEntryExt")]]),e.struct("LedgerKeyAccount",[["accountId",e.lookup("AccountId")]]),e.struct("LedgerKeyTrustLine",[["accountId",e.lookup("AccountId")],["asset",e.lookup("TrustLineAsset")]]),e.struct("LedgerKeyOffer",[["sellerId",e.lookup("AccountId")],["offerId",e.lookup("Int64")]]),e.struct("LedgerKeyData",[["accountId",e.lookup("AccountId")],["dataName",e.lookup("String64")]]),e.struct("LedgerKeyClaimableBalance",[["balanceId",e.lookup("ClaimableBalanceId")]]),e.struct("LedgerKeyLiquidityPool",[["liquidityPoolId",e.lookup("PoolId")]]),e.struct("LedgerKeyContractData",[["contract",e.lookup("ScAddress")],["key",e.lookup("ScVal")],["durability",e.lookup("ContractDataDurability")]]),e.struct("LedgerKeyContractCode",[["hash",e.lookup("Hash")]]),e.struct("LedgerKeyConfigSetting",[["configSettingId",e.lookup("ConfigSettingId")]]),e.struct("LedgerKeyTtl",[["keyHash",e.lookup("Hash")]]),e.union("LedgerKey",{switchOn:e.lookup("LedgerEntryType"),switchName:"type",switches:[["account","account"],["trustline","trustLine"],["offer","offer"],["data","data"],["claimableBalance","claimableBalance"],["liquidityPool","liquidityPool"],["contractData","contractData"],["contractCode","contractCode"],["configSetting","configSetting"],["ttl","ttl"]],arms:{account:e.lookup("LedgerKeyAccount"),trustLine:e.lookup("LedgerKeyTrustLine"),offer:e.lookup("LedgerKeyOffer"),data:e.lookup("LedgerKeyData"),claimableBalance:e.lookup("LedgerKeyClaimableBalance"),liquidityPool:e.lookup("LedgerKeyLiquidityPool"),contractData:e.lookup("LedgerKeyContractData"),contractCode:e.lookup("LedgerKeyContractCode"),configSetting:e.lookup("LedgerKeyConfigSetting"),ttl:e.lookup("LedgerKeyTtl")}}),e.enum("EnvelopeType",{envelopeTypeTxV0:0,envelopeTypeScp:1,envelopeTypeTx:2,envelopeTypeAuth:3,envelopeTypeScpvalue:4,envelopeTypeTxFeeBump:5,envelopeTypeOpId:6,envelopeTypePoolRevokeOpId:7,envelopeTypeContractId:8,envelopeTypeSorobanAuthorization:9}),e.enum("BucketListType",{live:0,hotArchive:1}),e.enum("BucketEntryType",{metaentry:-1,liveentry:0,deadentry:1,initentry:2}),e.enum("HotArchiveBucketEntryType",{hotArchiveMetaentry:-1,hotArchiveArchived:0,hotArchiveLive:1}),e.union("BucketMetadataExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"bucketListType"]],arms:{bucketListType:e.lookup("BucketListType")}}),e.struct("BucketMetadata",[["ledgerVersion",e.lookup("Uint32")],["ext",e.lookup("BucketMetadataExt")]]),e.union("BucketEntry",{switchOn:e.lookup("BucketEntryType"),switchName:"type",switches:[["liveentry","liveEntry"],["initentry","liveEntry"],["deadentry","deadEntry"],["metaentry","metaEntry"]],arms:{liveEntry:e.lookup("LedgerEntry"),deadEntry:e.lookup("LedgerKey"),metaEntry:e.lookup("BucketMetadata")}}),e.union("HotArchiveBucketEntry",{switchOn:e.lookup("HotArchiveBucketEntryType"),switchName:"type",switches:[["hotArchiveArchived","archivedEntry"],["hotArchiveLive","key"],["hotArchiveMetaentry","metaEntry"]],arms:{archivedEntry:e.lookup("LedgerEntry"),key:e.lookup("LedgerKey"),metaEntry:e.lookup("BucketMetadata")}}),e.typedef("UpgradeType",e.varOpaque(128)),e.enum("StellarValueType",{stellarValueBasic:0,stellarValueSigned:1}),e.struct("LedgerCloseValueSignature",[["nodeId",e.lookup("NodeId")],["signature",e.lookup("Signature")]]),e.union("StellarValueExt",{switchOn:e.lookup("StellarValueType"),switchName:"v",switches:[["stellarValueBasic",e.void()],["stellarValueSigned","lcValueSignature"]],arms:{lcValueSignature:e.lookup("LedgerCloseValueSignature")}}),e.struct("StellarValue",[["txSetHash",e.lookup("Hash")],["closeTime",e.lookup("TimePoint")],["upgrades",e.varArray(e.lookup("UpgradeType"),6)],["ext",e.lookup("StellarValueExt")]]),e.const("MASK_LEDGER_HEADER_FLAGS",7),e.enum("LedgerHeaderFlags",{disableLiquidityPoolTradingFlag:1,disableLiquidityPoolDepositFlag:2,disableLiquidityPoolWithdrawalFlag:4}),e.union("LedgerHeaderExtensionV1Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("LedgerHeaderExtensionV1",[["flags",e.lookup("Uint32")],["ext",e.lookup("LedgerHeaderExtensionV1Ext")]]),e.union("LedgerHeaderExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("LedgerHeaderExtensionV1")}}),e.struct("LedgerHeader",[["ledgerVersion",e.lookup("Uint32")],["previousLedgerHash",e.lookup("Hash")],["scpValue",e.lookup("StellarValue")],["txSetResultHash",e.lookup("Hash")],["bucketListHash",e.lookup("Hash")],["ledgerSeq",e.lookup("Uint32")],["totalCoins",e.lookup("Int64")],["feePool",e.lookup("Int64")],["inflationSeq",e.lookup("Uint32")],["idPool",e.lookup("Uint64")],["baseFee",e.lookup("Uint32")],["baseReserve",e.lookup("Uint32")],["maxTxSetSize",e.lookup("Uint32")],["skipList",e.array(e.lookup("Hash"),4)],["ext",e.lookup("LedgerHeaderExt")]]),e.enum("LedgerUpgradeType",{ledgerUpgradeVersion:1,ledgerUpgradeBaseFee:2,ledgerUpgradeMaxTxSetSize:3,ledgerUpgradeBaseReserve:4,ledgerUpgradeFlags:5,ledgerUpgradeConfig:6,ledgerUpgradeMaxSorobanTxSetSize:7}),e.struct("ConfigUpgradeSetKey",[["contractId",e.lookup("ContractId")],["contentHash",e.lookup("Hash")]]),e.union("LedgerUpgrade",{switchOn:e.lookup("LedgerUpgradeType"),switchName:"type",switches:[["ledgerUpgradeVersion","newLedgerVersion"],["ledgerUpgradeBaseFee","newBaseFee"],["ledgerUpgradeMaxTxSetSize","newMaxTxSetSize"],["ledgerUpgradeBaseReserve","newBaseReserve"],["ledgerUpgradeFlags","newFlags"],["ledgerUpgradeConfig","newConfig"],["ledgerUpgradeMaxSorobanTxSetSize","newMaxSorobanTxSetSize"]],arms:{newLedgerVersion:e.lookup("Uint32"),newBaseFee:e.lookup("Uint32"),newMaxTxSetSize:e.lookup("Uint32"),newBaseReserve:e.lookup("Uint32"),newFlags:e.lookup("Uint32"),newConfig:e.lookup("ConfigUpgradeSetKey"),newMaxSorobanTxSetSize:e.lookup("Uint32")}}),e.struct("ConfigUpgradeSet",[["updatedEntry",e.varArray(e.lookup("ConfigSettingEntry"),2147483647)]]),e.enum("TxSetComponentType",{txsetCompTxsMaybeDiscountedFee:0}),e.typedef("DependentTxCluster",e.varArray(e.lookup("TransactionEnvelope"),2147483647)),e.typedef("ParallelTxExecutionStage",e.varArray(e.lookup("DependentTxCluster"),2147483647)),e.struct("ParallelTxsComponent",[["baseFee",e.option(e.lookup("Int64"))],["executionStages",e.varArray(e.lookup("ParallelTxExecutionStage"),2147483647)]]),e.struct("TxSetComponentTxsMaybeDiscountedFee",[["baseFee",e.option(e.lookup("Int64"))],["txes",e.varArray(e.lookup("TransactionEnvelope"),2147483647)]]),e.union("TxSetComponent",{switchOn:e.lookup("TxSetComponentType"),switchName:"type",switches:[["txsetCompTxsMaybeDiscountedFee","txsMaybeDiscountedFee"]],arms:{txsMaybeDiscountedFee:e.lookup("TxSetComponentTxsMaybeDiscountedFee")}}),e.union("TransactionPhase",{switchOn:e.int(),switchName:"v",switches:[[0,"v0Components"],[1,"parallelTxsComponent"]],arms:{v0Components:e.varArray(e.lookup("TxSetComponent"),2147483647),parallelTxsComponent:e.lookup("ParallelTxsComponent")}}),e.struct("TransactionSet",[["previousLedgerHash",e.lookup("Hash")],["txes",e.varArray(e.lookup("TransactionEnvelope"),2147483647)]]),e.struct("TransactionSetV1",[["previousLedgerHash",e.lookup("Hash")],["phases",e.varArray(e.lookup("TransactionPhase"),2147483647)]]),e.union("GeneralizedTransactionSet",{switchOn:e.int(),switchName:"v",switches:[[1,"v1TxSet"]],arms:{v1TxSet:e.lookup("TransactionSetV1")}}),e.struct("TransactionResultPair",[["transactionHash",e.lookup("Hash")],["result",e.lookup("TransactionResult")]]),e.struct("TransactionResultSet",[["results",e.varArray(e.lookup("TransactionResultPair"),2147483647)]]),e.union("TransactionHistoryEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"generalizedTxSet"]],arms:{generalizedTxSet:e.lookup("GeneralizedTransactionSet")}}),e.struct("TransactionHistoryEntry",[["ledgerSeq",e.lookup("Uint32")],["txSet",e.lookup("TransactionSet")],["ext",e.lookup("TransactionHistoryEntryExt")]]),e.union("TransactionHistoryResultEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("TransactionHistoryResultEntry",[["ledgerSeq",e.lookup("Uint32")],["txResultSet",e.lookup("TransactionResultSet")],["ext",e.lookup("TransactionHistoryResultEntryExt")]]),e.union("LedgerHeaderHistoryEntryExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("LedgerHeaderHistoryEntry",[["hash",e.lookup("Hash")],["header",e.lookup("LedgerHeader")],["ext",e.lookup("LedgerHeaderHistoryEntryExt")]]),e.struct("LedgerScpMessages",[["ledgerSeq",e.lookup("Uint32")],["messages",e.varArray(e.lookup("ScpEnvelope"),2147483647)]]),e.struct("ScpHistoryEntryV0",[["quorumSets",e.varArray(e.lookup("ScpQuorumSet"),2147483647)],["ledgerMessages",e.lookup("LedgerScpMessages")]]),e.union("ScpHistoryEntry",{switchOn:e.int(),switchName:"v",switches:[[0,"v0"]],arms:{v0:e.lookup("ScpHistoryEntryV0")}}),e.enum("LedgerEntryChangeType",{ledgerEntryCreated:0,ledgerEntryUpdated:1,ledgerEntryRemoved:2,ledgerEntryState:3,ledgerEntryRestored:4}),e.union("LedgerEntryChange",{switchOn:e.lookup("LedgerEntryChangeType"),switchName:"type",switches:[["ledgerEntryCreated","created"],["ledgerEntryUpdated","updated"],["ledgerEntryRemoved","removed"],["ledgerEntryState","state"],["ledgerEntryRestored","restored"]],arms:{created:e.lookup("LedgerEntry"),updated:e.lookup("LedgerEntry"),removed:e.lookup("LedgerKey"),state:e.lookup("LedgerEntry"),restored:e.lookup("LedgerEntry")}}),e.typedef("LedgerEntryChanges",e.varArray(e.lookup("LedgerEntryChange"),2147483647)),e.struct("OperationMeta",[["changes",e.lookup("LedgerEntryChanges")]]),e.struct("TransactionMetaV1",[["txChanges",e.lookup("LedgerEntryChanges")],["operations",e.varArray(e.lookup("OperationMeta"),2147483647)]]),e.struct("TransactionMetaV2",[["txChangesBefore",e.lookup("LedgerEntryChanges")],["operations",e.varArray(e.lookup("OperationMeta"),2147483647)],["txChangesAfter",e.lookup("LedgerEntryChanges")]]),e.enum("ContractEventType",{system:0,contract:1,diagnostic:2}),e.struct("ContractEventV0",[["topics",e.varArray(e.lookup("ScVal"),2147483647)],["data",e.lookup("ScVal")]]),e.union("ContractEventBody",{switchOn:e.int(),switchName:"v",switches:[[0,"v0"]],arms:{v0:e.lookup("ContractEventV0")}}),e.struct("ContractEvent",[["ext",e.lookup("ExtensionPoint")],["contractId",e.option(e.lookup("ContractId"))],["type",e.lookup("ContractEventType")],["body",e.lookup("ContractEventBody")]]),e.struct("DiagnosticEvent",[["inSuccessfulContractCall",e.bool()],["event",e.lookup("ContractEvent")]]),e.struct("SorobanTransactionMetaExtV1",[["ext",e.lookup("ExtensionPoint")],["totalNonRefundableResourceFeeCharged",e.lookup("Int64")],["totalRefundableResourceFeeCharged",e.lookup("Int64")],["rentFeeCharged",e.lookup("Int64")]]),e.union("SorobanTransactionMetaExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("SorobanTransactionMetaExtV1")}}),e.struct("SorobanTransactionMeta",[["ext",e.lookup("SorobanTransactionMetaExt")],["events",e.varArray(e.lookup("ContractEvent"),2147483647)],["returnValue",e.lookup("ScVal")],["diagnosticEvents",e.varArray(e.lookup("DiagnosticEvent"),2147483647)]]),e.struct("TransactionMetaV3",[["ext",e.lookup("ExtensionPoint")],["txChangesBefore",e.lookup("LedgerEntryChanges")],["operations",e.varArray(e.lookup("OperationMeta"),2147483647)],["txChangesAfter",e.lookup("LedgerEntryChanges")],["sorobanMeta",e.option(e.lookup("SorobanTransactionMeta"))]]),e.struct("OperationMetaV2",[["ext",e.lookup("ExtensionPoint")],["changes",e.lookup("LedgerEntryChanges")],["events",e.varArray(e.lookup("ContractEvent"),2147483647)]]),e.struct("SorobanTransactionMetaV2",[["ext",e.lookup("SorobanTransactionMetaExt")],["returnValue",e.option(e.lookup("ScVal"))]]),e.enum("TransactionEventStage",{transactionEventStageBeforeAllTxes:0,transactionEventStageAfterTx:1,transactionEventStageAfterAllTxes:2}),e.struct("TransactionEvent",[["stage",e.lookup("TransactionEventStage")],["event",e.lookup("ContractEvent")]]),e.struct("TransactionMetaV4",[["ext",e.lookup("ExtensionPoint")],["txChangesBefore",e.lookup("LedgerEntryChanges")],["operations",e.varArray(e.lookup("OperationMetaV2"),2147483647)],["txChangesAfter",e.lookup("LedgerEntryChanges")],["sorobanMeta",e.option(e.lookup("SorobanTransactionMetaV2"))],["events",e.varArray(e.lookup("TransactionEvent"),2147483647)],["diagnosticEvents",e.varArray(e.lookup("DiagnosticEvent"),2147483647)]]),e.struct("InvokeHostFunctionSuccessPreImage",[["returnValue",e.lookup("ScVal")],["events",e.varArray(e.lookup("ContractEvent"),2147483647)]]),e.union("TransactionMeta",{switchOn:e.int(),switchName:"v",switches:[[0,"operations"],[1,"v1"],[2,"v2"],[3,"v3"],[4,"v4"]],arms:{operations:e.varArray(e.lookup("OperationMeta"),2147483647),v1:e.lookup("TransactionMetaV1"),v2:e.lookup("TransactionMetaV2"),v3:e.lookup("TransactionMetaV3"),v4:e.lookup("TransactionMetaV4")}}),e.struct("TransactionResultMeta",[["result",e.lookup("TransactionResultPair")],["feeProcessing",e.lookup("LedgerEntryChanges")],["txApplyProcessing",e.lookup("TransactionMeta")]]),e.struct("TransactionResultMetaV1",[["ext",e.lookup("ExtensionPoint")],["result",e.lookup("TransactionResultPair")],["feeProcessing",e.lookup("LedgerEntryChanges")],["txApplyProcessing",e.lookup("TransactionMeta")],["postTxApplyFeeProcessing",e.lookup("LedgerEntryChanges")]]),e.struct("UpgradeEntryMeta",[["upgrade",e.lookup("LedgerUpgrade")],["changes",e.lookup("LedgerEntryChanges")]]),e.struct("LedgerCloseMetaV0",[["ledgerHeader",e.lookup("LedgerHeaderHistoryEntry")],["txSet",e.lookup("TransactionSet")],["txProcessing",e.varArray(e.lookup("TransactionResultMeta"),2147483647)],["upgradesProcessing",e.varArray(e.lookup("UpgradeEntryMeta"),2147483647)],["scpInfo",e.varArray(e.lookup("ScpHistoryEntry"),2147483647)]]),e.struct("LedgerCloseMetaExtV1",[["ext",e.lookup("ExtensionPoint")],["sorobanFeeWrite1Kb",e.lookup("Int64")]]),e.union("LedgerCloseMetaExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"v1"]],arms:{v1:e.lookup("LedgerCloseMetaExtV1")}}),e.struct("LedgerCloseMetaV1",[["ext",e.lookup("LedgerCloseMetaExt")],["ledgerHeader",e.lookup("LedgerHeaderHistoryEntry")],["txSet",e.lookup("GeneralizedTransactionSet")],["txProcessing",e.varArray(e.lookup("TransactionResultMeta"),2147483647)],["upgradesProcessing",e.varArray(e.lookup("UpgradeEntryMeta"),2147483647)],["scpInfo",e.varArray(e.lookup("ScpHistoryEntry"),2147483647)],["totalByteSizeOfLiveSorobanState",e.lookup("Uint64")],["evictedKeys",e.varArray(e.lookup("LedgerKey"),2147483647)],["unused",e.varArray(e.lookup("LedgerEntry"),2147483647)]]),e.struct("LedgerCloseMetaV2",[["ext",e.lookup("LedgerCloseMetaExt")],["ledgerHeader",e.lookup("LedgerHeaderHistoryEntry")],["txSet",e.lookup("GeneralizedTransactionSet")],["txProcessing",e.varArray(e.lookup("TransactionResultMetaV1"),2147483647)],["upgradesProcessing",e.varArray(e.lookup("UpgradeEntryMeta"),2147483647)],["scpInfo",e.varArray(e.lookup("ScpHistoryEntry"),2147483647)],["totalByteSizeOfLiveSorobanState",e.lookup("Uint64")],["evictedKeys",e.varArray(e.lookup("LedgerKey"),2147483647)]]),e.union("LedgerCloseMeta",{switchOn:e.int(),switchName:"v",switches:[[0,"v0"],[1,"v1"],[2,"v2"]],arms:{v0:e.lookup("LedgerCloseMetaV0"),v1:e.lookup("LedgerCloseMetaV1"),v2:e.lookup("LedgerCloseMetaV2")}}),e.enum("ErrorCode",{errMisc:0,errData:1,errConf:2,errAuth:3,errLoad:4}),e.struct("Error",[["code",e.lookup("ErrorCode")],["msg",e.string(100)]]),e.struct("SendMore",[["numMessages",e.lookup("Uint32")]]),e.struct("SendMoreExtended",[["numMessages",e.lookup("Uint32")],["numBytes",e.lookup("Uint32")]]),e.struct("AuthCert",[["pubkey",e.lookup("Curve25519Public")],["expiration",e.lookup("Uint64")],["sig",e.lookup("Signature")]]),e.struct("Hello",[["ledgerVersion",e.lookup("Uint32")],["overlayVersion",e.lookup("Uint32")],["overlayMinVersion",e.lookup("Uint32")],["networkId",e.lookup("Hash")],["versionStr",e.string(100)],["listeningPort",e.int()],["peerId",e.lookup("NodeId")],["cert",e.lookup("AuthCert")],["nonce",e.lookup("Uint256")]]),e.const("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED",200),e.struct("Auth",[["flags",e.int()]]),e.enum("IpAddrType",{iPv4:0,iPv6:1}),e.union("PeerAddressIp",{switchOn:e.lookup("IpAddrType"),switchName:"type",switches:[["iPv4","ipv4"],["iPv6","ipv6"]],arms:{ipv4:e.opaque(4),ipv6:e.opaque(16)}}),e.struct("PeerAddress",[["ip",e.lookup("PeerAddressIp")],["port",e.lookup("Uint32")],["numFailures",e.lookup("Uint32")]]),e.enum("MessageType",{errorMsg:0,auth:2,dontHave:3,peers:5,getTxSet:6,txSet:7,generalizedTxSet:17,transaction:8,getScpQuorumset:9,scpQuorumset:10,scpMessage:11,getScpState:12,hello:13,sendMore:16,sendMoreExtended:20,floodAdvert:18,floodDemand:19,timeSlicedSurveyRequest:21,timeSlicedSurveyResponse:22,timeSlicedSurveyStartCollecting:23,timeSlicedSurveyStopCollecting:24}),e.struct("DontHave",[["type",e.lookup("MessageType")],["reqHash",e.lookup("Uint256")]]),e.enum("SurveyMessageCommandType",{timeSlicedSurveyTopology:1}),e.enum("SurveyMessageResponseType",{surveyTopologyResponseV2:2}),e.struct("TimeSlicedSurveyStartCollectingMessage",[["surveyorId",e.lookup("NodeId")],["nonce",e.lookup("Uint32")],["ledgerNum",e.lookup("Uint32")]]),e.struct("SignedTimeSlicedSurveyStartCollectingMessage",[["signature",e.lookup("Signature")],["startCollecting",e.lookup("TimeSlicedSurveyStartCollectingMessage")]]),e.struct("TimeSlicedSurveyStopCollectingMessage",[["surveyorId",e.lookup("NodeId")],["nonce",e.lookup("Uint32")],["ledgerNum",e.lookup("Uint32")]]),e.struct("SignedTimeSlicedSurveyStopCollectingMessage",[["signature",e.lookup("Signature")],["stopCollecting",e.lookup("TimeSlicedSurveyStopCollectingMessage")]]),e.struct("SurveyRequestMessage",[["surveyorPeerId",e.lookup("NodeId")],["surveyedPeerId",e.lookup("NodeId")],["ledgerNum",e.lookup("Uint32")],["encryptionKey",e.lookup("Curve25519Public")],["commandType",e.lookup("SurveyMessageCommandType")]]),e.struct("TimeSlicedSurveyRequestMessage",[["request",e.lookup("SurveyRequestMessage")],["nonce",e.lookup("Uint32")],["inboundPeersIndex",e.lookup("Uint32")],["outboundPeersIndex",e.lookup("Uint32")]]),e.struct("SignedTimeSlicedSurveyRequestMessage",[["requestSignature",e.lookup("Signature")],["request",e.lookup("TimeSlicedSurveyRequestMessage")]]),e.typedef("EncryptedBody",e.varOpaque(64e3)),e.struct("SurveyResponseMessage",[["surveyorPeerId",e.lookup("NodeId")],["surveyedPeerId",e.lookup("NodeId")],["ledgerNum",e.lookup("Uint32")],["commandType",e.lookup("SurveyMessageCommandType")],["encryptedBody",e.lookup("EncryptedBody")]]),e.struct("TimeSlicedSurveyResponseMessage",[["response",e.lookup("SurveyResponseMessage")],["nonce",e.lookup("Uint32")]]),e.struct("SignedTimeSlicedSurveyResponseMessage",[["responseSignature",e.lookup("Signature")],["response",e.lookup("TimeSlicedSurveyResponseMessage")]]),e.struct("PeerStats",[["id",e.lookup("NodeId")],["versionStr",e.string(100)],["messagesRead",e.lookup("Uint64")],["messagesWritten",e.lookup("Uint64")],["bytesRead",e.lookup("Uint64")],["bytesWritten",e.lookup("Uint64")],["secondsConnected",e.lookup("Uint64")],["uniqueFloodBytesRecv",e.lookup("Uint64")],["duplicateFloodBytesRecv",e.lookup("Uint64")],["uniqueFetchBytesRecv",e.lookup("Uint64")],["duplicateFetchBytesRecv",e.lookup("Uint64")],["uniqueFloodMessageRecv",e.lookup("Uint64")],["duplicateFloodMessageRecv",e.lookup("Uint64")],["uniqueFetchMessageRecv",e.lookup("Uint64")],["duplicateFetchMessageRecv",e.lookup("Uint64")]]),e.struct("TimeSlicedNodeData",[["addedAuthenticatedPeers",e.lookup("Uint32")],["droppedAuthenticatedPeers",e.lookup("Uint32")],["totalInboundPeerCount",e.lookup("Uint32")],["totalOutboundPeerCount",e.lookup("Uint32")],["p75ScpFirstToSelfLatencyMs",e.lookup("Uint32")],["p75ScpSelfToOtherLatencyMs",e.lookup("Uint32")],["lostSyncCount",e.lookup("Uint32")],["isValidator",e.bool()],["maxInboundPeerCount",e.lookup("Uint32")],["maxOutboundPeerCount",e.lookup("Uint32")]]),e.struct("TimeSlicedPeerData",[["peerStats",e.lookup("PeerStats")],["averageLatencyMs",e.lookup("Uint32")]]),e.typedef("TimeSlicedPeerDataList",e.varArray(e.lookup("TimeSlicedPeerData"),25)),e.struct("TopologyResponseBodyV2",[["inboundPeers",e.lookup("TimeSlicedPeerDataList")],["outboundPeers",e.lookup("TimeSlicedPeerDataList")],["nodeData",e.lookup("TimeSlicedNodeData")]]),e.union("SurveyResponseBody",{switchOn:e.lookup("SurveyMessageResponseType"),switchName:"type",switches:[["surveyTopologyResponseV2","topologyResponseBodyV2"]],arms:{topologyResponseBodyV2:e.lookup("TopologyResponseBodyV2")}}),e.const("TX_ADVERT_VECTOR_MAX_SIZE",1e3),e.typedef("TxAdvertVector",e.varArray(e.lookup("Hash"),e.lookup("TX_ADVERT_VECTOR_MAX_SIZE"))),e.struct("FloodAdvert",[["txHashes",e.lookup("TxAdvertVector")]]),e.const("TX_DEMAND_VECTOR_MAX_SIZE",1e3),e.typedef("TxDemandVector",e.varArray(e.lookup("Hash"),e.lookup("TX_DEMAND_VECTOR_MAX_SIZE"))),e.struct("FloodDemand",[["txHashes",e.lookup("TxDemandVector")]]),e.union("StellarMessage",{switchOn:e.lookup("MessageType"),switchName:"type",switches:[["errorMsg","error"],["hello","hello"],["auth","auth"],["dontHave","dontHave"],["peers","peers"],["getTxSet","txSetHash"],["txSet","txSet"],["generalizedTxSet","generalizedTxSet"],["transaction","transaction"],["timeSlicedSurveyRequest","signedTimeSlicedSurveyRequestMessage"],["timeSlicedSurveyResponse","signedTimeSlicedSurveyResponseMessage"],["timeSlicedSurveyStartCollecting","signedTimeSlicedSurveyStartCollectingMessage"],["timeSlicedSurveyStopCollecting","signedTimeSlicedSurveyStopCollectingMessage"],["getScpQuorumset","qSetHash"],["scpQuorumset","qSet"],["scpMessage","envelope"],["getScpState","getScpLedgerSeq"],["sendMore","sendMoreMessage"],["sendMoreExtended","sendMoreExtendedMessage"],["floodAdvert","floodAdvert"],["floodDemand","floodDemand"]],arms:{error:e.lookup("Error"),hello:e.lookup("Hello"),auth:e.lookup("Auth"),dontHave:e.lookup("DontHave"),peers:e.varArray(e.lookup("PeerAddress"),100),txSetHash:e.lookup("Uint256"),txSet:e.lookup("TransactionSet"),generalizedTxSet:e.lookup("GeneralizedTransactionSet"),transaction:e.lookup("TransactionEnvelope"),signedTimeSlicedSurveyRequestMessage:e.lookup("SignedTimeSlicedSurveyRequestMessage"),signedTimeSlicedSurveyResponseMessage:e.lookup("SignedTimeSlicedSurveyResponseMessage"),signedTimeSlicedSurveyStartCollectingMessage:e.lookup("SignedTimeSlicedSurveyStartCollectingMessage"),signedTimeSlicedSurveyStopCollectingMessage:e.lookup("SignedTimeSlicedSurveyStopCollectingMessage"),qSetHash:e.lookup("Uint256"),qSet:e.lookup("ScpQuorumSet"),envelope:e.lookup("ScpEnvelope"),getScpLedgerSeq:e.lookup("Uint32"),sendMoreMessage:e.lookup("SendMore"),sendMoreExtendedMessage:e.lookup("SendMoreExtended"),floodAdvert:e.lookup("FloodAdvert"),floodDemand:e.lookup("FloodDemand")}}),e.struct("AuthenticatedMessageV0",[["sequence",e.lookup("Uint64")],["message",e.lookup("StellarMessage")],["mac",e.lookup("HmacSha256Mac")]]),e.union("AuthenticatedMessage",{switchOn:e.lookup("Uint32"),switchName:"v",switches:[[0,"v0"]],arms:{v0:e.lookup("AuthenticatedMessageV0")}}),e.const("MAX_OPS_PER_TX",100),e.union("LiquidityPoolParameters",{switchOn:e.lookup("LiquidityPoolType"),switchName:"type",switches:[["liquidityPoolConstantProduct","constantProduct"]],arms:{constantProduct:e.lookup("LiquidityPoolConstantProductParameters")}}),e.struct("MuxedAccountMed25519",[["id",e.lookup("Uint64")],["ed25519",e.lookup("Uint256")]]),e.union("MuxedAccount",{switchOn:e.lookup("CryptoKeyType"),switchName:"type",switches:[["keyTypeEd25519","ed25519"],["keyTypeMuxedEd25519","med25519"]],arms:{ed25519:e.lookup("Uint256"),med25519:e.lookup("MuxedAccountMed25519")}}),e.struct("DecoratedSignature",[["hint",e.lookup("SignatureHint")],["signature",e.lookup("Signature")]]),e.enum("OperationType",{createAccount:0,payment:1,pathPaymentStrictReceive:2,manageSellOffer:3,createPassiveSellOffer:4,setOptions:5,changeTrust:6,allowTrust:7,accountMerge:8,inflation:9,manageData:10,bumpSequence:11,manageBuyOffer:12,pathPaymentStrictSend:13,createClaimableBalance:14,claimClaimableBalance:15,beginSponsoringFutureReserves:16,endSponsoringFutureReserves:17,revokeSponsorship:18,clawback:19,clawbackClaimableBalance:20,setTrustLineFlags:21,liquidityPoolDeposit:22,liquidityPoolWithdraw:23,invokeHostFunction:24,extendFootprintTtl:25,restoreFootprint:26}),e.struct("CreateAccountOp",[["destination",e.lookup("AccountId")],["startingBalance",e.lookup("Int64")]]),e.struct("PaymentOp",[["destination",e.lookup("MuxedAccount")],["asset",e.lookup("Asset")],["amount",e.lookup("Int64")]]),e.struct("PathPaymentStrictReceiveOp",[["sendAsset",e.lookup("Asset")],["sendMax",e.lookup("Int64")],["destination",e.lookup("MuxedAccount")],["destAsset",e.lookup("Asset")],["destAmount",e.lookup("Int64")],["path",e.varArray(e.lookup("Asset"),5)]]),e.struct("PathPaymentStrictSendOp",[["sendAsset",e.lookup("Asset")],["sendAmount",e.lookup("Int64")],["destination",e.lookup("MuxedAccount")],["destAsset",e.lookup("Asset")],["destMin",e.lookup("Int64")],["path",e.varArray(e.lookup("Asset"),5)]]),e.struct("ManageSellOfferOp",[["selling",e.lookup("Asset")],["buying",e.lookup("Asset")],["amount",e.lookup("Int64")],["price",e.lookup("Price")],["offerId",e.lookup("Int64")]]),e.struct("ManageBuyOfferOp",[["selling",e.lookup("Asset")],["buying",e.lookup("Asset")],["buyAmount",e.lookup("Int64")],["price",e.lookup("Price")],["offerId",e.lookup("Int64")]]),e.struct("CreatePassiveSellOfferOp",[["selling",e.lookup("Asset")],["buying",e.lookup("Asset")],["amount",e.lookup("Int64")],["price",e.lookup("Price")]]),e.struct("SetOptionsOp",[["inflationDest",e.option(e.lookup("AccountId"))],["clearFlags",e.option(e.lookup("Uint32"))],["setFlags",e.option(e.lookup("Uint32"))],["masterWeight",e.option(e.lookup("Uint32"))],["lowThreshold",e.option(e.lookup("Uint32"))],["medThreshold",e.option(e.lookup("Uint32"))],["highThreshold",e.option(e.lookup("Uint32"))],["homeDomain",e.option(e.lookup("String32"))],["signer",e.option(e.lookup("Signer"))]]),e.union("ChangeTrustAsset",{switchOn:e.lookup("AssetType"),switchName:"type",switches:[["assetTypeNative",e.void()],["assetTypeCreditAlphanum4","alphaNum4"],["assetTypeCreditAlphanum12","alphaNum12"],["assetTypePoolShare","liquidityPool"]],arms:{alphaNum4:e.lookup("AlphaNum4"),alphaNum12:e.lookup("AlphaNum12"),liquidityPool:e.lookup("LiquidityPoolParameters")}}),e.struct("ChangeTrustOp",[["line",e.lookup("ChangeTrustAsset")],["limit",e.lookup("Int64")]]),e.struct("AllowTrustOp",[["trustor",e.lookup("AccountId")],["asset",e.lookup("AssetCode")],["authorize",e.lookup("Uint32")]]),e.struct("ManageDataOp",[["dataName",e.lookup("String64")],["dataValue",e.option(e.lookup("DataValue"))]]),e.struct("BumpSequenceOp",[["bumpTo",e.lookup("SequenceNumber")]]),e.struct("CreateClaimableBalanceOp",[["asset",e.lookup("Asset")],["amount",e.lookup("Int64")],["claimants",e.varArray(e.lookup("Claimant"),10)]]),e.struct("ClaimClaimableBalanceOp",[["balanceId",e.lookup("ClaimableBalanceId")]]),e.struct("BeginSponsoringFutureReservesOp",[["sponsoredId",e.lookup("AccountId")]]),e.enum("RevokeSponsorshipType",{revokeSponsorshipLedgerEntry:0,revokeSponsorshipSigner:1}),e.struct("RevokeSponsorshipOpSigner",[["accountId",e.lookup("AccountId")],["signerKey",e.lookup("SignerKey")]]),e.union("RevokeSponsorshipOp",{switchOn:e.lookup("RevokeSponsorshipType"),switchName:"type",switches:[["revokeSponsorshipLedgerEntry","ledgerKey"],["revokeSponsorshipSigner","signer"]],arms:{ledgerKey:e.lookup("LedgerKey"),signer:e.lookup("RevokeSponsorshipOpSigner")}}),e.struct("ClawbackOp",[["asset",e.lookup("Asset")],["from",e.lookup("MuxedAccount")],["amount",e.lookup("Int64")]]),e.struct("ClawbackClaimableBalanceOp",[["balanceId",e.lookup("ClaimableBalanceId")]]),e.struct("SetTrustLineFlagsOp",[["trustor",e.lookup("AccountId")],["asset",e.lookup("Asset")],["clearFlags",e.lookup("Uint32")],["setFlags",e.lookup("Uint32")]]),e.const("LIQUIDITY_POOL_FEE_V18",30),e.struct("LiquidityPoolDepositOp",[["liquidityPoolId",e.lookup("PoolId")],["maxAmountA",e.lookup("Int64")],["maxAmountB",e.lookup("Int64")],["minPrice",e.lookup("Price")],["maxPrice",e.lookup("Price")]]),e.struct("LiquidityPoolWithdrawOp",[["liquidityPoolId",e.lookup("PoolId")],["amount",e.lookup("Int64")],["minAmountA",e.lookup("Int64")],["minAmountB",e.lookup("Int64")]]),e.enum("HostFunctionType",{hostFunctionTypeInvokeContract:0,hostFunctionTypeCreateContract:1,hostFunctionTypeUploadContractWasm:2,hostFunctionTypeCreateContractV2:3}),e.enum("ContractIdPreimageType",{contractIdPreimageFromAddress:0,contractIdPreimageFromAsset:1}),e.struct("ContractIdPreimageFromAddress",[["address",e.lookup("ScAddress")],["salt",e.lookup("Uint256")]]),e.union("ContractIdPreimage",{switchOn:e.lookup("ContractIdPreimageType"),switchName:"type",switches:[["contractIdPreimageFromAddress","fromAddress"],["contractIdPreimageFromAsset","fromAsset"]],arms:{fromAddress:e.lookup("ContractIdPreimageFromAddress"),fromAsset:e.lookup("Asset")}}),e.struct("CreateContractArgs",[["contractIdPreimage",e.lookup("ContractIdPreimage")],["executable",e.lookup("ContractExecutable")]]),e.struct("CreateContractArgsV2",[["contractIdPreimage",e.lookup("ContractIdPreimage")],["executable",e.lookup("ContractExecutable")],["constructorArgs",e.varArray(e.lookup("ScVal"),2147483647)]]),e.struct("InvokeContractArgs",[["contractAddress",e.lookup("ScAddress")],["functionName",e.lookup("ScSymbol")],["args",e.varArray(e.lookup("ScVal"),2147483647)]]),e.union("HostFunction",{switchOn:e.lookup("HostFunctionType"),switchName:"type",switches:[["hostFunctionTypeInvokeContract","invokeContract"],["hostFunctionTypeCreateContract","createContract"],["hostFunctionTypeUploadContractWasm","wasm"],["hostFunctionTypeCreateContractV2","createContractV2"]],arms:{invokeContract:e.lookup("InvokeContractArgs"),createContract:e.lookup("CreateContractArgs"),wasm:e.varOpaque(),createContractV2:e.lookup("CreateContractArgsV2")}}),e.enum("SorobanAuthorizedFunctionType",{sorobanAuthorizedFunctionTypeContractFn:0,sorobanAuthorizedFunctionTypeCreateContractHostFn:1,sorobanAuthorizedFunctionTypeCreateContractV2HostFn:2}),e.union("SorobanAuthorizedFunction",{switchOn:e.lookup("SorobanAuthorizedFunctionType"),switchName:"type",switches:[["sorobanAuthorizedFunctionTypeContractFn","contractFn"],["sorobanAuthorizedFunctionTypeCreateContractHostFn","createContractHostFn"],["sorobanAuthorizedFunctionTypeCreateContractV2HostFn","createContractV2HostFn"]],arms:{contractFn:e.lookup("InvokeContractArgs"),createContractHostFn:e.lookup("CreateContractArgs"),createContractV2HostFn:e.lookup("CreateContractArgsV2")}}),e.struct("SorobanAuthorizedInvocation",[["function",e.lookup("SorobanAuthorizedFunction")],["subInvocations",e.varArray(e.lookup("SorobanAuthorizedInvocation"),2147483647)]]),e.struct("SorobanAddressCredentials",[["address",e.lookup("ScAddress")],["nonce",e.lookup("Int64")],["signatureExpirationLedger",e.lookup("Uint32")],["signature",e.lookup("ScVal")]]),e.enum("SorobanCredentialsType",{sorobanCredentialsSourceAccount:0,sorobanCredentialsAddress:1}),e.union("SorobanCredentials",{switchOn:e.lookup("SorobanCredentialsType"),switchName:"type",switches:[["sorobanCredentialsSourceAccount",e.void()],["sorobanCredentialsAddress","address"]],arms:{address:e.lookup("SorobanAddressCredentials")}}),e.struct("SorobanAuthorizationEntry",[["credentials",e.lookup("SorobanCredentials")],["rootInvocation",e.lookup("SorobanAuthorizedInvocation")]]),e.typedef("SorobanAuthorizationEntries",e.varArray(e.lookup("SorobanAuthorizationEntry"),2147483647)),e.struct("InvokeHostFunctionOp",[["hostFunction",e.lookup("HostFunction")],["auth",e.varArray(e.lookup("SorobanAuthorizationEntry"),2147483647)]]),e.struct("ExtendFootprintTtlOp",[["ext",e.lookup("ExtensionPoint")],["extendTo",e.lookup("Uint32")]]),e.struct("RestoreFootprintOp",[["ext",e.lookup("ExtensionPoint")]]),e.union("OperationBody",{switchOn:e.lookup("OperationType"),switchName:"type",switches:[["createAccount","createAccountOp"],["payment","paymentOp"],["pathPaymentStrictReceive","pathPaymentStrictReceiveOp"],["manageSellOffer","manageSellOfferOp"],["createPassiveSellOffer","createPassiveSellOfferOp"],["setOptions","setOptionsOp"],["changeTrust","changeTrustOp"],["allowTrust","allowTrustOp"],["accountMerge","destination"],["inflation",e.void()],["manageData","manageDataOp"],["bumpSequence","bumpSequenceOp"],["manageBuyOffer","manageBuyOfferOp"],["pathPaymentStrictSend","pathPaymentStrictSendOp"],["createClaimableBalance","createClaimableBalanceOp"],["claimClaimableBalance","claimClaimableBalanceOp"],["beginSponsoringFutureReserves","beginSponsoringFutureReservesOp"],["endSponsoringFutureReserves",e.void()],["revokeSponsorship","revokeSponsorshipOp"],["clawback","clawbackOp"],["clawbackClaimableBalance","clawbackClaimableBalanceOp"],["setTrustLineFlags","setTrustLineFlagsOp"],["liquidityPoolDeposit","liquidityPoolDepositOp"],["liquidityPoolWithdraw","liquidityPoolWithdrawOp"],["invokeHostFunction","invokeHostFunctionOp"],["extendFootprintTtl","extendFootprintTtlOp"],["restoreFootprint","restoreFootprintOp"]],arms:{createAccountOp:e.lookup("CreateAccountOp"),paymentOp:e.lookup("PaymentOp"),pathPaymentStrictReceiveOp:e.lookup("PathPaymentStrictReceiveOp"),manageSellOfferOp:e.lookup("ManageSellOfferOp"),createPassiveSellOfferOp:e.lookup("CreatePassiveSellOfferOp"),setOptionsOp:e.lookup("SetOptionsOp"),changeTrustOp:e.lookup("ChangeTrustOp"),allowTrustOp:e.lookup("AllowTrustOp"),destination:e.lookup("MuxedAccount"),manageDataOp:e.lookup("ManageDataOp"),bumpSequenceOp:e.lookup("BumpSequenceOp"),manageBuyOfferOp:e.lookup("ManageBuyOfferOp"),pathPaymentStrictSendOp:e.lookup("PathPaymentStrictSendOp"),createClaimableBalanceOp:e.lookup("CreateClaimableBalanceOp"),claimClaimableBalanceOp:e.lookup("ClaimClaimableBalanceOp"),beginSponsoringFutureReservesOp:e.lookup("BeginSponsoringFutureReservesOp"),revokeSponsorshipOp:e.lookup("RevokeSponsorshipOp"),clawbackOp:e.lookup("ClawbackOp"),clawbackClaimableBalanceOp:e.lookup("ClawbackClaimableBalanceOp"),setTrustLineFlagsOp:e.lookup("SetTrustLineFlagsOp"),liquidityPoolDepositOp:e.lookup("LiquidityPoolDepositOp"),liquidityPoolWithdrawOp:e.lookup("LiquidityPoolWithdrawOp"),invokeHostFunctionOp:e.lookup("InvokeHostFunctionOp"),extendFootprintTtlOp:e.lookup("ExtendFootprintTtlOp"),restoreFootprintOp:e.lookup("RestoreFootprintOp")}}),e.struct("Operation",[["sourceAccount",e.option(e.lookup("MuxedAccount"))],["body",e.lookup("OperationBody")]]),e.struct("HashIdPreimageOperationId",[["sourceAccount",e.lookup("AccountId")],["seqNum",e.lookup("SequenceNumber")],["opNum",e.lookup("Uint32")]]),e.struct("HashIdPreimageRevokeId",[["sourceAccount",e.lookup("AccountId")],["seqNum",e.lookup("SequenceNumber")],["opNum",e.lookup("Uint32")],["liquidityPoolId",e.lookup("PoolId")],["asset",e.lookup("Asset")]]),e.struct("HashIdPreimageContractId",[["networkId",e.lookup("Hash")],["contractIdPreimage",e.lookup("ContractIdPreimage")]]),e.struct("HashIdPreimageSorobanAuthorization",[["networkId",e.lookup("Hash")],["nonce",e.lookup("Int64")],["signatureExpirationLedger",e.lookup("Uint32")],["invocation",e.lookup("SorobanAuthorizedInvocation")]]),e.union("HashIdPreimage",{switchOn:e.lookup("EnvelopeType"),switchName:"type",switches:[["envelopeTypeOpId","operationId"],["envelopeTypePoolRevokeOpId","revokeId"],["envelopeTypeContractId","contractId"],["envelopeTypeSorobanAuthorization","sorobanAuthorization"]],arms:{operationId:e.lookup("HashIdPreimageOperationId"),revokeId:e.lookup("HashIdPreimageRevokeId"),contractId:e.lookup("HashIdPreimageContractId"),sorobanAuthorization:e.lookup("HashIdPreimageSorobanAuthorization")}}),e.enum("MemoType",{memoNone:0,memoText:1,memoId:2,memoHash:3,memoReturn:4}),e.union("Memo",{switchOn:e.lookup("MemoType"),switchName:"type",switches:[["memoNone",e.void()],["memoText","text"],["memoId","id"],["memoHash","hash"],["memoReturn","retHash"]],arms:{text:e.string(28),id:e.lookup("Uint64"),hash:e.lookup("Hash"),retHash:e.lookup("Hash")}}),e.struct("TimeBounds",[["minTime",e.lookup("TimePoint")],["maxTime",e.lookup("TimePoint")]]),e.struct("LedgerBounds",[["minLedger",e.lookup("Uint32")],["maxLedger",e.lookup("Uint32")]]),e.struct("PreconditionsV2",[["timeBounds",e.option(e.lookup("TimeBounds"))],["ledgerBounds",e.option(e.lookup("LedgerBounds"))],["minSeqNum",e.option(e.lookup("SequenceNumber"))],["minSeqAge",e.lookup("Duration")],["minSeqLedgerGap",e.lookup("Uint32")],["extraSigners",e.varArray(e.lookup("SignerKey"),2)]]),e.enum("PreconditionType",{precondNone:0,precondTime:1,precondV2:2}),e.union("Preconditions",{switchOn:e.lookup("PreconditionType"),switchName:"type",switches:[["precondNone",e.void()],["precondTime","timeBounds"],["precondV2","v2"]],arms:{timeBounds:e.lookup("TimeBounds"),v2:e.lookup("PreconditionsV2")}}),e.struct("LedgerFootprint",[["readOnly",e.varArray(e.lookup("LedgerKey"),2147483647)],["readWrite",e.varArray(e.lookup("LedgerKey"),2147483647)]]),e.struct("SorobanResources",[["footprint",e.lookup("LedgerFootprint")],["instructions",e.lookup("Uint32")],["diskReadBytes",e.lookup("Uint32")],["writeBytes",e.lookup("Uint32")]]),e.struct("SorobanResourcesExtV0",[["archivedSorobanEntries",e.varArray(e.lookup("Uint32"),2147483647)]]),e.union("SorobanTransactionDataExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"resourceExt"]],arms:{resourceExt:e.lookup("SorobanResourcesExtV0")}}),e.struct("SorobanTransactionData",[["ext",e.lookup("SorobanTransactionDataExt")],["resources",e.lookup("SorobanResources")],["resourceFee",e.lookup("Int64")]]),e.union("TransactionV0Ext",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("TransactionV0",[["sourceAccountEd25519",e.lookup("Uint256")],["fee",e.lookup("Uint32")],["seqNum",e.lookup("SequenceNumber")],["timeBounds",e.option(e.lookup("TimeBounds"))],["memo",e.lookup("Memo")],["operations",e.varArray(e.lookup("Operation"),e.lookup("MAX_OPS_PER_TX"))],["ext",e.lookup("TransactionV0Ext")]]),e.struct("TransactionV0Envelope",[["tx",e.lookup("TransactionV0")],["signatures",e.varArray(e.lookup("DecoratedSignature"),20)]]),e.union("TransactionExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()],[1,"sorobanData"]],arms:{sorobanData:e.lookup("SorobanTransactionData")}}),e.struct("Transaction",[["sourceAccount",e.lookup("MuxedAccount")],["fee",e.lookup("Uint32")],["seqNum",e.lookup("SequenceNumber")],["cond",e.lookup("Preconditions")],["memo",e.lookup("Memo")],["operations",e.varArray(e.lookup("Operation"),e.lookup("MAX_OPS_PER_TX"))],["ext",e.lookup("TransactionExt")]]),e.struct("TransactionV1Envelope",[["tx",e.lookup("Transaction")],["signatures",e.varArray(e.lookup("DecoratedSignature"),20)]]),e.union("FeeBumpTransactionInnerTx",{switchOn:e.lookup("EnvelopeType"),switchName:"type",switches:[["envelopeTypeTx","v1"]],arms:{v1:e.lookup("TransactionV1Envelope")}}),e.union("FeeBumpTransactionExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("FeeBumpTransaction",[["feeSource",e.lookup("MuxedAccount")],["fee",e.lookup("Int64")],["innerTx",e.lookup("FeeBumpTransactionInnerTx")],["ext",e.lookup("FeeBumpTransactionExt")]]),e.struct("FeeBumpTransactionEnvelope",[["tx",e.lookup("FeeBumpTransaction")],["signatures",e.varArray(e.lookup("DecoratedSignature"),20)]]),e.union("TransactionEnvelope",{switchOn:e.lookup("EnvelopeType"),switchName:"type",switches:[["envelopeTypeTxV0","v0"],["envelopeTypeTx","v1"],["envelopeTypeTxFeeBump","feeBump"]],arms:{v0:e.lookup("TransactionV0Envelope"),v1:e.lookup("TransactionV1Envelope"),feeBump:e.lookup("FeeBumpTransactionEnvelope")}}),e.union("TransactionSignaturePayloadTaggedTransaction",{switchOn:e.lookup("EnvelopeType"),switchName:"type",switches:[["envelopeTypeTx","tx"],["envelopeTypeTxFeeBump","feeBump"]],arms:{tx:e.lookup("Transaction"),feeBump:e.lookup("FeeBumpTransaction")}}),e.struct("TransactionSignaturePayload",[["networkId",e.lookup("Hash")],["taggedTransaction",e.lookup("TransactionSignaturePayloadTaggedTransaction")]]),e.enum("ClaimAtomType",{claimAtomTypeV0:0,claimAtomTypeOrderBook:1,claimAtomTypeLiquidityPool:2}),e.struct("ClaimOfferAtomV0",[["sellerEd25519",e.lookup("Uint256")],["offerId",e.lookup("Int64")],["assetSold",e.lookup("Asset")],["amountSold",e.lookup("Int64")],["assetBought",e.lookup("Asset")],["amountBought",e.lookup("Int64")]]),e.struct("ClaimOfferAtom",[["sellerId",e.lookup("AccountId")],["offerId",e.lookup("Int64")],["assetSold",e.lookup("Asset")],["amountSold",e.lookup("Int64")],["assetBought",e.lookup("Asset")],["amountBought",e.lookup("Int64")]]),e.struct("ClaimLiquidityAtom",[["liquidityPoolId",e.lookup("PoolId")],["assetSold",e.lookup("Asset")],["amountSold",e.lookup("Int64")],["assetBought",e.lookup("Asset")],["amountBought",e.lookup("Int64")]]),e.union("ClaimAtom",{switchOn:e.lookup("ClaimAtomType"),switchName:"type",switches:[["claimAtomTypeV0","v0"],["claimAtomTypeOrderBook","orderBook"],["claimAtomTypeLiquidityPool","liquidityPool"]],arms:{v0:e.lookup("ClaimOfferAtomV0"),orderBook:e.lookup("ClaimOfferAtom"),liquidityPool:e.lookup("ClaimLiquidityAtom")}}),e.enum("CreateAccountResultCode",{createAccountSuccess:0,createAccountMalformed:-1,createAccountUnderfunded:-2,createAccountLowReserve:-3,createAccountAlreadyExist:-4}),e.union("CreateAccountResult",{switchOn:e.lookup("CreateAccountResultCode"),switchName:"code",switches:[["createAccountSuccess",e.void()],["createAccountMalformed",e.void()],["createAccountUnderfunded",e.void()],["createAccountLowReserve",e.void()],["createAccountAlreadyExist",e.void()]],arms:{}}),e.enum("PaymentResultCode",{paymentSuccess:0,paymentMalformed:-1,paymentUnderfunded:-2,paymentSrcNoTrust:-3,paymentSrcNotAuthorized:-4,paymentNoDestination:-5,paymentNoTrust:-6,paymentNotAuthorized:-7,paymentLineFull:-8,paymentNoIssuer:-9}),e.union("PaymentResult",{switchOn:e.lookup("PaymentResultCode"),switchName:"code",switches:[["paymentSuccess",e.void()],["paymentMalformed",e.void()],["paymentUnderfunded",e.void()],["paymentSrcNoTrust",e.void()],["paymentSrcNotAuthorized",e.void()],["paymentNoDestination",e.void()],["paymentNoTrust",e.void()],["paymentNotAuthorized",e.void()],["paymentLineFull",e.void()],["paymentNoIssuer",e.void()]],arms:{}}),e.enum("PathPaymentStrictReceiveResultCode",{pathPaymentStrictReceiveSuccess:0,pathPaymentStrictReceiveMalformed:-1,pathPaymentStrictReceiveUnderfunded:-2,pathPaymentStrictReceiveSrcNoTrust:-3,pathPaymentStrictReceiveSrcNotAuthorized:-4,pathPaymentStrictReceiveNoDestination:-5,pathPaymentStrictReceiveNoTrust:-6,pathPaymentStrictReceiveNotAuthorized:-7,pathPaymentStrictReceiveLineFull:-8,pathPaymentStrictReceiveNoIssuer:-9,pathPaymentStrictReceiveTooFewOffers:-10,pathPaymentStrictReceiveOfferCrossSelf:-11,pathPaymentStrictReceiveOverSendmax:-12}),e.struct("SimplePaymentResult",[["destination",e.lookup("AccountId")],["asset",e.lookup("Asset")],["amount",e.lookup("Int64")]]),e.struct("PathPaymentStrictReceiveResultSuccess",[["offers",e.varArray(e.lookup("ClaimAtom"),2147483647)],["last",e.lookup("SimplePaymentResult")]]),e.union("PathPaymentStrictReceiveResult",{switchOn:e.lookup("PathPaymentStrictReceiveResultCode"),switchName:"code",switches:[["pathPaymentStrictReceiveSuccess","success"],["pathPaymentStrictReceiveMalformed",e.void()],["pathPaymentStrictReceiveUnderfunded",e.void()],["pathPaymentStrictReceiveSrcNoTrust",e.void()],["pathPaymentStrictReceiveSrcNotAuthorized",e.void()],["pathPaymentStrictReceiveNoDestination",e.void()],["pathPaymentStrictReceiveNoTrust",e.void()],["pathPaymentStrictReceiveNotAuthorized",e.void()],["pathPaymentStrictReceiveLineFull",e.void()],["pathPaymentStrictReceiveNoIssuer","noIssuer"],["pathPaymentStrictReceiveTooFewOffers",e.void()],["pathPaymentStrictReceiveOfferCrossSelf",e.void()],["pathPaymentStrictReceiveOverSendmax",e.void()]],arms:{success:e.lookup("PathPaymentStrictReceiveResultSuccess"),noIssuer:e.lookup("Asset")}}),e.enum("PathPaymentStrictSendResultCode",{pathPaymentStrictSendSuccess:0,pathPaymentStrictSendMalformed:-1,pathPaymentStrictSendUnderfunded:-2,pathPaymentStrictSendSrcNoTrust:-3,pathPaymentStrictSendSrcNotAuthorized:-4,pathPaymentStrictSendNoDestination:-5,pathPaymentStrictSendNoTrust:-6,pathPaymentStrictSendNotAuthorized:-7,pathPaymentStrictSendLineFull:-8,pathPaymentStrictSendNoIssuer:-9,pathPaymentStrictSendTooFewOffers:-10,pathPaymentStrictSendOfferCrossSelf:-11,pathPaymentStrictSendUnderDestmin:-12}),e.struct("PathPaymentStrictSendResultSuccess",[["offers",e.varArray(e.lookup("ClaimAtom"),2147483647)],["last",e.lookup("SimplePaymentResult")]]),e.union("PathPaymentStrictSendResult",{switchOn:e.lookup("PathPaymentStrictSendResultCode"),switchName:"code",switches:[["pathPaymentStrictSendSuccess","success"],["pathPaymentStrictSendMalformed",e.void()],["pathPaymentStrictSendUnderfunded",e.void()],["pathPaymentStrictSendSrcNoTrust",e.void()],["pathPaymentStrictSendSrcNotAuthorized",e.void()],["pathPaymentStrictSendNoDestination",e.void()],["pathPaymentStrictSendNoTrust",e.void()],["pathPaymentStrictSendNotAuthorized",e.void()],["pathPaymentStrictSendLineFull",e.void()],["pathPaymentStrictSendNoIssuer","noIssuer"],["pathPaymentStrictSendTooFewOffers",e.void()],["pathPaymentStrictSendOfferCrossSelf",e.void()],["pathPaymentStrictSendUnderDestmin",e.void()]],arms:{success:e.lookup("PathPaymentStrictSendResultSuccess"),noIssuer:e.lookup("Asset")}}),e.enum("ManageSellOfferResultCode",{manageSellOfferSuccess:0,manageSellOfferMalformed:-1,manageSellOfferSellNoTrust:-2,manageSellOfferBuyNoTrust:-3,manageSellOfferSellNotAuthorized:-4,manageSellOfferBuyNotAuthorized:-5,manageSellOfferLineFull:-6,manageSellOfferUnderfunded:-7,manageSellOfferCrossSelf:-8,manageSellOfferSellNoIssuer:-9,manageSellOfferBuyNoIssuer:-10,manageSellOfferNotFound:-11,manageSellOfferLowReserve:-12}),e.enum("ManageOfferEffect",{manageOfferCreated:0,manageOfferUpdated:1,manageOfferDeleted:2}),e.union("ManageOfferSuccessResultOffer",{switchOn:e.lookup("ManageOfferEffect"),switchName:"effect",switches:[["manageOfferCreated","offer"],["manageOfferUpdated","offer"],["manageOfferDeleted",e.void()]],arms:{offer:e.lookup("OfferEntry")}}),e.struct("ManageOfferSuccessResult",[["offersClaimed",e.varArray(e.lookup("ClaimAtom"),2147483647)],["offer",e.lookup("ManageOfferSuccessResultOffer")]]),e.union("ManageSellOfferResult",{switchOn:e.lookup("ManageSellOfferResultCode"),switchName:"code",switches:[["manageSellOfferSuccess","success"],["manageSellOfferMalformed",e.void()],["manageSellOfferSellNoTrust",e.void()],["manageSellOfferBuyNoTrust",e.void()],["manageSellOfferSellNotAuthorized",e.void()],["manageSellOfferBuyNotAuthorized",e.void()],["manageSellOfferLineFull",e.void()],["manageSellOfferUnderfunded",e.void()],["manageSellOfferCrossSelf",e.void()],["manageSellOfferSellNoIssuer",e.void()],["manageSellOfferBuyNoIssuer",e.void()],["manageSellOfferNotFound",e.void()],["manageSellOfferLowReserve",e.void()]],arms:{success:e.lookup("ManageOfferSuccessResult")}}),e.enum("ManageBuyOfferResultCode",{manageBuyOfferSuccess:0,manageBuyOfferMalformed:-1,manageBuyOfferSellNoTrust:-2,manageBuyOfferBuyNoTrust:-3,manageBuyOfferSellNotAuthorized:-4,manageBuyOfferBuyNotAuthorized:-5,manageBuyOfferLineFull:-6,manageBuyOfferUnderfunded:-7,manageBuyOfferCrossSelf:-8,manageBuyOfferSellNoIssuer:-9,manageBuyOfferBuyNoIssuer:-10,manageBuyOfferNotFound:-11,manageBuyOfferLowReserve:-12}),e.union("ManageBuyOfferResult",{switchOn:e.lookup("ManageBuyOfferResultCode"),switchName:"code",switches:[["manageBuyOfferSuccess","success"],["manageBuyOfferMalformed",e.void()],["manageBuyOfferSellNoTrust",e.void()],["manageBuyOfferBuyNoTrust",e.void()],["manageBuyOfferSellNotAuthorized",e.void()],["manageBuyOfferBuyNotAuthorized",e.void()],["manageBuyOfferLineFull",e.void()],["manageBuyOfferUnderfunded",e.void()],["manageBuyOfferCrossSelf",e.void()],["manageBuyOfferSellNoIssuer",e.void()],["manageBuyOfferBuyNoIssuer",e.void()],["manageBuyOfferNotFound",e.void()],["manageBuyOfferLowReserve",e.void()]],arms:{success:e.lookup("ManageOfferSuccessResult")}}),e.enum("SetOptionsResultCode",{setOptionsSuccess:0,setOptionsLowReserve:-1,setOptionsTooManySigners:-2,setOptionsBadFlags:-3,setOptionsInvalidInflation:-4,setOptionsCantChange:-5,setOptionsUnknownFlag:-6,setOptionsThresholdOutOfRange:-7,setOptionsBadSigner:-8,setOptionsInvalidHomeDomain:-9,setOptionsAuthRevocableRequired:-10}),e.union("SetOptionsResult",{switchOn:e.lookup("SetOptionsResultCode"),switchName:"code",switches:[["setOptionsSuccess",e.void()],["setOptionsLowReserve",e.void()],["setOptionsTooManySigners",e.void()],["setOptionsBadFlags",e.void()],["setOptionsInvalidInflation",e.void()],["setOptionsCantChange",e.void()],["setOptionsUnknownFlag",e.void()],["setOptionsThresholdOutOfRange",e.void()],["setOptionsBadSigner",e.void()],["setOptionsInvalidHomeDomain",e.void()],["setOptionsAuthRevocableRequired",e.void()]],arms:{}}),e.enum("ChangeTrustResultCode",{changeTrustSuccess:0,changeTrustMalformed:-1,changeTrustNoIssuer:-2,changeTrustInvalidLimit:-3,changeTrustLowReserve:-4,changeTrustSelfNotAllowed:-5,changeTrustTrustLineMissing:-6,changeTrustCannotDelete:-7,changeTrustNotAuthMaintainLiabilities:-8}),e.union("ChangeTrustResult",{switchOn:e.lookup("ChangeTrustResultCode"),switchName:"code",switches:[["changeTrustSuccess",e.void()],["changeTrustMalformed",e.void()],["changeTrustNoIssuer",e.void()],["changeTrustInvalidLimit",e.void()],["changeTrustLowReserve",e.void()],["changeTrustSelfNotAllowed",e.void()],["changeTrustTrustLineMissing",e.void()],["changeTrustCannotDelete",e.void()],["changeTrustNotAuthMaintainLiabilities",e.void()]],arms:{}}),e.enum("AllowTrustResultCode",{allowTrustSuccess:0,allowTrustMalformed:-1,allowTrustNoTrustLine:-2,allowTrustTrustNotRequired:-3,allowTrustCantRevoke:-4,allowTrustSelfNotAllowed:-5,allowTrustLowReserve:-6}),e.union("AllowTrustResult",{switchOn:e.lookup("AllowTrustResultCode"),switchName:"code",switches:[["allowTrustSuccess",e.void()],["allowTrustMalformed",e.void()],["allowTrustNoTrustLine",e.void()],["allowTrustTrustNotRequired",e.void()],["allowTrustCantRevoke",e.void()],["allowTrustSelfNotAllowed",e.void()],["allowTrustLowReserve",e.void()]],arms:{}}),e.enum("AccountMergeResultCode",{accountMergeSuccess:0,accountMergeMalformed:-1,accountMergeNoAccount:-2,accountMergeImmutableSet:-3,accountMergeHasSubEntries:-4,accountMergeSeqnumTooFar:-5,accountMergeDestFull:-6,accountMergeIsSponsor:-7}),e.union("AccountMergeResult",{switchOn:e.lookup("AccountMergeResultCode"),switchName:"code",switches:[["accountMergeSuccess","sourceAccountBalance"],["accountMergeMalformed",e.void()],["accountMergeNoAccount",e.void()],["accountMergeImmutableSet",e.void()],["accountMergeHasSubEntries",e.void()],["accountMergeSeqnumTooFar",e.void()],["accountMergeDestFull",e.void()],["accountMergeIsSponsor",e.void()]],arms:{sourceAccountBalance:e.lookup("Int64")}}),e.enum("InflationResultCode",{inflationSuccess:0,inflationNotTime:-1}),e.struct("InflationPayout",[["destination",e.lookup("AccountId")],["amount",e.lookup("Int64")]]),e.union("InflationResult",{switchOn:e.lookup("InflationResultCode"),switchName:"code",switches:[["inflationSuccess","payouts"],["inflationNotTime",e.void()]],arms:{payouts:e.varArray(e.lookup("InflationPayout"),2147483647)}}),e.enum("ManageDataResultCode",{manageDataSuccess:0,manageDataNotSupportedYet:-1,manageDataNameNotFound:-2,manageDataLowReserve:-3,manageDataInvalidName:-4}),e.union("ManageDataResult",{switchOn:e.lookup("ManageDataResultCode"),switchName:"code",switches:[["manageDataSuccess",e.void()],["manageDataNotSupportedYet",e.void()],["manageDataNameNotFound",e.void()],["manageDataLowReserve",e.void()],["manageDataInvalidName",e.void()]],arms:{}}),e.enum("BumpSequenceResultCode",{bumpSequenceSuccess:0,bumpSequenceBadSeq:-1}),e.union("BumpSequenceResult",{switchOn:e.lookup("BumpSequenceResultCode"),switchName:"code",switches:[["bumpSequenceSuccess",e.void()],["bumpSequenceBadSeq",e.void()]],arms:{}}),e.enum("CreateClaimableBalanceResultCode",{createClaimableBalanceSuccess:0,createClaimableBalanceMalformed:-1,createClaimableBalanceLowReserve:-2,createClaimableBalanceNoTrust:-3,createClaimableBalanceNotAuthorized:-4,createClaimableBalanceUnderfunded:-5}),e.union("CreateClaimableBalanceResult",{switchOn:e.lookup("CreateClaimableBalanceResultCode"),switchName:"code",switches:[["createClaimableBalanceSuccess","balanceId"],["createClaimableBalanceMalformed",e.void()],["createClaimableBalanceLowReserve",e.void()],["createClaimableBalanceNoTrust",e.void()],["createClaimableBalanceNotAuthorized",e.void()],["createClaimableBalanceUnderfunded",e.void()]],arms:{balanceId:e.lookup("ClaimableBalanceId")}}),e.enum("ClaimClaimableBalanceResultCode",{claimClaimableBalanceSuccess:0,claimClaimableBalanceDoesNotExist:-1,claimClaimableBalanceCannotClaim:-2,claimClaimableBalanceLineFull:-3,claimClaimableBalanceNoTrust:-4,claimClaimableBalanceNotAuthorized:-5}),e.union("ClaimClaimableBalanceResult",{switchOn:e.lookup("ClaimClaimableBalanceResultCode"),switchName:"code",switches:[["claimClaimableBalanceSuccess",e.void()],["claimClaimableBalanceDoesNotExist",e.void()],["claimClaimableBalanceCannotClaim",e.void()],["claimClaimableBalanceLineFull",e.void()],["claimClaimableBalanceNoTrust",e.void()],["claimClaimableBalanceNotAuthorized",e.void()]],arms:{}}),e.enum("BeginSponsoringFutureReservesResultCode",{beginSponsoringFutureReservesSuccess:0,beginSponsoringFutureReservesMalformed:-1,beginSponsoringFutureReservesAlreadySponsored:-2,beginSponsoringFutureReservesRecursive:-3}),e.union("BeginSponsoringFutureReservesResult",{switchOn:e.lookup("BeginSponsoringFutureReservesResultCode"),switchName:"code",switches:[["beginSponsoringFutureReservesSuccess",e.void()],["beginSponsoringFutureReservesMalformed",e.void()],["beginSponsoringFutureReservesAlreadySponsored",e.void()],["beginSponsoringFutureReservesRecursive",e.void()]],arms:{}}),e.enum("EndSponsoringFutureReservesResultCode",{endSponsoringFutureReservesSuccess:0,endSponsoringFutureReservesNotSponsored:-1}),e.union("EndSponsoringFutureReservesResult",{switchOn:e.lookup("EndSponsoringFutureReservesResultCode"),switchName:"code",switches:[["endSponsoringFutureReservesSuccess",e.void()],["endSponsoringFutureReservesNotSponsored",e.void()]],arms:{}}),e.enum("RevokeSponsorshipResultCode",{revokeSponsorshipSuccess:0,revokeSponsorshipDoesNotExist:-1,revokeSponsorshipNotSponsor:-2,revokeSponsorshipLowReserve:-3,revokeSponsorshipOnlyTransferable:-4,revokeSponsorshipMalformed:-5}),e.union("RevokeSponsorshipResult",{switchOn:e.lookup("RevokeSponsorshipResultCode"),switchName:"code",switches:[["revokeSponsorshipSuccess",e.void()],["revokeSponsorshipDoesNotExist",e.void()],["revokeSponsorshipNotSponsor",e.void()],["revokeSponsorshipLowReserve",e.void()],["revokeSponsorshipOnlyTransferable",e.void()],["revokeSponsorshipMalformed",e.void()]],arms:{}}),e.enum("ClawbackResultCode",{clawbackSuccess:0,clawbackMalformed:-1,clawbackNotClawbackEnabled:-2,clawbackNoTrust:-3,clawbackUnderfunded:-4}),e.union("ClawbackResult",{switchOn:e.lookup("ClawbackResultCode"),switchName:"code",switches:[["clawbackSuccess",e.void()],["clawbackMalformed",e.void()],["clawbackNotClawbackEnabled",e.void()],["clawbackNoTrust",e.void()],["clawbackUnderfunded",e.void()]],arms:{}}),e.enum("ClawbackClaimableBalanceResultCode",{clawbackClaimableBalanceSuccess:0,clawbackClaimableBalanceDoesNotExist:-1,clawbackClaimableBalanceNotIssuer:-2,clawbackClaimableBalanceNotClawbackEnabled:-3}),e.union("ClawbackClaimableBalanceResult",{switchOn:e.lookup("ClawbackClaimableBalanceResultCode"),switchName:"code",switches:[["clawbackClaimableBalanceSuccess",e.void()],["clawbackClaimableBalanceDoesNotExist",e.void()],["clawbackClaimableBalanceNotIssuer",e.void()],["clawbackClaimableBalanceNotClawbackEnabled",e.void()]],arms:{}}),e.enum("SetTrustLineFlagsResultCode",{setTrustLineFlagsSuccess:0,setTrustLineFlagsMalformed:-1,setTrustLineFlagsNoTrustLine:-2,setTrustLineFlagsCantRevoke:-3,setTrustLineFlagsInvalidState:-4,setTrustLineFlagsLowReserve:-5}),e.union("SetTrustLineFlagsResult",{switchOn:e.lookup("SetTrustLineFlagsResultCode"),switchName:"code",switches:[["setTrustLineFlagsSuccess",e.void()],["setTrustLineFlagsMalformed",e.void()],["setTrustLineFlagsNoTrustLine",e.void()],["setTrustLineFlagsCantRevoke",e.void()],["setTrustLineFlagsInvalidState",e.void()],["setTrustLineFlagsLowReserve",e.void()]],arms:{}}),e.enum("LiquidityPoolDepositResultCode",{liquidityPoolDepositSuccess:0,liquidityPoolDepositMalformed:-1,liquidityPoolDepositNoTrust:-2,liquidityPoolDepositNotAuthorized:-3,liquidityPoolDepositUnderfunded:-4,liquidityPoolDepositLineFull:-5,liquidityPoolDepositBadPrice:-6,liquidityPoolDepositPoolFull:-7}),e.union("LiquidityPoolDepositResult",{switchOn:e.lookup("LiquidityPoolDepositResultCode"),switchName:"code",switches:[["liquidityPoolDepositSuccess",e.void()],["liquidityPoolDepositMalformed",e.void()],["liquidityPoolDepositNoTrust",e.void()],["liquidityPoolDepositNotAuthorized",e.void()],["liquidityPoolDepositUnderfunded",e.void()],["liquidityPoolDepositLineFull",e.void()],["liquidityPoolDepositBadPrice",e.void()],["liquidityPoolDepositPoolFull",e.void()]],arms:{}}),e.enum("LiquidityPoolWithdrawResultCode",{liquidityPoolWithdrawSuccess:0,liquidityPoolWithdrawMalformed:-1,liquidityPoolWithdrawNoTrust:-2,liquidityPoolWithdrawUnderfunded:-3,liquidityPoolWithdrawLineFull:-4,liquidityPoolWithdrawUnderMinimum:-5}),e.union("LiquidityPoolWithdrawResult",{switchOn:e.lookup("LiquidityPoolWithdrawResultCode"),switchName:"code",switches:[["liquidityPoolWithdrawSuccess",e.void()],["liquidityPoolWithdrawMalformed",e.void()],["liquidityPoolWithdrawNoTrust",e.void()],["liquidityPoolWithdrawUnderfunded",e.void()],["liquidityPoolWithdrawLineFull",e.void()],["liquidityPoolWithdrawUnderMinimum",e.void()]],arms:{}}),e.enum("InvokeHostFunctionResultCode",{invokeHostFunctionSuccess:0,invokeHostFunctionMalformed:-1,invokeHostFunctionTrapped:-2,invokeHostFunctionResourceLimitExceeded:-3,invokeHostFunctionEntryArchived:-4,invokeHostFunctionInsufficientRefundableFee:-5}),e.union("InvokeHostFunctionResult",{switchOn:e.lookup("InvokeHostFunctionResultCode"),switchName:"code",switches:[["invokeHostFunctionSuccess","success"],["invokeHostFunctionMalformed",e.void()],["invokeHostFunctionTrapped",e.void()],["invokeHostFunctionResourceLimitExceeded",e.void()],["invokeHostFunctionEntryArchived",e.void()],["invokeHostFunctionInsufficientRefundableFee",e.void()]],arms:{success:e.lookup("Hash")}}),e.enum("ExtendFootprintTtlResultCode",{extendFootprintTtlSuccess:0,extendFootprintTtlMalformed:-1,extendFootprintTtlResourceLimitExceeded:-2,extendFootprintTtlInsufficientRefundableFee:-3}),e.union("ExtendFootprintTtlResult",{switchOn:e.lookup("ExtendFootprintTtlResultCode"),switchName:"code",switches:[["extendFootprintTtlSuccess",e.void()],["extendFootprintTtlMalformed",e.void()],["extendFootprintTtlResourceLimitExceeded",e.void()],["extendFootprintTtlInsufficientRefundableFee",e.void()]],arms:{}}),e.enum("RestoreFootprintResultCode",{restoreFootprintSuccess:0,restoreFootprintMalformed:-1,restoreFootprintResourceLimitExceeded:-2,restoreFootprintInsufficientRefundableFee:-3}),e.union("RestoreFootprintResult",{switchOn:e.lookup("RestoreFootprintResultCode"),switchName:"code",switches:[["restoreFootprintSuccess",e.void()],["restoreFootprintMalformed",e.void()],["restoreFootprintResourceLimitExceeded",e.void()],["restoreFootprintInsufficientRefundableFee",e.void()]],arms:{}}),e.enum("OperationResultCode",{opInner:0,opBadAuth:-1,opNoAccount:-2,opNotSupported:-3,opTooManySubentries:-4,opExceededWorkLimit:-5,opTooManySponsoring:-6}),e.union("OperationResultTr",{switchOn:e.lookup("OperationType"),switchName:"type",switches:[["createAccount","createAccountResult"],["payment","paymentResult"],["pathPaymentStrictReceive","pathPaymentStrictReceiveResult"],["manageSellOffer","manageSellOfferResult"],["createPassiveSellOffer","createPassiveSellOfferResult"],["setOptions","setOptionsResult"],["changeTrust","changeTrustResult"],["allowTrust","allowTrustResult"],["accountMerge","accountMergeResult"],["inflation","inflationResult"],["manageData","manageDataResult"],["bumpSequence","bumpSeqResult"],["manageBuyOffer","manageBuyOfferResult"],["pathPaymentStrictSend","pathPaymentStrictSendResult"],["createClaimableBalance","createClaimableBalanceResult"],["claimClaimableBalance","claimClaimableBalanceResult"],["beginSponsoringFutureReserves","beginSponsoringFutureReservesResult"],["endSponsoringFutureReserves","endSponsoringFutureReservesResult"],["revokeSponsorship","revokeSponsorshipResult"],["clawback","clawbackResult"],["clawbackClaimableBalance","clawbackClaimableBalanceResult"],["setTrustLineFlags","setTrustLineFlagsResult"],["liquidityPoolDeposit","liquidityPoolDepositResult"],["liquidityPoolWithdraw","liquidityPoolWithdrawResult"],["invokeHostFunction","invokeHostFunctionResult"],["extendFootprintTtl","extendFootprintTtlResult"],["restoreFootprint","restoreFootprintResult"]],arms:{createAccountResult:e.lookup("CreateAccountResult"),paymentResult:e.lookup("PaymentResult"),pathPaymentStrictReceiveResult:e.lookup("PathPaymentStrictReceiveResult"),manageSellOfferResult:e.lookup("ManageSellOfferResult"),createPassiveSellOfferResult:e.lookup("ManageSellOfferResult"),setOptionsResult:e.lookup("SetOptionsResult"),changeTrustResult:e.lookup("ChangeTrustResult"),allowTrustResult:e.lookup("AllowTrustResult"),accountMergeResult:e.lookup("AccountMergeResult"),inflationResult:e.lookup("InflationResult"),manageDataResult:e.lookup("ManageDataResult"),bumpSeqResult:e.lookup("BumpSequenceResult"),manageBuyOfferResult:e.lookup("ManageBuyOfferResult"),pathPaymentStrictSendResult:e.lookup("PathPaymentStrictSendResult"),createClaimableBalanceResult:e.lookup("CreateClaimableBalanceResult"),claimClaimableBalanceResult:e.lookup("ClaimClaimableBalanceResult"),beginSponsoringFutureReservesResult:e.lookup("BeginSponsoringFutureReservesResult"),endSponsoringFutureReservesResult:e.lookup("EndSponsoringFutureReservesResult"),revokeSponsorshipResult:e.lookup("RevokeSponsorshipResult"),clawbackResult:e.lookup("ClawbackResult"),clawbackClaimableBalanceResult:e.lookup("ClawbackClaimableBalanceResult"),setTrustLineFlagsResult:e.lookup("SetTrustLineFlagsResult"),liquidityPoolDepositResult:e.lookup("LiquidityPoolDepositResult"),liquidityPoolWithdrawResult:e.lookup("LiquidityPoolWithdrawResult"),invokeHostFunctionResult:e.lookup("InvokeHostFunctionResult"),extendFootprintTtlResult:e.lookup("ExtendFootprintTtlResult"),restoreFootprintResult:e.lookup("RestoreFootprintResult")}}),e.union("OperationResult",{switchOn:e.lookup("OperationResultCode"),switchName:"code",switches:[["opInner","tr"],["opBadAuth",e.void()],["opNoAccount",e.void()],["opNotSupported",e.void()],["opTooManySubentries",e.void()],["opExceededWorkLimit",e.void()],["opTooManySponsoring",e.void()]],arms:{tr:e.lookup("OperationResultTr")}}),e.enum("TransactionResultCode",{txFeeBumpInnerSuccess:1,txSuccess:0,txFailed:-1,txTooEarly:-2,txTooLate:-3,txMissingOperation:-4,txBadSeq:-5,txBadAuth:-6,txInsufficientBalance:-7,txNoAccount:-8,txInsufficientFee:-9,txBadAuthExtra:-10,txInternalError:-11,txNotSupported:-12,txFeeBumpInnerFailed:-13,txBadSponsorship:-14,txBadMinSeqAgeOrGap:-15,txMalformed:-16,txSorobanInvalid:-17}),e.union("InnerTransactionResultResult",{switchOn:e.lookup("TransactionResultCode"),switchName:"code",switches:[["txSuccess","results"],["txFailed","results"],["txTooEarly",e.void()],["txTooLate",e.void()],["txMissingOperation",e.void()],["txBadSeq",e.void()],["txBadAuth",e.void()],["txInsufficientBalance",e.void()],["txNoAccount",e.void()],["txInsufficientFee",e.void()],["txBadAuthExtra",e.void()],["txInternalError",e.void()],["txNotSupported",e.void()],["txBadSponsorship",e.void()],["txBadMinSeqAgeOrGap",e.void()],["txMalformed",e.void()],["txSorobanInvalid",e.void()]],arms:{results:e.varArray(e.lookup("OperationResult"),2147483647)}}),e.union("InnerTransactionResultExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("InnerTransactionResult",[["feeCharged",e.lookup("Int64")],["result",e.lookup("InnerTransactionResultResult")],["ext",e.lookup("InnerTransactionResultExt")]]),e.struct("InnerTransactionResultPair",[["transactionHash",e.lookup("Hash")],["result",e.lookup("InnerTransactionResult")]]),e.union("TransactionResultResult",{switchOn:e.lookup("TransactionResultCode"),switchName:"code",switches:[["txFeeBumpInnerSuccess","innerResultPair"],["txFeeBumpInnerFailed","innerResultPair"],["txSuccess","results"],["txFailed","results"],["txTooEarly",e.void()],["txTooLate",e.void()],["txMissingOperation",e.void()],["txBadSeq",e.void()],["txBadAuth",e.void()],["txInsufficientBalance",e.void()],["txNoAccount",e.void()],["txInsufficientFee",e.void()],["txBadAuthExtra",e.void()],["txInternalError",e.void()],["txNotSupported",e.void()],["txBadSponsorship",e.void()],["txBadMinSeqAgeOrGap",e.void()],["txMalformed",e.void()],["txSorobanInvalid",e.void()]],arms:{innerResultPair:e.lookup("InnerTransactionResultPair"),results:e.varArray(e.lookup("OperationResult"),2147483647)}}),e.union("TransactionResultExt",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.struct("TransactionResult",[["feeCharged",e.lookup("Int64")],["result",e.lookup("TransactionResultResult")],["ext",e.lookup("TransactionResultExt")]]),e.typedef("Hash",e.opaque(32)),e.typedef("Uint256",e.opaque(32)),e.typedef("Uint32",e.uint()),e.typedef("Int32",e.int()),e.typedef("Uint64",e.uhyper()),e.typedef("Int64",e.hyper()),e.typedef("TimePoint",e.lookup("Uint64")),e.typedef("Duration",e.lookup("Uint64")),e.union("ExtensionPoint",{switchOn:e.int(),switchName:"v",switches:[[0,e.void()]],arms:{}}),e.enum("CryptoKeyType",{keyTypeEd25519:0,keyTypePreAuthTx:1,keyTypeHashX:2,keyTypeEd25519SignedPayload:3,keyTypeMuxedEd25519:256}),e.enum("PublicKeyType",{publicKeyTypeEd25519:0}),e.enum("SignerKeyType",{signerKeyTypeEd25519:0,signerKeyTypePreAuthTx:1,signerKeyTypeHashX:2,signerKeyTypeEd25519SignedPayload:3}),e.union("PublicKey",{switchOn:e.lookup("PublicKeyType"),switchName:"type",switches:[["publicKeyTypeEd25519","ed25519"]],arms:{ed25519:e.lookup("Uint256")}}),e.struct("SignerKeyEd25519SignedPayload",[["ed25519",e.lookup("Uint256")],["payload",e.varOpaque(64)]]),e.union("SignerKey",{switchOn:e.lookup("SignerKeyType"),switchName:"type",switches:[["signerKeyTypeEd25519","ed25519"],["signerKeyTypePreAuthTx","preAuthTx"],["signerKeyTypeHashX","hashX"],["signerKeyTypeEd25519SignedPayload","ed25519SignedPayload"]],arms:{ed25519:e.lookup("Uint256"),preAuthTx:e.lookup("Uint256"),hashX:e.lookup("Uint256"),ed25519SignedPayload:e.lookup("SignerKeyEd25519SignedPayload")}}),e.typedef("Signature",e.varOpaque(64)),e.typedef("SignatureHint",e.opaque(4)),e.typedef("NodeId",e.lookup("PublicKey")),e.typedef("AccountId",e.lookup("PublicKey")),e.typedef("ContractId",e.lookup("Hash")),e.struct("Curve25519Secret",[["key",e.opaque(32)]]),e.struct("Curve25519Public",[["key",e.opaque(32)]]),e.struct("HmacSha256Key",[["key",e.opaque(32)]]),e.struct("HmacSha256Mac",[["mac",e.opaque(32)]]),e.struct("ShortHashSeed",[["seed",e.opaque(16)]]),e.enum("BinaryFuseFilterType",{binaryFuseFilter8Bit:0,binaryFuseFilter16Bit:1,binaryFuseFilter32Bit:2}),e.struct("SerializedBinaryFuseFilter",[["type",e.lookup("BinaryFuseFilterType")],["inputHashSeed",e.lookup("ShortHashSeed")],["filterSeed",e.lookup("ShortHashSeed")],["segmentLength",e.lookup("Uint32")],["segementLengthMask",e.lookup("Uint32")],["segmentCount",e.lookup("Uint32")],["segmentCountLength",e.lookup("Uint32")],["fingerprintLength",e.lookup("Uint32")],["fingerprints",e.varOpaque()]]),e.typedef("PoolId",e.lookup("Hash")),e.enum("ClaimableBalanceIdType",{claimableBalanceIdTypeV0:0}),e.union("ClaimableBalanceId",{switchOn:e.lookup("ClaimableBalanceIdType"),switchName:"type",switches:[["claimableBalanceIdTypeV0","v0"]],arms:{v0:e.lookup("Hash")}}),e.enum("ScValType",{scvBool:0,scvVoid:1,scvError:2,scvU32:3,scvI32:4,scvU64:5,scvI64:6,scvTimepoint:7,scvDuration:8,scvU128:9,scvI128:10,scvU256:11,scvI256:12,scvBytes:13,scvString:14,scvSymbol:15,scvVec:16,scvMap:17,scvAddress:18,scvContractInstance:19,scvLedgerKeyContractInstance:20,scvLedgerKeyNonce:21}),e.enum("ScErrorType",{sceContract:0,sceWasmVm:1,sceContext:2,sceStorage:3,sceObject:4,sceCrypto:5,sceEvents:6,sceBudget:7,sceValue:8,sceAuth:9}),e.enum("ScErrorCode",{scecArithDomain:0,scecIndexBounds:1,scecInvalidInput:2,scecMissingValue:3,scecExistingValue:4,scecExceededLimit:5,scecInvalidAction:6,scecInternalError:7,scecUnexpectedType:8,scecUnexpectedSize:9}),e.union("ScError",{switchOn:e.lookup("ScErrorType"),switchName:"type",switches:[["sceContract","contractCode"],["sceWasmVm","code"],["sceContext","code"],["sceStorage","code"],["sceObject","code"],["sceCrypto","code"],["sceEvents","code"],["sceBudget","code"],["sceValue","code"],["sceAuth","code"]],arms:{contractCode:e.lookup("Uint32"),code:e.lookup("ScErrorCode")}}),e.struct("UInt128Parts",[["hi",e.lookup("Uint64")],["lo",e.lookup("Uint64")]]),e.struct("Int128Parts",[["hi",e.lookup("Int64")],["lo",e.lookup("Uint64")]]),e.struct("UInt256Parts",[["hiHi",e.lookup("Uint64")],["hiLo",e.lookup("Uint64")],["loHi",e.lookup("Uint64")],["loLo",e.lookup("Uint64")]]),e.struct("Int256Parts",[["hiHi",e.lookup("Int64")],["hiLo",e.lookup("Uint64")],["loHi",e.lookup("Uint64")],["loLo",e.lookup("Uint64")]]),e.enum("ContractExecutableType",{contractExecutableWasm:0,contractExecutableStellarAsset:1}),e.union("ContractExecutable",{switchOn:e.lookup("ContractExecutableType"),switchName:"type",switches:[["contractExecutableWasm","wasmHash"],["contractExecutableStellarAsset",e.void()]],arms:{wasmHash:e.lookup("Hash")}}),e.enum("ScAddressType",{scAddressTypeAccount:0,scAddressTypeContract:1,scAddressTypeMuxedAccount:2,scAddressTypeClaimableBalance:3,scAddressTypeLiquidityPool:4}),e.struct("MuxedEd25519Account",[["id",e.lookup("Uint64")],["ed25519",e.lookup("Uint256")]]),e.union("ScAddress",{switchOn:e.lookup("ScAddressType"),switchName:"type",switches:[["scAddressTypeAccount","accountId"],["scAddressTypeContract","contractId"],["scAddressTypeMuxedAccount","muxedAccount"],["scAddressTypeClaimableBalance","claimableBalanceId"],["scAddressTypeLiquidityPool","liquidityPoolId"]],arms:{accountId:e.lookup("AccountId"),contractId:e.lookup("ContractId"),muxedAccount:e.lookup("MuxedEd25519Account"),claimableBalanceId:e.lookup("ClaimableBalanceId"),liquidityPoolId:e.lookup("PoolId")}}),e.const("SCSYMBOL_LIMIT",32),e.typedef("ScVec",e.varArray(e.lookup("ScVal"),2147483647)),e.typedef("ScMap",e.varArray(e.lookup("ScMapEntry"),2147483647)),e.typedef("ScBytes",e.varOpaque()),e.typedef("ScString",e.string()),e.typedef("ScSymbol",e.string(32)),e.struct("ScNonceKey",[["nonce",e.lookup("Int64")]]),e.struct("ScContractInstance",[["executable",e.lookup("ContractExecutable")],["storage",e.option(e.lookup("ScMap"))]]),e.union("ScVal",{switchOn:e.lookup("ScValType"),switchName:"type",switches:[["scvBool","b"],["scvVoid",e.void()],["scvError","error"],["scvU32","u32"],["scvI32","i32"],["scvU64","u64"],["scvI64","i64"],["scvTimepoint","timepoint"],["scvDuration","duration"],["scvU128","u128"],["scvI128","i128"],["scvU256","u256"],["scvI256","i256"],["scvBytes","bytes"],["scvString","str"],["scvSymbol","sym"],["scvVec","vec"],["scvMap","map"],["scvAddress","address"],["scvContractInstance","instance"],["scvLedgerKeyContractInstance",e.void()],["scvLedgerKeyNonce","nonceKey"]],arms:{b:e.bool(),error:e.lookup("ScError"),u32:e.lookup("Uint32"),i32:e.lookup("Int32"),u64:e.lookup("Uint64"),i64:e.lookup("Int64"),timepoint:e.lookup("TimePoint"),duration:e.lookup("Duration"),u128:e.lookup("UInt128Parts"),i128:e.lookup("Int128Parts"),u256:e.lookup("UInt256Parts"),i256:e.lookup("Int256Parts"),bytes:e.lookup("ScBytes"),str:e.lookup("ScString"),sym:e.lookup("ScSymbol"),vec:e.option(e.lookup("ScVec")),map:e.option(e.lookup("ScMap")),address:e.lookup("ScAddress"),instance:e.lookup("ScContractInstance"),nonceKey:e.lookup("ScNonceKey")}}),e.struct("ScMapEntry",[["key",e.lookup("ScVal")],["val",e.lookup("ScVal")]]),e.enum("ScEnvMetaKind",{scEnvMetaKindInterfaceVersion:0}),e.struct("ScEnvMetaEntryInterfaceVersion",[["protocol",e.lookup("Uint32")],["preRelease",e.lookup("Uint32")]]),e.union("ScEnvMetaEntry",{switchOn:e.lookup("ScEnvMetaKind"),switchName:"kind",switches:[["scEnvMetaKindInterfaceVersion","interfaceVersion"]],arms:{interfaceVersion:e.lookup("ScEnvMetaEntryInterfaceVersion")}}),e.struct("ScMetaV0",[["key",e.string()],["val",e.string()]]),e.enum("ScMetaKind",{scMetaV0:0}),e.union("ScMetaEntry",{switchOn:e.lookup("ScMetaKind"),switchName:"kind",switches:[["scMetaV0","v0"]],arms:{v0:e.lookup("ScMetaV0")}}),e.const("SC_SPEC_DOC_LIMIT",1024),e.enum("ScSpecType",{scSpecTypeVal:0,scSpecTypeBool:1,scSpecTypeVoid:2,scSpecTypeError:3,scSpecTypeU32:4,scSpecTypeI32:5,scSpecTypeU64:6,scSpecTypeI64:7,scSpecTypeTimepoint:8,scSpecTypeDuration:9,scSpecTypeU128:10,scSpecTypeI128:11,scSpecTypeU256:12,scSpecTypeI256:13,scSpecTypeBytes:14,scSpecTypeString:16,scSpecTypeSymbol:17,scSpecTypeAddress:19,scSpecTypeMuxedAddress:20,scSpecTypeOption:1e3,scSpecTypeResult:1001,scSpecTypeVec:1002,scSpecTypeMap:1004,scSpecTypeTuple:1005,scSpecTypeBytesN:1006,scSpecTypeUdt:2e3}),e.struct("ScSpecTypeOption",[["valueType",e.lookup("ScSpecTypeDef")]]),e.struct("ScSpecTypeResult",[["okType",e.lookup("ScSpecTypeDef")],["errorType",e.lookup("ScSpecTypeDef")]]),e.struct("ScSpecTypeVec",[["elementType",e.lookup("ScSpecTypeDef")]]),e.struct("ScSpecTypeMap",[["keyType",e.lookup("ScSpecTypeDef")],["valueType",e.lookup("ScSpecTypeDef")]]),e.struct("ScSpecTypeTuple",[["valueTypes",e.varArray(e.lookup("ScSpecTypeDef"),12)]]),e.struct("ScSpecTypeBytesN",[["n",e.lookup("Uint32")]]),e.struct("ScSpecTypeUdt",[["name",e.string(60)]]),e.union("ScSpecTypeDef",{switchOn:e.lookup("ScSpecType"),switchName:"type",switches:[["scSpecTypeVal",e.void()],["scSpecTypeBool",e.void()],["scSpecTypeVoid",e.void()],["scSpecTypeError",e.void()],["scSpecTypeU32",e.void()],["scSpecTypeI32",e.void()],["scSpecTypeU64",e.void()],["scSpecTypeI64",e.void()],["scSpecTypeTimepoint",e.void()],["scSpecTypeDuration",e.void()],["scSpecTypeU128",e.void()],["scSpecTypeI128",e.void()],["scSpecTypeU256",e.void()],["scSpecTypeI256",e.void()],["scSpecTypeBytes",e.void()],["scSpecTypeString",e.void()],["scSpecTypeSymbol",e.void()],["scSpecTypeAddress",e.void()],["scSpecTypeMuxedAddress",e.void()],["scSpecTypeOption","option"],["scSpecTypeResult","result"],["scSpecTypeVec","vec"],["scSpecTypeMap","map"],["scSpecTypeTuple","tuple"],["scSpecTypeBytesN","bytesN"],["scSpecTypeUdt","udt"]],arms:{option:e.lookup("ScSpecTypeOption"),result:e.lookup("ScSpecTypeResult"),vec:e.lookup("ScSpecTypeVec"),map:e.lookup("ScSpecTypeMap"),tuple:e.lookup("ScSpecTypeTuple"),bytesN:e.lookup("ScSpecTypeBytesN"),udt:e.lookup("ScSpecTypeUdt")}}),e.struct("ScSpecUdtStructFieldV0",[["doc",e.string(t)],["name",e.string(30)],["type",e.lookup("ScSpecTypeDef")]]),e.struct("ScSpecUdtStructV0",[["doc",e.string(t)],["lib",e.string(80)],["name",e.string(60)],["fields",e.varArray(e.lookup("ScSpecUdtStructFieldV0"),40)]]),e.struct("ScSpecUdtUnionCaseVoidV0",[["doc",e.string(t)],["name",e.string(60)]]),e.struct("ScSpecUdtUnionCaseTupleV0",[["doc",e.string(t)],["name",e.string(60)],["type",e.varArray(e.lookup("ScSpecTypeDef"),12)]]),e.enum("ScSpecUdtUnionCaseV0Kind",{scSpecUdtUnionCaseVoidV0:0,scSpecUdtUnionCaseTupleV0:1}),e.union("ScSpecUdtUnionCaseV0",{switchOn:e.lookup("ScSpecUdtUnionCaseV0Kind"),switchName:"kind",switches:[["scSpecUdtUnionCaseVoidV0","voidCase"],["scSpecUdtUnionCaseTupleV0","tupleCase"]],arms:{voidCase:e.lookup("ScSpecUdtUnionCaseVoidV0"),tupleCase:e.lookup("ScSpecUdtUnionCaseTupleV0")}}),e.struct("ScSpecUdtUnionV0",[["doc",e.string(t)],["lib",e.string(80)],["name",e.string(60)],["cases",e.varArray(e.lookup("ScSpecUdtUnionCaseV0"),50)]]),e.struct("ScSpecUdtEnumCaseV0",[["doc",e.string(t)],["name",e.string(60)],["value",e.lookup("Uint32")]]),e.struct("ScSpecUdtEnumV0",[["doc",e.string(t)],["lib",e.string(80)],["name",e.string(60)],["cases",e.varArray(e.lookup("ScSpecUdtEnumCaseV0"),50)]]),e.struct("ScSpecUdtErrorEnumCaseV0",[["doc",e.string(t)],["name",e.string(60)],["value",e.lookup("Uint32")]]),e.struct("ScSpecUdtErrorEnumV0",[["doc",e.string(t)],["lib",e.string(80)],["name",e.string(60)],["cases",e.varArray(e.lookup("ScSpecUdtErrorEnumCaseV0"),50)]]),e.struct("ScSpecFunctionInputV0",[["doc",e.string(t)],["name",e.string(30)],["type",e.lookup("ScSpecTypeDef")]]),e.struct("ScSpecFunctionV0",[["doc",e.string(t)],["name",e.lookup("ScSymbol")],["inputs",e.varArray(e.lookup("ScSpecFunctionInputV0"),10)],["outputs",e.varArray(e.lookup("ScSpecTypeDef"),1)]]),e.enum("ScSpecEventParamLocationV0",{scSpecEventParamLocationData:0,scSpecEventParamLocationTopicList:1}),e.struct("ScSpecEventParamV0",[["doc",e.string(t)],["name",e.string(30)],["type",e.lookup("ScSpecTypeDef")],["location",e.lookup("ScSpecEventParamLocationV0")]]),e.enum("ScSpecEventDataFormat",{scSpecEventDataFormatSingleValue:0,scSpecEventDataFormatVec:1,scSpecEventDataFormatMap:2}),e.struct("ScSpecEventV0",[["doc",e.string(t)],["lib",e.string(80)],["name",e.lookup("ScSymbol")],["prefixTopics",e.varArray(e.lookup("ScSymbol"),2)],["params",e.varArray(e.lookup("ScSpecEventParamV0"),50)],["dataFormat",e.lookup("ScSpecEventDataFormat")]]),e.enum("ScSpecEntryKind",{scSpecEntryFunctionV0:0,scSpecEntryUdtStructV0:1,scSpecEntryUdtUnionV0:2,scSpecEntryUdtEnumV0:3,scSpecEntryUdtErrorEnumV0:4,scSpecEntryEventV0:5}),e.union("ScSpecEntry",{switchOn:e.lookup("ScSpecEntryKind"),switchName:"kind",switches:[["scSpecEntryFunctionV0","functionV0"],["scSpecEntryUdtStructV0","udtStructV0"],["scSpecEntryUdtUnionV0","udtUnionV0"],["scSpecEntryUdtEnumV0","udtEnumV0"],["scSpecEntryUdtErrorEnumV0","udtErrorEnumV0"],["scSpecEntryEventV0","eventV0"]],arms:{functionV0:e.lookup("ScSpecFunctionV0"),udtStructV0:e.lookup("ScSpecUdtStructV0"),udtUnionV0:e.lookup("ScSpecUdtUnionV0"),udtEnumV0:e.lookup("ScSpecUdtEnumV0"),udtErrorEnumV0:e.lookup("ScSpecUdtErrorEnumV0"),eventV0:e.lookup("ScSpecEventV0")}}),e.struct("ConfigSettingContractExecutionLanesV0",[["ledgerMaxTxCount",e.lookup("Uint32")]]),e.struct("ConfigSettingContractComputeV0",[["ledgerMaxInstructions",e.lookup("Int64")],["txMaxInstructions",e.lookup("Int64")],["feeRatePerInstructionsIncrement",e.lookup("Int64")],["txMemoryLimit",e.lookup("Uint32")]]),e.struct("ConfigSettingContractParallelComputeV0",[["ledgerMaxDependentTxClusters",e.lookup("Uint32")]]),e.struct("ConfigSettingContractLedgerCostV0",[["ledgerMaxDiskReadEntries",e.lookup("Uint32")],["ledgerMaxDiskReadBytes",e.lookup("Uint32")],["ledgerMaxWriteLedgerEntries",e.lookup("Uint32")],["ledgerMaxWriteBytes",e.lookup("Uint32")],["txMaxDiskReadEntries",e.lookup("Uint32")],["txMaxDiskReadBytes",e.lookup("Uint32")],["txMaxWriteLedgerEntries",e.lookup("Uint32")],["txMaxWriteBytes",e.lookup("Uint32")],["feeDiskReadLedgerEntry",e.lookup("Int64")],["feeWriteLedgerEntry",e.lookup("Int64")],["feeDiskRead1Kb",e.lookup("Int64")],["sorobanStateTargetSizeBytes",e.lookup("Int64")],["rentFee1KbSorobanStateSizeLow",e.lookup("Int64")],["rentFee1KbSorobanStateSizeHigh",e.lookup("Int64")],["sorobanStateRentFeeGrowthFactor",e.lookup("Uint32")]]),e.struct("ConfigSettingContractLedgerCostExtV0",[["txMaxFootprintEntries",e.lookup("Uint32")],["feeWrite1Kb",e.lookup("Int64")]]),e.struct("ConfigSettingContractHistoricalDataV0",[["feeHistorical1Kb",e.lookup("Int64")]]),e.struct("ConfigSettingContractEventsV0",[["txMaxContractEventsSizeBytes",e.lookup("Uint32")],["feeContractEvents1Kb",e.lookup("Int64")]]),e.struct("ConfigSettingContractBandwidthV0",[["ledgerMaxTxsSizeBytes",e.lookup("Uint32")],["txMaxSizeBytes",e.lookup("Uint32")],["feeTxSize1Kb",e.lookup("Int64")]]),e.enum("ContractCostType",{wasmInsnExec:0,memAlloc:1,memCpy:2,memCmp:3,dispatchHostFunction:4,visitObject:5,valSer:6,valDeser:7,computeSha256Hash:8,computeEd25519PubKey:9,verifyEd25519Sig:10,vmInstantiation:11,vmCachedInstantiation:12,invokeVmFunction:13,computeKeccak256Hash:14,decodeEcdsaCurve256Sig:15,recoverEcdsaSecp256k1Key:16,int256AddSub:17,int256Mul:18,int256Div:19,int256Pow:20,int256Shift:21,chaCha20DrawBytes:22,parseWasmInstructions:23,parseWasmFunctions:24,parseWasmGlobals:25,parseWasmTableEntries:26,parseWasmTypes:27,parseWasmDataSegments:28,parseWasmElemSegments:29,parseWasmImports:30,parseWasmExports:31,parseWasmDataSegmentBytes:32,instantiateWasmInstructions:33,instantiateWasmFunctions:34,instantiateWasmGlobals:35,instantiateWasmTableEntries:36,instantiateWasmTypes:37,instantiateWasmDataSegments:38,instantiateWasmElemSegments:39,instantiateWasmImports:40,instantiateWasmExports:41,instantiateWasmDataSegmentBytes:42,sec1DecodePointUncompressed:43,verifyEcdsaSecp256r1Sig:44,bls12381EncodeFp:45,bls12381DecodeFp:46,bls12381G1CheckPointOnCurve:47,bls12381G1CheckPointInSubgroup:48,bls12381G2CheckPointOnCurve:49,bls12381G2CheckPointInSubgroup:50,bls12381G1ProjectiveToAffine:51,bls12381G2ProjectiveToAffine:52,bls12381G1Add:53,bls12381G1Mul:54,bls12381G1Msm:55,bls12381MapFpToG1:56,bls12381HashToG1:57,bls12381G2Add:58,bls12381G2Mul:59,bls12381G2Msm:60,bls12381MapFp2ToG2:61,bls12381HashToG2:62,bls12381Pairing:63,bls12381FrFromU256:64,bls12381FrToU256:65,bls12381FrAddSub:66,bls12381FrMul:67,bls12381FrPow:68,bls12381FrInv:69}),e.struct("ContractCostParamEntry",[["ext",e.lookup("ExtensionPoint")],["constTerm",e.lookup("Int64")],["linearTerm",e.lookup("Int64")]]),e.struct("StateArchivalSettings",[["maxEntryTtl",e.lookup("Uint32")],["minTemporaryTtl",e.lookup("Uint32")],["minPersistentTtl",e.lookup("Uint32")],["persistentRentRateDenominator",e.lookup("Int64")],["tempRentRateDenominator",e.lookup("Int64")],["maxEntriesToArchive",e.lookup("Uint32")],["liveSorobanStateSizeWindowSampleSize",e.lookup("Uint32")],["liveSorobanStateSizeWindowSamplePeriod",e.lookup("Uint32")],["evictionScanSize",e.lookup("Uint32")],["startingEvictionScanLevel",e.lookup("Uint32")]]),e.struct("EvictionIterator",[["bucketListLevel",e.lookup("Uint32")],["isCurrBucket",e.bool()],["bucketFileOffset",e.lookup("Uint64")]]),e.struct("ConfigSettingScpTiming",[["ledgerTargetCloseTimeMilliseconds",e.lookup("Uint32")],["nominationTimeoutInitialMilliseconds",e.lookup("Uint32")],["nominationTimeoutIncrementMilliseconds",e.lookup("Uint32")],["ballotTimeoutInitialMilliseconds",e.lookup("Uint32")],["ballotTimeoutIncrementMilliseconds",e.lookup("Uint32")]]),e.const("CONTRACT_COST_COUNT_LIMIT",1024),e.typedef("ContractCostParams",e.varArray(e.lookup("ContractCostParamEntry"),e.lookup("CONTRACT_COST_COUNT_LIMIT"))),e.enum("ConfigSettingId",{configSettingContractMaxSizeBytes:0,configSettingContractComputeV0:1,configSettingContractLedgerCostV0:2,configSettingContractHistoricalDataV0:3,configSettingContractEventsV0:4,configSettingContractBandwidthV0:5,configSettingContractCostParamsCpuInstructions:6,configSettingContractCostParamsMemoryBytes:7,configSettingContractDataKeySizeBytes:8,configSettingContractDataEntrySizeBytes:9,configSettingStateArchival:10,configSettingContractExecutionLanes:11,configSettingLiveSorobanStateSizeWindow:12,configSettingEvictionIterator:13,configSettingContractParallelComputeV0:14,configSettingContractLedgerCostExtV0:15,configSettingScpTiming:16}),e.union("ConfigSettingEntry",{switchOn:e.lookup("ConfigSettingId"),switchName:"configSettingId",switches:[["configSettingContractMaxSizeBytes","contractMaxSizeBytes"],["configSettingContractComputeV0","contractCompute"],["configSettingContractLedgerCostV0","contractLedgerCost"],["configSettingContractHistoricalDataV0","contractHistoricalData"],["configSettingContractEventsV0","contractEvents"],["configSettingContractBandwidthV0","contractBandwidth"],["configSettingContractCostParamsCpuInstructions","contractCostParamsCpuInsns"],["configSettingContractCostParamsMemoryBytes","contractCostParamsMemBytes"],["configSettingContractDataKeySizeBytes","contractDataKeySizeBytes"],["configSettingContractDataEntrySizeBytes","contractDataEntrySizeBytes"],["configSettingStateArchival","stateArchivalSettings"],["configSettingContractExecutionLanes","contractExecutionLanes"],["configSettingLiveSorobanStateSizeWindow","liveSorobanStateSizeWindow"],["configSettingEvictionIterator","evictionIterator"],["configSettingContractParallelComputeV0","contractParallelCompute"],["configSettingContractLedgerCostExtV0","contractLedgerCostExt"],["configSettingScpTiming","contractScpTiming"]],arms:{contractMaxSizeBytes:e.lookup("Uint32"),contractCompute:e.lookup("ConfigSettingContractComputeV0"),contractLedgerCost:e.lookup("ConfigSettingContractLedgerCostV0"),contractHistoricalData:e.lookup("ConfigSettingContractHistoricalDataV0"),contractEvents:e.lookup("ConfigSettingContractEventsV0"),contractBandwidth:e.lookup("ConfigSettingContractBandwidthV0"),contractCostParamsCpuInsns:e.lookup("ContractCostParams"),contractCostParamsMemBytes:e.lookup("ContractCostParams"),contractDataKeySizeBytes:e.lookup("Uint32"),contractDataEntrySizeBytes:e.lookup("Uint32"),stateArchivalSettings:e.lookup("StateArchivalSettings"),contractExecutionLanes:e.lookup("ConfigSettingContractExecutionLanesV0"),liveSorobanStateSizeWindow:e.varArray(e.lookup("Uint64"),2147483647),evictionIterator:e.lookup("EvictionIterator"),contractParallelCompute:e.lookup("ConfigSettingContractParallelComputeV0"),contractLedgerCostExt:e.lookup("ConfigSettingContractLedgerCostExtV0"),contractScpTiming:e.lookup("ConfigSettingScpTiming")}}),e.struct("LedgerCloseMetaBatch",[["startSequence",e.lookup("Uint32")],["endSequence",e.lookup("Uint32")],["ledgerCloseMeta",e.varArray(e.lookup("LedgerCloseMeta"),2147483647)]])});const i=o;const a={XdrWriter:n.XdrWriter,XdrReader:n.XdrReader};var s=r(2802);function u(e){var t=new s.sha256;return t.update(e,"utf8"),t.digest()}const c="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function l(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function f(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function p(e,...t){if(!l(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function d(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function h(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function y(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}const m=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),g=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function v(e){if(p(e),m)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=g[e[r]];return t}const b=48,w=57,S=65,E=70,k=97,A=102;function T(e){return e>=b&&e<=w?e-b:e>=S&&e<=E?e-(S-10):e>=k&&e<=A?e-(k-10):void 0}function O(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);if(m)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,o=0;t<r;t++,o+=2){const r=T(e.charCodeAt(o)),i=T(e.charCodeAt(o+1));if(void 0===r||void 0===i){const t=e[o]+e[o+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+o)}n[t]=16*r+i}return n}function x(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}function P(e){return"string"==typeof e&&(e=x(e)),p(e),e}function B(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];p(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const o=e[t];r.set(o,n),n+=o.length}return r}class I{}function C(e){const t=t=>e().update(P(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function R(e=32){if(c&&"function"==typeof c.getRandomValues)return c.getRandomValues(new Uint8Array(e));if(c&&"function"==typeof c.randomBytes)return Uint8Array.from(c.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}class _ extends I{constructor(e,t,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(e),this.view=y(this.buffer)}update(e){d(this),p(e=P(e));const{view:t,buffer:r,blockLen:n}=this,o=e.length;for(let i=0;i<o;){const a=Math.min(n-this.pos,o-i);if(a===n){const t=y(e);for(;n<=o-i;i+=n)this.process(t,i);continue}r.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===n&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){d(this),function(e,t){p(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:o}=this;let{pos:i}=this;t[i++]=128,h(this.buffer.subarray(i)),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const o=BigInt(32),i=BigInt(4294967295),a=Number(r>>o&i),s=Number(r&i),u=n?4:0,c=n?0:4;e.setUint32(t+u,a,n),e.setUint32(t+c,s,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const a=y(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=s/4,c=this.get();if(u>c.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<u;e++)a.setUint32(4*e,c[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:o,destroyed:i,pos:a}=this;return e.destroyed=i,e.finished=o,e.length=n,e.pos=a,n%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const U=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),N=BigInt(2**32-1),L=BigInt(32);function F(e,t=!1){return t?{h:Number(e&N),l:Number(e>>L&N)}:{h:0|Number(e>>L&N),l:0|Number(e&N)}}function j(e,t=!1){const r=e.length;let n=new Uint32Array(r),o=new Uint32Array(r);for(let i=0;i<r;i++){const{h:r,l:a}=F(e[i],t);[n[i],o[i]]=[r,a]}return[n,o]}const M=(e,t,r)=>e>>>r,D=(e,t,r)=>e<<32-r|t>>>r,V=(e,t,r)=>e>>>r|t<<32-r,q=(e,t,r)=>e<<32-r|t>>>r,K=(e,t,r)=>e<<64-r|t>>>r-32,H=(e,t,r)=>e>>>r-32|t<<64-r;function z(e,t,r,n){const o=(t>>>0)+(n>>>0);return{h:e+r+(o/2**32|0)|0,l:0|o}}const X=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),$=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,G=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),W=(e,t,r,n,o)=>t+r+n+o+(e/2**32|0)|0,Y=(e,t,r,n,o)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(o>>>0),Z=(e,t,r,n,o,i)=>t+r+n+o+i+(e/2**32|0)|0;const J=(()=>j(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))))(),Q=(()=>J[0])(),ee=(()=>J[1])(),te=new Uint32Array(80),re=new Uint32Array(80);class ne extends _{constructor(e=64){super(128,e,16,!1),this.Ah=0|U[0],this.Al=0|U[1],this.Bh=0|U[2],this.Bl=0|U[3],this.Ch=0|U[4],this.Cl=0|U[5],this.Dh=0|U[6],this.Dl=0|U[7],this.Eh=0|U[8],this.El=0|U[9],this.Fh=0|U[10],this.Fl=0|U[11],this.Gh=0|U[12],this.Gl=0|U[13],this.Hh=0|U[14],this.Hl=0|U[15]}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:o,Cl:i,Dh:a,Dl:s,Eh:u,El:c,Fh:l,Fl:f,Gh:p,Gl:d,Hh:h,Hl:y}=this;return[e,t,r,n,o,i,a,s,u,c,l,f,p,d,h,y]}set(e,t,r,n,o,i,a,s,u,c,l,f,p,d,h,y){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|o,this.Cl=0|i,this.Dh=0|a,this.Dl=0|s,this.Eh=0|u,this.El=0|c,this.Fh=0|l,this.Fl=0|f,this.Gh=0|p,this.Gl=0|d,this.Hh=0|h,this.Hl=0|y}process(e,t){for(let r=0;r<16;r++,t+=4)te[r]=e.getUint32(t),re[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|te[e-15],r=0|re[e-15],n=V(t,r,1)^V(t,r,8)^M(t,0,7),o=q(t,r,1)^q(t,r,8)^D(t,r,7),i=0|te[e-2],a=0|re[e-2],s=V(i,a,19)^K(i,a,61)^M(i,0,6),u=q(i,a,19)^H(i,a,61)^D(i,a,6),c=G(o,u,re[e-7],re[e-16]),l=W(c,n,s,te[e-7],te[e-16]);te[e]=0|l,re[e]=0|c}let{Ah:r,Al:n,Bh:o,Bl:i,Ch:a,Cl:s,Dh:u,Dl:c,Eh:l,El:f,Fh:p,Fl:d,Gh:h,Gl:y,Hh:m,Hl:g}=this;for(let e=0;e<80;e++){const t=V(l,f,14)^V(l,f,18)^K(l,f,41),v=q(l,f,14)^q(l,f,18)^H(l,f,41),b=l&p^~l&h,w=Y(g,v,f&d^~f&y,ee[e],re[e]),S=Z(w,m,t,b,Q[e],te[e]),E=0|w,k=V(r,n,28)^K(r,n,34)^K(r,n,39),A=q(r,n,28)^H(r,n,34)^H(r,n,39),T=r&o^r&a^o&a,O=n&i^n&s^i&s;m=0|h,g=0|y,h=0|p,y=0|d,p=0|l,d=0|f,({h:l,l:f}=z(0|u,0|c,0|S,0|E)),u=0|a,c=0|s,a=0|o,s=0|i,o=0|r,i=0|n;const x=X(E,A,O);r=$(x,S,k,T),n=0|x}({h:r,l:n}=z(0|this.Ah,0|this.Al,0|r,0|n)),({h:o,l:i}=z(0|this.Bh,0|this.Bl,0|o,0|i)),({h:a,l:s}=z(0|this.Ch,0|this.Cl,0|a,0|s)),({h:u,l:c}=z(0|this.Dh,0|this.Dl,0|u,0|c)),({h:l,l:f}=z(0|this.Eh,0|this.El,0|l,0|f)),({h:p,l:d}=z(0|this.Fh,0|this.Fl,0|p,0|d)),({h,l:y}=z(0|this.Gh,0|this.Gl,0|h,0|y)),({h:m,l:g}=z(0|this.Hh,0|this.Hl,0|m,0|g)),this.set(r,n,o,i,a,s,u,c,l,f,p,d,h,y,m,g)}roundClean(){h(te,re)}destroy(){h(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const oe=C(()=>new ne),ie=BigInt(0),ae=BigInt(1);function se(e,t=""){if("boolean"!=typeof e){throw new Error((t&&`"${t}"`)+"expected boolean, got type="+typeof e)}return e}function ue(e,t,r=""){const n=l(e),o=e?.length,i=void 0!==t;if(!n||i&&o!==t){throw new Error((r&&`"${r}" `)+"expected Uint8Array"+(i?` of length ${t}`:"")+", got "+(n?`length=${o}`:"type="+typeof e))}return e}function ce(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?ie:BigInt("0x"+e)}function le(e){return p(e),ce(v(Uint8Array.from(e).reverse()))}function fe(e,t){return O(e.toString(16).padStart(2*t,"0"))}function pe(e,t,r){let n;if("string"==typeof t)try{n=O(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!l(t))throw new Error(e+" must be hex string or Uint8Array");n=Uint8Array.from(t)}const o=n.length;if("number"==typeof r&&o!==r)throw new Error(e+" of length "+r+" expected, got "+o);return n}function de(e){return Uint8Array.from(e)}const he=e=>"bigint"==typeof e&&ie<=e;function ye(e,t,r,n){if(!function(e,t,r){return he(e)&&he(t)&&he(r)&&t<=e&&e<r}(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}const me=e=>(ae<<BigInt(e))-ae;function ge(e,t,r={}){if(!e||"object"!=typeof e)throw new Error("expected valid options object");function n(t,r,n){const o=e[t];if(n&&void 0===o)return;const i=typeof o;if(i!==r||null===o)throw new Error(`param "${t}" is invalid: expected ${r}, got ${i}`)}Object.entries(t).forEach(([e,t])=>n(e,t,!1)),Object.entries(r).forEach(([e,t])=>n(e,t,!0))}const ve=()=>{throw new Error("not implemented")};function be(e){const t=new WeakMap;return(r,...n)=>{const o=t.get(r);if(void 0!==o)return o;const i=e(r,...n);return t.set(r,i),i}}const we=BigInt(0),Se=BigInt(1),Ee=BigInt(2),ke=BigInt(3),Ae=BigInt(4),Te=BigInt(5),Oe=BigInt(7),xe=BigInt(8),Pe=BigInt(9),Be=BigInt(16);function Ie(e,t){const r=e%t;return r>=we?r:t+r}function Ce(e,t,r){let n=e;for(;t-- >we;)n*=n,n%=r;return n}function Re(e,t){if(e===we)throw new Error("invert: expected non-zero number");if(t<=we)throw new Error("invert: expected positive modulus, got "+t);let r=Ie(e,t),n=t,o=we,i=Se,a=Se,s=we;for(;r!==we;){const e=n/r,t=n%r,u=o-a*e,c=i-s*e;n=r,r=t,o=a,i=s,a=u,s=c}if(n!==Se)throw new Error("invert: does not exist");return Ie(o,t)}function _e(e,t,r){if(!e.eql(e.sqr(t),r))throw new Error("Cannot find square root")}function Ue(e,t){const r=(e.ORDER+Se)/Ae,n=e.pow(t,r);return _e(e,n,t),n}function Ne(e,t){const r=(e.ORDER-Te)/xe,n=e.mul(t,Ee),o=e.pow(n,r),i=e.mul(t,o),a=e.mul(e.mul(i,Ee),o),s=e.mul(i,e.sub(a,e.ONE));return _e(e,s,t),s}function Le(e){if(e<ke)throw new Error("sqrt is not defined for small field");let t=e-Se,r=0;for(;t%Ee===we;)t/=Ee,r++;let n=Ee;const o=He(e);for(;1===qe(o,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return Ue;let i=o.pow(n,t);const a=(t+Se)/Ee;return function(e,n){if(e.is0(n))return n;if(1!==qe(e,n))throw new Error("Cannot find square root");let o=r,s=e.mul(e.ONE,i),u=e.pow(n,t),c=e.pow(n,a);for(;!e.eql(u,e.ONE);){if(e.is0(u))return e.ZERO;let t=1,r=e.sqr(u);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===o)throw new Error("Cannot find square root");const n=Se<<BigInt(o-t-1),i=e.pow(s,n);o=t,s=e.sqr(i),u=e.mul(u,s),c=e.mul(c,i)}return c}}function Fe(e){return e%Ae===ke?Ue:e%xe===Te?Ne:e%Be===Pe?function(e){const t=He(e),r=Le(e),n=r(t,t.neg(t.ONE)),o=r(t,n),i=r(t,t.neg(n)),a=(e+Oe)/Be;return(e,t)=>{let r=e.pow(t,a),s=e.mul(r,n);const u=e.mul(r,o),c=e.mul(r,i),l=e.eql(e.sqr(s),t),f=e.eql(e.sqr(u),t);r=e.cmov(r,s,l),s=e.cmov(c,u,f);const p=e.eql(e.sqr(s),t),d=e.cmov(r,s,p);return _e(e,d,t),d}}(e):Le(e)}const je=(e,t)=>(Ie(e,t)&Se)===Se,Me=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function De(e,t,r){if(r<we)throw new Error("invalid exponent, negatives unsupported");if(r===we)return e.ONE;if(r===Se)return t;let n=e.ONE,o=t;for(;r>we;)r&Se&&(n=e.mul(n,o)),o=e.sqr(o),r>>=Se;return n}function Ve(e,t,r=!1){const n=new Array(t.length).fill(r?e.ZERO:void 0),o=t.reduce((t,r,o)=>e.is0(r)?t:(n[o]=t,e.mul(t,r)),e.ONE),i=e.inv(o);return t.reduceRight((t,r,o)=>e.is0(r)?t:(n[o]=e.mul(t,n[o]),e.mul(t,r)),i),n}function qe(e,t){const r=(e.ORDER-Se)/Ee,n=e.pow(t,r),o=e.eql(n,e.ONE),i=e.eql(n,e.ZERO),a=e.eql(n,e.neg(e.ONE));if(!o&&!i&&!a)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function Ke(e,t){void 0!==t&&f(t);const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function He(e,t,r=!1,n={}){if(e<=we)throw new Error("invalid field: expected ORDER > 0, got "+e);let o,i,a,s=!1;if("object"==typeof t&&null!=t){if(n.sqrt||r)throw new Error("cannot specify opts in two arguments");const e=t;e.BITS&&(o=e.BITS),e.sqrt&&(i=e.sqrt),"boolean"==typeof e.isLE&&(r=e.isLE),"boolean"==typeof e.modFromBytes&&(s=e.modFromBytes),a=e.allowedLengths}else"number"==typeof t&&(o=t),n.sqrt&&(i=n.sqrt);const{nBitLength:u,nByteLength:c}=Ke(e,o);if(c>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let l;const f=Object.freeze({ORDER:e,isLE:r,BITS:u,BYTES:c,MASK:me(u),ZERO:we,ONE:Se,allowedLengths:a,create:t=>Ie(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return we<=t&&t<e},is0:e=>e===we,isValidNot0:e=>!f.is0(e)&&f.isValid(e),isOdd:e=>(e&Se)===Se,neg:t=>Ie(-t,e),eql:(e,t)=>e===t,sqr:t=>Ie(t*t,e),add:(t,r)=>Ie(t+r,e),sub:(t,r)=>Ie(t-r,e),mul:(t,r)=>Ie(t*r,e),pow:(e,t)=>De(f,e,t),div:(t,r)=>Ie(t*Re(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Re(t,e),sqrt:i||(t=>(l||(l=Fe(e)),l(f,t))),toBytes:e=>r?fe(e,c).reverse():fe(e,c),fromBytes:(t,n=!0)=>{if(a){if(!a.includes(t.length)||t.length>c)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+t.length);const e=new Uint8Array(c);e.set(t,r?0:e.length-t.length),t=e}if(t.length!==c)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+t.length);let o=r?le(t):function(e){return ce(v(e))}(t);if(s&&(o=Ie(o,e)),!n&&!f.isValid(o))throw new Error("invalid field element: outside of range 0..ORDER");return o},invertBatch:e=>Ve(f,e),cmov:(e,t,r)=>r?t:e});return Object.freeze(f)}const ze=BigInt(0),Xe=BigInt(1);function $e(e,t){const r=t.negate();return e?r:t}function Ge(e,t){const r=Ve(e.Fp,t.map(e=>e.Z));return t.map((t,n)=>e.fromAffine(t.toAffine(r[n])))}function We(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function Ye(e,t){We(e,t);const r=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:me(e),maxNumber:r,shiftBy:BigInt(e)}}function Ze(e,t,r){const{windowSize:n,mask:o,maxNumber:i,shiftBy:a}=r;let s=Number(e&o),u=e>>a;s>n&&(s-=i,u+=Xe);const c=t*n;return{nextN:u,offset:c+Math.abs(s)-1,isZero:0===s,isNeg:s<0,isNegF:t%2!=0,offsetF:c}}function Je(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)})}function Qe(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)})}const et=new WeakMap,tt=new WeakMap;function rt(e){return tt.get(e)||1}function nt(e){if(e!==ze)throw new Error("invalid wNAF")}class ot{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>ze;)t&Xe&&(r=r.add(n)),n=n.double(),t>>=Xe;return r}precomputeWindow(e,t){const{windows:r,windowSize:n}=Ye(t,this.bits),o=[];let i=e,a=i;for(let e=0;e<r;e++){a=i,o.push(a);for(let e=1;e<n;e++)a=a.add(i),o.push(a);i=a.double()}return o}wNAF(e,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let n=this.ZERO,o=this.BASE;const i=Ye(e,this.bits);for(let e=0;e<i.windows;e++){const{nextN:a,offset:s,isZero:u,isNeg:c,isNegF:l,offsetF:f}=Ze(r,e,i);r=a,u?o=o.add($e(l,t[f])):n=n.add($e(c,t[s]))}return nt(r),{p:n,f:o}}wNAFUnsafe(e,t,r,n=this.ZERO){const o=Ye(e,this.bits);for(let e=0;e<o.windows&&r!==ze;e++){const{nextN:i,offset:a,isZero:s,isNeg:u}=Ze(r,e,o);if(r=i,!s){const e=t[a];n=n.add(u?e.negate():e)}}return nt(r),n}getPrecomputes(e,t,r){let n=et.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(n=r(n)),et.set(t,n))),n}cached(e,t,r){const n=rt(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){const o=rt(e);return 1===o?this._unsafeLadder(e,t,n):this.wNAFUnsafe(o,this.getPrecomputes(o,e,r),t,n)}createCache(e,t){We(t,this.bits),tt.set(e,t),et.delete(e)}hasCache(e){return 1!==rt(e)}}function it(e,t,r,n){Je(r,e),Qe(n,t);const o=r.length,i=n.length;if(o!==i)throw new Error("arrays of points and scalars must have equal length");const a=e.ZERO,s=function(e){let t;for(t=0;e>ie;e>>=ae,t+=1);return t}(BigInt(o));let u=1;s>12?u=s-3:s>4?u=s-2:s>0&&(u=2);const c=me(u),l=new Array(Number(c)+1).fill(a);let f=a;for(let e=Math.floor((t.BITS-1)/u)*u;e>=0;e-=u){l.fill(a);for(let t=0;t<i;t++){const o=n[t],i=Number(o>>BigInt(e)&c);l[i]=l[i].add(r[t])}let t=a;for(let e=l.length-1,r=a;e>0;e--)r=r.add(l[e]),t=t.add(r);if(f=f.add(t),0!==e)for(let e=0;e<u;e++)f=f.double()}return f}function at(e,t,r){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return function(e){ge(e,Me.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(t),t}return He(e,{isLE:r})}const st=BigInt(0),ut=BigInt(1),ct=BigInt(2),lt=BigInt(8);function ft(e,t={}){const r=function(e,t,r={},n){if(void 0===n&&(n="edwards"===e),!t||"object"!=typeof t)throw new Error(`expected valid ${e} CURVE object`);for(const e of["p","n","h"]){const r=t[e];if(!("bigint"==typeof r&&r>ze))throw new Error(`CURVE.${e} must be positive bigint`)}const o=at(t.p,r.Fp,n),i=at(t.n,r.Fn,n),a=["Gx","Gy","a","weierstrass"===e?"b":"d"];for(const e of a)if(!o.isValid(t[e]))throw new Error(`CURVE.${e} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:o,Fn:i}}("edwards",e,t,t.FpFnLE),{Fp:n,Fn:o}=r;let i=r.CURVE;const{h:a}=i;ge(t,{},{uvRatio:"function"});const s=ct<<BigInt(8*o.BYTES)-ut,u=e=>n.create(e),c=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:n.sqrt(n.div(e,t))}}catch(e){return{isValid:!1,value:st}}});if(!function(e,t,r,n){const o=e.sqr(r),i=e.sqr(n),a=e.add(e.mul(t.a,o),i),s=e.add(e.ONE,e.mul(t.d,e.mul(o,i)));return e.eql(a,s)}(n,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function l(e,t,r=!1){return ye("coordinate "+e,t,r?ut:st,s),t}function f(e){if(!(e instanceof h))throw new Error("ExtendedPoint expected")}const p=be((e,t)=>{const{X:r,Y:o,Z:i}=e,a=e.is0();null==t&&(t=a?lt:n.inv(i));const s=u(r*t),c=u(o*t),l=n.mul(i,t);if(a)return{x:st,y:ut};if(l!==ut)throw new Error("invZ was invalid");return{x:s,y:c}}),d=be(e=>{const{a:t,d:r}=i;if(e.is0())throw new Error("bad point: ZERO");const{X:n,Y:o,Z:a,T:s}=e,c=u(n*n),l=u(o*o),f=u(a*a),p=u(f*f),d=u(c*t);if(u(f*u(d+l))!==u(p+u(r*u(c*l))))throw new Error("bad point: equation left != right (1)");if(u(n*o)!==u(a*s))throw new Error("bad point: equation left != right (2)");return!0});class h{constructor(e,t,r,n){this.X=l("x",e),this.Y=l("y",t),this.Z=l("z",r,!0),this.T=l("t",n),Object.freeze(this)}static CURVE(){return i}static fromAffine(e){if(e instanceof h)throw new Error("extended point not allowed");const{x:t,y:r}=e||{};return l("x",t),l("y",r),new h(t,r,ut,u(t*r))}static fromBytes(e,t=!1){const r=n.BYTES,{a:o,d:a}=i;e=de(ue(e,r,"point")),se(t,"zip215");const l=de(e),f=e[r-1];l[r-1]=-129&f;const p=le(l),d=t?s:n.ORDER;ye("point.y",p,st,d);const y=u(p*p),m=u(y-ut),g=u(a*y-o);let{isValid:v,value:b}=c(m,g);if(!v)throw new Error("bad point: invalid y coordinate");const w=(b&ut)===ut,S=!!(128&f);if(!t&&b===st&&S)throw new Error("bad point: x=0 and x_0=1");return S!==w&&(b=u(-b)),h.fromAffine({x:b,y:p})}static fromHex(e,t=!1){return h.fromBytes(pe("point",e),t)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return y.createCache(this,e),t||this.multiply(ct),this}assertValidity(){d(this)}equals(e){f(e);const{X:t,Y:r,Z:n}=this,{X:o,Y:i,Z:a}=e,s=u(t*a),c=u(o*n),l=u(r*a),p=u(i*n);return s===c&&l===p}is0(){return this.equals(h.ZERO)}negate(){return new h(u(-this.X),this.Y,this.Z,u(-this.T))}double(){const{a:e}=i,{X:t,Y:r,Z:n}=this,o=u(t*t),a=u(r*r),s=u(ct*u(n*n)),c=u(e*o),l=t+r,f=u(u(l*l)-o-a),p=c+a,d=p-s,y=c-a,m=u(f*d),g=u(p*y),v=u(f*y),b=u(d*p);return new h(m,g,b,v)}add(e){f(e);const{a:t,d:r}=i,{X:n,Y:o,Z:a,T:s}=this,{X:c,Y:l,Z:p,T:d}=e,y=u(n*c),m=u(o*l),g=u(s*r*d),v=u(a*p),b=u((n+o)*(c+l)-y-m),w=v-g,S=v+g,E=u(m-t*y),k=u(b*w),A=u(S*E),T=u(b*E),O=u(w*S);return new h(k,A,O,T)}subtract(e){return this.add(e.negate())}multiply(e){if(!o.isValidNot0(e))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:t,f:r}=y.cached(this,e,e=>Ge(h,e));return Ge(h,[t,r])[0]}multiplyUnsafe(e,t=h.ZERO){if(!o.isValid(e))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return e===st?h.ZERO:this.is0()||e===ut?this:y.unsafe(this,e,e=>Ge(h,e),t)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return y.unsafe(this,i.n).is0()}toAffine(e){return p(this,e)}clearCofactor(){return a===ut?this:this.multiplyUnsafe(a)}toBytes(){const{x:e,y:t}=this.toAffine(),r=n.toBytes(t);return r[r.length-1]|=e&ut?128:0,r}toHex(){return v(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(e){return Ge(h,e)}static msm(e,t){return it(h,o,e,t)}_setWindowSize(e){this.precompute(e)}toRawBytes(){return this.toBytes()}}h.BASE=new h(i.Gx,i.Gy,ut,u(i.Gx*i.Gy)),h.ZERO=new h(st,ut,ut,st),h.Fp=n,h.Fn=o;const y=new ot(h,o.BITS);return h.BASE.precompute(8),h}class pt{constructor(e){this.ep=e}static fromBytes(e){ve()}static fromHex(e){ve()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(e){return this.ep.toAffine(e)}toHex(){return v(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(e){return this.assertSame(e),this.init(this.ep.add(e.ep))}subtract(e){return this.assertSame(e),this.init(this.ep.subtract(e.ep))}multiply(e){return this.init(this.ep.multiply(e))}multiplyUnsafe(e){return this.init(this.ep.multiplyUnsafe(e))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(e,t){return this.init(this.ep.precompute(e,t))}toRawBytes(){return this.toBytes()}}function dt(e,t,r={}){if("function"!=typeof t)throw new Error('"hash" function param is required');ge(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=r,{BASE:o,Fp:i,Fn:a}=e,s=r.randomBytes||R,u=r.adjustScalarBytes||(e=>e),c=r.domain||((e,t,r)=>{if(se(r,"phflag"),t.length||r)throw new Error("Contexts/pre-hash are not supported");return e});function f(e){return a.create(le(e))}function p(e){const{head:r,prefix:n,scalar:i}=function(e){const r=g.secretKey;e=pe("private key",e,r);const n=pe("hashed private key",t(e),2*r),o=u(n.slice(0,r));return{head:o,prefix:n.slice(r,2*r),scalar:f(o)}}(e),a=o.multiply(i),s=a.toBytes();return{head:r,prefix:n,scalar:i,point:a,pointBytes:s}}function d(e){return p(e).pointBytes}function h(e=Uint8Array.of(),...r){const o=B(...r);return f(t(c(o,pe("context",e),!!n)))}const y={zip215:!0};const m=i.BYTES,g={secretKey:m,publicKey:m,signature:2*m,seed:m};function v(e=s(g.seed)){return ue(e,g.seed,"seed")}const b={getExtendedPublicKey:p,randomSecretKey:v,isValidSecretKey:function(e){return l(e)&&e.length===a.BYTES},isValidPublicKey:function(t,r){try{return!!e.fromBytes(t,r)}catch(e){return!1}},toMontgomery(t){const{y:r}=e.fromBytes(t),n=g.publicKey,o=32===n;if(!o&&57!==n)throw new Error("only defined for 25519 and 448");const a=o?i.div(ut+r,ut-r):i.div(r-ut,r+ut);return i.toBytes(a)},toMontgomeryPriv(e){const r=g.secretKey;ue(e,r);const n=t(e.subarray(0,r));return u(n).subarray(0,r)},randomPrivateKey:v,precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({keygen:function(e){const t=b.randomSecretKey(e);return{secretKey:t,publicKey:d(t)}},getPublicKey:d,sign:function(e,t,r={}){e=pe("message",e),n&&(e=n(e));const{prefix:i,scalar:s,pointBytes:u}=p(t),c=h(r.context,i,e),l=o.multiply(c).toBytes(),f=h(r.context,l,u,e),d=a.create(c+f*s);if(!a.isValid(d))throw new Error("sign failed: invalid s");return ue(B(l,a.toBytes(d)),g.signature,"result")},verify:function(t,r,i,a=y){const{context:s,zip215:u}=a,c=g.signature;t=pe("signature",t,c),r=pe("message",r),i=pe("publicKey",i,g.publicKey),void 0!==u&&se(u,"zip215"),n&&(r=n(r));const l=c/2,f=t.subarray(0,l),p=le(t.subarray(l,c));let d,m,v;try{d=e.fromBytes(i,u),m=e.fromBytes(f,u),v=o.multiplyUnsafe(p)}catch(e){return!1}if(!u&&d.isSmallOrder())return!1;const b=h(s,m.toBytes(),d.toBytes(),r);return m.add(d.multiplyUnsafe(b)).subtract(v).clearCofactor().is0()},utils:b,Point:e,lengths:g})}function ht(e){const{CURVE:t,curveOpts:r,hash:n,eddsaOpts:o}=function(e){const t={a:e.a,d:e.d,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r={Fp:e.Fp,Fn:He(t.n,e.nBitLength,!0),uvRatio:e.uvRatio},n={randomBytes:e.randomBytes,adjustScalarBytes:e.adjustScalarBytes,domain:e.domain,prehash:e.prehash,mapToCurve:e.mapToCurve};return{CURVE:t,curveOpts:r,hash:e.hash,eddsaOpts:n}}(e);return function(e,t){const r=t.Point;return Object.assign({},t,{ExtendedPoint:r,CURVE:e,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(e,dt(ft(t,r),n,o))}x("HashToScalar-");const yt=BigInt(0),mt=BigInt(1),gt=BigInt(2),vt=(BigInt(3),BigInt(5)),bt=BigInt(8),wt=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),St=(()=>({p:wt,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:bt,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function Et(e){const t=BigInt(10),r=BigInt(20),n=BigInt(40),o=BigInt(80),i=wt,a=e*e%i*e%i,s=Ce(a,gt,i)*a%i,u=Ce(s,mt,i)*e%i,c=Ce(u,vt,i)*u%i,l=Ce(c,t,i)*c%i,f=Ce(l,r,i)*l%i,p=Ce(f,n,i)*f%i,d=Ce(p,o,i)*p%i,h=Ce(d,o,i)*p%i,y=Ce(h,t,i)*c%i;return{pow_p_5_8:Ce(y,gt,i)*e%i,b2:a}}function kt(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const At=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Tt(e,t){const r=wt,n=Ie(t*t*t,r),o=Ie(n*n*t,r);let i=Ie(e*n*Et(e*o).pow_p_5_8,r);const a=Ie(t*i*i,r),s=i,u=Ie(i*At,r),c=a===e,l=a===Ie(-e,r),f=a===Ie(-e*At,r);return c&&(i=s),(l||f)&&(i=u),je(i,r)&&(i=Ie(-i,r)),{isValid:c||l,value:i}}const Ot=(()=>He(St.p,{isLE:!0}))(),xt=(()=>He(St.n,{isLE:!0}))(),Pt=(()=>({...St,Fp:Ot,hash:oe,adjustScalarBytes:kt,uvRatio:Tt}))(),Bt=(()=>ht(Pt))();const It=At,Ct=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),Rt=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),_t=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),Ut=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),Nt=e=>Tt(mt,e),Lt=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),Ft=e=>Bt.Point.Fp.create(le(e)&Lt);function jt(e){const{d:t}=St,r=wt,n=e=>Ot.create(e),o=n(It*e*e),i=n((o+mt)*_t);let a=BigInt(-1);const s=n((a-t*o)*n(o+t));let{isValid:u,value:c}=Tt(i,s),l=n(c*e);je(l,r)||(l=n(-l)),u||(c=l),u||(a=o);const f=n(a*(o-mt)*Ut-s),p=c*c,d=n((c+c)*s),h=n(f*Ct),y=n(mt-p),m=n(mt+p);return new Bt.Point(n(d*m),n(y*h),n(h*m),n(d*y))}function Mt(e){p(e,64);const t=jt(Ft(e.subarray(0,32))),r=jt(Ft(e.subarray(32,64)));return new Dt(t.add(r))}class Dt extends pt{constructor(e){super(e)}static fromAffine(e){return new Dt(Bt.Point.fromAffine(e))}assertSame(e){if(!(e instanceof Dt))throw new Error("RistrettoPoint expected")}init(e){return new Dt(e)}static hashToCurve(e){return Mt(pe("ristrettoHash",e,64))}static fromBytes(e){p(e,32);const{a:t,d:r}=St,n=wt,o=e=>Ot.create(e),i=Ft(e);if(!function(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r}(Ot.toBytes(i),e)||je(i,n))throw new Error("invalid ristretto255 encoding 1");const a=o(i*i),s=o(mt+t*a),u=o(mt-t*a),c=o(s*s),l=o(u*u),f=o(t*r*c-l),{isValid:d,value:h}=Nt(o(f*l)),y=o(h*u),m=o(h*y*f);let g=o((i+i)*y);je(g,n)&&(g=o(-g));const v=o(s*m),b=o(g*v);if(!d||je(b,n)||v===yt)throw new Error("invalid ristretto255 encoding 2");return new Dt(new Bt.Point(g,v,mt,b))}static fromHex(e){return Dt.fromBytes(pe("ristrettoHex",e,32))}static msm(e,t){return it(Dt,Bt.Point.Fn,e,t)}toBytes(){let{X:e,Y:t,Z:r,T:n}=this.ep;const o=wt,i=e=>Ot.create(e),a=i(i(r+t)*i(r-t)),s=i(e*t),u=i(s*s),{value:c}=Nt(i(a*u)),l=i(c*a),f=i(c*s),p=i(l*f*n);let d;if(je(n*p,o)){let r=i(t*It),n=i(e*It);e=r,t=n,d=i(l*Rt)}else d=f;je(e*p,o)&&(t=i(-t));let h=i((r-t)*d);return je(h,o)&&(h=i(-h)),Ot.toBytes(h)}equals(e){this.assertSame(e);const{X:t,Y:r}=this.ep,{X:n,Y:o}=e.ep,i=e=>Ot.create(e),a=i(t*o)===i(r*n),s=i(r*o)===i(t*n);return a||s}is0(){return this.equals(Dt.ZERO)}}Dt.BASE=(()=>new Dt(Bt.Point.BASE))(),Dt.ZERO=(()=>new Dt(Bt.Point.ZERO))(),Dt.Fp=(()=>Ot)(),Dt.Fn=(()=>xt)();var Vt=r(8287).Buffer;function qt(e,t){return Vt.from(Bt.sign(Vt.from(e),t))}function Kt(e,t,r){return Bt.verify(Vt.from(t),Vt.from(e),Vt.from(r),{zip215:!1})}var Ht=function(e,t){for(var r="number"==typeof e,n=String(e);n.endsWith(t);)n=n.slice(0,-1);return r?Number(n):n},zt=r(5360);var Xt=r(8287).Buffer;function $t(e){return $t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},$t(e)}function Gt(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Wt(n.key),n)}}function Wt(e){var t=function(e,t){if("object"!=$t(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=$t(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==$t(t)?t:t+""}var Yt,Zt,Jt,Qt={ed25519PublicKey:48,ed25519SecretSeed:144,med25519PublicKey:96,preAuthTx:152,sha256Hash:184,signedPayload:120,contract:16,liquidityPool:88,claimableBalance:8},er={G:"ed25519PublicKey",S:"ed25519SecretSeed",M:"med25519PublicKey",T:"preAuthTx",X:"sha256Hash",P:"signedPayload",C:"contract",L:"liquidityPool",B:"claimableBalance"},tr=function(){return e=function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)},r=[{key:"encodeEd25519PublicKey",value:function(e){return or("ed25519PublicKey",e)}},{key:"decodeEd25519PublicKey",value:function(e){return nr("ed25519PublicKey",e)}},{key:"isValidEd25519PublicKey",value:function(e){return rr("ed25519PublicKey",e)}},{key:"encodeEd25519SecretSeed",value:function(e){return or("ed25519SecretSeed",e)}},{key:"decodeEd25519SecretSeed",value:function(e){return nr("ed25519SecretSeed",e)}},{key:"isValidEd25519SecretSeed",value:function(e){return rr("ed25519SecretSeed",e)}},{key:"encodeMed25519PublicKey",value:function(e){return or("med25519PublicKey",e)}},{key:"decodeMed25519PublicKey",value:function(e){return nr("med25519PublicKey",e)}},{key:"isValidMed25519PublicKey",value:function(e){return rr("med25519PublicKey",e)}},{key:"encodePreAuthTx",value:function(e){return or("preAuthTx",e)}},{key:"decodePreAuthTx",value:function(e){return nr("preAuthTx",e)}},{key:"encodeSha256Hash",value:function(e){return or("sha256Hash",e)}},{key:"decodeSha256Hash",value:function(e){return nr("sha256Hash",e)}},{key:"encodeSignedPayload",value:function(e){return or("signedPayload",e)}},{key:"decodeSignedPayload",value:function(e){return nr("signedPayload",e)}},{key:"isValidSignedPayload",value:function(e){return rr("signedPayload",e)}},{key:"encodeContract",value:function(e){return or("contract",e)}},{key:"decodeContract",value:function(e){return nr("contract",e)}},{key:"isValidContract",value:function(e){return rr("contract",e)}},{key:"encodeClaimableBalance",value:function(e){return or("claimableBalance",e)}},{key:"decodeClaimableBalance",value:function(e){return nr("claimableBalance",e)}},{key:"isValidClaimableBalance",value:function(e){return rr("claimableBalance",e)}},{key:"encodeLiquidityPool",value:function(e){return or("liquidityPool",e)}},{key:"decodeLiquidityPool",value:function(e){return nr("liquidityPool",e)}},{key:"isValidLiquidityPool",value:function(e){return rr("liquidityPool",e)}},{key:"getVersionByteForPrefix",value:function(e){return er[e[0]]}}],(t=null)&&Gt(e.prototype,t),r&&Gt(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e;// removed by dead control flow
{ var e, t, r; }}();function rr(e,t){if("string"!=typeof t)return!1;switch(e){case"ed25519PublicKey":case"ed25519SecretSeed":case"preAuthTx":case"sha256Hash":case"contract":case"liquidityPool":if(56!==t.length)return!1;break;case"claimableBalance":if(58!==t.length)return!1;break;case"med25519PublicKey":if(69!==t.length)return!1;break;case"signedPayload":if(t.length<56||t.length>165)return!1;break;default:return!1}var r="";try{r=nr(e,t)}catch(e){return!1}switch(e){case"ed25519PublicKey":case"ed25519SecretSeed":case"preAuthTx":case"sha256Hash":case"contract":case"liquidityPool":return 32===r.length;case"claimableBalance":return 33===r.length;case"med25519PublicKey":return 40===r.length;case"signedPayload":return r.length>=40&&r.length<=100;default:return!1}}function nr(e,t){if("string"!=typeof t)throw new TypeError("encoded argument must be of type String");var r=zt.decode(t),n=r[0],o=r.slice(0,-2),i=o.slice(1),a=r.slice(-2);if(t!==zt.encode(r))throw new Error("invalid encoded string");var s=Qt[e];if(void 0===s)throw new Error("".concat(e," is not a valid version byte name. ")+"Expected one of ".concat(Object.keys(Qt).join(", ")));if(n!==s)throw new Error("invalid version byte. expected ".concat(s,", got ").concat(n));if(!function(e,t){if(e.length!==t.length)return!1;if(0===e.length)return!0;for(var r=0;r<e.length;r+=1)if(e[r]!==t[r])return!1;return!0}(ir(o),a))throw new Error("invalid checksum");return Xt.from(i)}function or(e,t){if(null==t)throw new Error("cannot encode null data");var r=Qt[e];if(void 0===r)throw new Error("".concat(e," is not a valid version byte name. ")+"Expected one of ".concat(Object.keys(Qt).join(", ")));t=Xt.from(t);var n=Xt.from([r]),o=Xt.concat([n,t]),i=Xt.from(ir(o)),a=Xt.concat([o,i]);return zt.encode(a)}function ir(e){for(var t=[0,4129,8258,12387,16516,20645,24774,28903,33032,37161,41290,45419,49548,53677,57806,61935,4657,528,12915,8786,21173,17044,29431,25302,37689,33560,45947,41818,54205,50076,62463,58334,9314,13379,1056,5121,25830,29895,17572,21637,42346,46411,34088,38153,58862,62927,50604,54669,13907,9842,5649,1584,30423,26358,22165,18100,46939,42874,38681,34616,63455,59390,55197,51132,18628,22757,26758,30887,2112,6241,10242,14371,51660,55789,59790,63919,35144,39273,43274,47403,23285,19156,31415,27286,6769,2640,14899,10770,56317,52188,64447,60318,39801,35672,47931,43802,27814,31879,19684,23749,11298,15363,3168,7233,60846,64911,52716,56781,44330,48395,36200,40265,32407,28342,24277,20212,15891,11826,7761,3696,65439,61374,57309,53244,48923,44858,40793,36728,37256,33193,45514,41451,53516,49453,61774,57711,4224,161,12482,8419,20484,16421,28742,24679,33721,37784,41979,46042,49981,54044,58239,62302,689,4752,8947,13010,16949,21012,25207,29270,46570,42443,38312,34185,62830,58703,54572,50445,13538,9411,5280,1153,29798,25671,21540,17413,42971,47098,34713,38840,59231,63358,50973,55100,9939,14066,1681,5808,26199,30326,17941,22068,55628,51565,63758,59695,39368,35305,47498,43435,22596,18533,30726,26663,6336,2273,14466,10403,52093,56156,60223,64286,35833,39896,43963,48026,19061,23124,27191,31254,2801,6864,10931,14994,64814,60687,56684,52557,48554,44427,40424,36297,31782,27655,23652,19525,15522,11395,7392,3265,61215,65342,53085,57212,44955,49082,36825,40952,28183,32310,20053,24180,11923,16050,3793,7920],r=0,n=0;n<e.length;n+=1){r=r<<8^t[r>>8^e[n]],r&=65535}var o=new Uint8Array(2);return o[0]=255&r,o[1]=r>>8&255,o}Yt=tr,Jt=er,(Zt=Wt(Zt="types"))in Yt?Object.defineProperty(Yt,Zt,{value:Jt,enumerable:!0,configurable:!0,writable:!0}):Yt[Zt]=Jt;var ar=r(8287).Buffer;function sr(e){return sr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},sr(e)}function ur(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,cr(n.key),n)}}function cr(e){var t=function(e,t){if("object"!=sr(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=sr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==sr(t)?t:t+""}var lr=function(){return function(e,t,r){return t&&ur(e.prototype,t),r&&ur(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),"ed25519"!==t.type)throw new Error("Invalid keys type");if(this.type=t.type,t.secretKey){if(t.secretKey=ar.from(t.secretKey),32!==t.secretKey.length)throw new Error("secretKey length is invalid");if(this._secretSeed=t.secretKey,this._publicKey=(r=t.secretKey,Vt.from(Bt.getPublicKey(r))),this._secretKey=t.secretKey,t.publicKey&&!this._publicKey.equals(ar.from(t.publicKey)))throw new Error("secretKey does not match publicKey")}else if(this._publicKey=ar.from(t.publicKey),32!==this._publicKey.length)throw new Error("publicKey length is invalid");var r},[{key:"xdrAccountId",value:function(){return new i.AccountId.publicKeyTypeEd25519(this._publicKey)}},{key:"xdrPublicKey",value:function(){return new i.PublicKey.publicKeyTypeEd25519(this._publicKey)}},{key:"xdrMuxedAccount",value:function(e){if(void 0!==e){if("string"!=typeof e)throw new TypeError("expected string for ID, got ".concat(sr(e)));return i.MuxedAccount.keyTypeMuxedEd25519(new i.MuxedAccountMed25519({id:i.Uint64.fromString(e),ed25519:this._publicKey}))}return new i.MuxedAccount.keyTypeEd25519(this._publicKey)}},{key:"rawPublicKey",value:function(){return this._publicKey}},{key:"signatureHint",value:function(){var e=this.xdrAccountId().toXDR();return e.slice(e.length-4)}},{key:"publicKey",value:function(){return tr.encodeEd25519PublicKey(this._publicKey)}},{key:"secret",value:function(){if(!this._secretSeed)throw new Error("no secret key available");if("ed25519"===this.type)return tr.encodeEd25519SecretSeed(this._secretSeed);throw new Error("Invalid Keypair type")}},{key:"rawSecretKey",value:function(){return this._secretSeed}},{key:"canSign",value:function(){return!!this._secretKey}},{key:"sign",value:function(e){if(!this.canSign())throw new Error("cannot sign: no secret key available");return qt(e,this._secretKey)}},{key:"verify",value:function(e,t){return Kt(e,t,this._publicKey)}},{key:"signDecorated",value:function(e){var t=this.sign(e),r=this.signatureHint();return new i.DecoratedSignature({hint:r,signature:t})}},{key:"signPayloadDecorated",value:function(e){var t=this.sign(e),r=this.signatureHint(),n=ar.from(e.slice(-4));return n.length<4&&(n=ar.concat([n,ar.alloc(4-e.length,0)])),new i.DecoratedSignature({hint:n.map(function(e,t){return e^r[t]}),signature:t})}}],[{key:"fromSecret",value:function(e){var t=tr.decodeEd25519SecretSeed(e);return this.fromRawEd25519Seed(t)}},{key:"fromRawEd25519Seed",value:function(e){return new this({type:"ed25519",secretKey:e})}},{key:"master",value:function(e){if(!e)throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");return this.fromRawEd25519Seed(u(e))}},{key:"fromPublicKey",value:function(e){if(32!==(e=tr.decodeEd25519PublicKey(e)).length)throw new Error("Invalid Stellar public key");return new this({type:"ed25519",publicKey:e})}},{key:"random",value:function(){var e=Bt.utils.randomPrivateKey();return this.fromRawEd25519Seed(e)}}])}(),fr=r(8287).Buffer;function pr(e){return pr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},pr(e)}function dr(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,hr(n.key),n)}}function hr(e){var t=function(e,t){if("object"!=pr(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=pr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==pr(t)?t:t+""}var yr=function(){function e(t,r){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),!/^[a-zA-Z0-9]{1,12}$/.test(t))throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");if("xlm"!==String(t).toLowerCase()&&!r)throw new Error("Issuer cannot be null");if(r&&!tr.isValidEd25519PublicKey(r))throw new Error("Issuer is invalid");"xlm"===String(t).toLowerCase()?this.code="XLM":this.code=t,this.issuer=r}return function(e,t,r){return t&&dr(e.prototype,t),r&&dr(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(e,[{key:"toXDRObject",value:function(){return this._toXDRObject(i.Asset)}},{key:"toChangeTrustXDRObject",value:function(){return this._toXDRObject(i.ChangeTrustAsset)}},{key:"toTrustLineXDRObject",value:function(){return this._toXDRObject(i.TrustLineAsset)}},{key:"contractId",value:function(e){var t=u(fr.from(e)),r=i.HashIdPreimage.envelopeTypeContractId(new i.HashIdPreimageContractId({networkId:t,contractIdPreimage:i.ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject())}));return tr.encodeContract(u(r.toXDR()))}},{key:"_toXDRObject",value:function(){var e,t,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:i.Asset;if(this.isNative())return r.assetTypeNative();this.code.length<=4?(e=i.AlphaNum4,t="assetTypeCreditAlphanum4"):(e=i.AlphaNum12,t="assetTypeCreditAlphanum12");var n=this.code.length<=4?4:12;return new r(t,new e({assetCode:this.code.padEnd(n,"\0"),issuer:lr.fromPublicKey(this.issuer).xdrAccountId()}))}},{key:"getCode",value:function(){if(void 0!==this.code)return String(this.code)}},{key:"getIssuer",value:function(){if(void 0!==this.issuer)return String(this.issuer)}},{key:"getAssetType",value:function(){switch(this.getRawAssetType().value){case i.AssetType.assetTypeNative().value:return"native";case i.AssetType.assetTypeCreditAlphanum4().value:return"credit_alphanum4";case i.AssetType.assetTypeCreditAlphanum12().value:return"credit_alphanum12";default:return"unknown"}}},{key:"getRawAssetType",value:function(){return this.isNative()?i.AssetType.assetTypeNative():this.code.length<=4?i.AssetType.assetTypeCreditAlphanum4():i.AssetType.assetTypeCreditAlphanum12()}},{key:"isNative",value:function(){return!this.issuer}},{key:"equals",value:function(e){return this.code===e.getCode()&&this.issuer===e.getIssuer()}},{key:"toString",value:function(){return this.isNative()?"native":"".concat(this.getCode(),":").concat(this.getIssuer())}}],[{key:"native",value:function(){return new e("XLM")}},{key:"fromOperation",value:function(e){var t,r;switch(e.switch()){case i.AssetType.assetTypeNative():return this.native();case i.AssetType.assetTypeCreditAlphanum4():t=e.alphaNum4();case i.AssetType.assetTypeCreditAlphanum12():return t=t||e.alphaNum12(),r=tr.encodeEd25519PublicKey(t.issuer().ed25519()),new this(Ht(t.assetCode(),"\0"),r);default:throw new Error("Invalid asset type: ".concat(e.switch().name))}}},{key:"compare",value:function(t,r){if(!(t&&t instanceof e))throw new Error("assetA is invalid");if(!(r&&r instanceof e))throw new Error("assetB is invalid");if(t.equals(r))return 0;var n=t.getRawAssetType().value,o=r.getRawAssetType().value;if(n!==o)return n<o?-1:1;var i=mr(t.getCode(),r.getCode());return 0!==i?i:mr(t.getIssuer(),r.getIssuer())}}])}();function mr(e,t){return fr.compare(fr.from(e,"ascii"),fr.from(t,"ascii"))}var gr=r(8287).Buffer,vr=30;function br(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("constant_product"!==e)throw new Error("liquidityPoolType is invalid");var r=t.assetA,n=t.assetB,o=t.fee;if(!(r&&r instanceof yr))throw new Error("assetA is invalid");if(!(n&&n instanceof yr))throw new Error("assetB is invalid");if(!o||o!==vr)throw new Error("fee is invalid");if(-1!==yr.compare(r,n))throw new Error("Assets are not in lexicographic order");var a=i.LiquidityPoolType.liquidityPoolConstantProduct().toXDR(),s=new i.LiquidityPoolConstantProductParameters({assetA:r.toXDRObject(),assetB:n.toXDRObject(),fee:o}).toXDR();return u(gr.concat([a,s]))}var wr=r(8287).Buffer;function Sr(e){return Sr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Sr(e)}function Er(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,kr(n.key),n)}}function kr(e){var t=function(e,t){if("object"!=Sr(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Sr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Sr(t)?t:t+""}var Ar=function(){return function(e,t,r){return t&&Er(e.prototype,t),r&&Er(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t,r,n,o){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),"string"!=typeof o)throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(Sr(o)));this._networkPassphrase=o,this._tx=t,this._signatures=r,this._fee=n},[{key:"signatures",get:function(){return this._signatures},set:function(e){throw new Error("Transaction is immutable")}},{key:"tx",get:function(){return this._tx},set:function(e){throw new Error("Transaction is immutable")}},{key:"fee",get:function(){return this._fee},set:function(e){throw new Error("Transaction is immutable")}},{key:"networkPassphrase",get:function(){return this._networkPassphrase},set:function(e){this._networkPassphrase=e}},{key:"sign",value:function(){for(var e=this,t=this.hash(),r=arguments.length,n=new Array(r),o=0;o<r;o++)n[o]=arguments[o];n.forEach(function(r){var n=r.signDecorated(t);e.signatures.push(n)})}},{key:"getKeypairSignature",value:function(e){return e.sign(this.hash()).toString("base64")}},{key:"addSignature",value:function(){var e,t,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if(!n||"string"!=typeof n)throw new Error("Invalid signature");if(!r||"string"!=typeof r)throw new Error("Invalid publicKey");var o=wr.from(n,"base64");try{t=(e=lr.fromPublicKey(r)).signatureHint()}catch(e){throw new Error("Invalid publicKey")}if(!e.verify(this.hash(),o))throw new Error("Invalid signature");this.signatures.push(new i.DecoratedSignature({hint:t,signature:o}))}},{key:"addDecoratedSignature",value:function(e){this.signatures.push(e)}},{key:"signHashX",value:function(e){if("string"==typeof e&&(e=wr.from(e,"hex")),e.length>64)throw new Error("preimage cannnot be longer than 64 bytes");var t=e,r=u(e),n=r.slice(r.length-4);this.signatures.push(new i.DecoratedSignature({hint:n,signature:t}))}},{key:"hash",value:function(){return u(this.signatureBase())}},{key:"signatureBase",value:function(){throw new Error("Implement in subclass")}},{key:"toEnvelope",value:function(){throw new Error("Implement in subclass")}},{key:"toXDR",value:function(){return this.toEnvelope().toXDR().toString("base64")}}])}(),Tr=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,Or=Math.ceil,xr=Math.floor,Pr="[BigNumber Error] ",Br=Pr+"Number primitive has more than 15 significant digits: ",Ir=1e14,Cr=14,Rr=9007199254740991,_r=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],Ur=1e7,Nr=1e9;function Lr(e){var t=0|e;return e>0||e===t?t:t-1}function Fr(e){for(var t,r,n=1,o=e.length,i=e[0]+"";n<o;){for(t=e[n++]+"",r=Cr-t.length;r--;t="0"+t);i+=t}for(o=i.length;48===i.charCodeAt(--o););return i.slice(0,o+1||1)}function jr(e,t){var r,n,o=e.c,i=t.c,a=e.s,s=t.s,u=e.e,c=t.e;if(!a||!s)return null;if(r=o&&!o[0],n=i&&!i[0],r||n)return r?n?0:-s:a;if(a!=s)return a;if(r=a<0,n=u==c,!o||!i)return n?0:!o^r?1:-1;if(!n)return u>c^r?1:-1;for(s=(u=o.length)<(c=i.length)?u:c,a=0;a<s;a++)if(o[a]!=i[a])return o[a]>i[a]^r?1:-1;return u==c?0:u>c^r?1:-1}function Mr(e,t,r,n){if(e<t||e>r||e!==xr(e))throw Error(Pr+(n||"Argument")+("number"==typeof e?e<t||e>r?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function Dr(e){var t=e.c.length-1;return Lr(e.e/Cr)==t&&e.c[t]%2!=0}function Vr(e,t){return(e.length>1?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function qr(e,t,r){var n,o;if(t<0){for(o=r+".";++t;o+=r);e=o+e}else if(++t>(n=e.length)){for(o=r,t-=n;--t;o+=r);e+=o}else t<n&&(e=e.slice(0,t)+"."+e.slice(t));return e}var Kr=function e(t){var r,n,o,i,a,s,u,c,l,f,p=O.prototype={constructor:O,toString:null,valueOf:null},d=new O(1),h=20,y=4,m=-7,g=21,v=-1e7,b=1e7,w=!1,S=1,E=0,k={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:"\xa0",suffix:""},A="0123456789abcdefghijklmnopqrstuvwxyz",T=!0;function O(e,t){var r,i,a,s,u,c,l,f,p=this;if(!(p instanceof O))return new O(e,t);if(null==t){if(e&&!0===e._isBigNumber)return p.s=e.s,void(!e.c||e.e>b?p.c=p.e=null:e.e<v?p.c=[p.e=0]:(p.e=e.e,p.c=e.c.slice()));if((c="number"==typeof e)&&0*e==0){if(p.s=1/e<0?(e=-e,-1):1,e===~~e){for(s=0,u=e;u>=10;u/=10,s++);return void(s>b?p.c=p.e=null:(p.e=s,p.c=[e]))}f=String(e)}else{if(!Tr.test(f=String(e)))return o(p,f,c);p.s=45==f.charCodeAt(0)?(f=f.slice(1),-1):1}(s=f.indexOf("."))>-1&&(f=f.replace(".","")),(u=f.search(/e/i))>0?(s<0&&(s=u),s+=+f.slice(u+1),f=f.substring(0,u)):s<0&&(s=f.length)}else{if(Mr(t,2,A.length,"Base"),10==t&&T)return I(p=new O(e),h+p.e+1,y);if(f=String(e),c="number"==typeof e){if(0*e!=0)return o(p,f,c,t);if(p.s=1/e<0?(f=f.slice(1),-1):1,O.DEBUG&&f.replace(/^0\.0*|\./,"").length>15)throw Error(Br+e)}else p.s=45===f.charCodeAt(0)?(f=f.slice(1),-1):1;for(r=A.slice(0,t),s=u=0,l=f.length;u<l;u++)if(r.indexOf(i=f.charAt(u))<0){if("."==i){if(u>s){s=l;continue}}else if(!a&&(f==f.toUpperCase()&&(f=f.toLowerCase())||f==f.toLowerCase()&&(f=f.toUpperCase()))){a=!0,u=-1,s=0;continue}return o(p,String(e),c,t)}c=!1,(s=(f=n(f,t,10,p.s)).indexOf("."))>-1?f=f.replace(".",""):s=f.length}for(u=0;48===f.charCodeAt(u);u++);for(l=f.length;48===f.charCodeAt(--l););if(f=f.slice(u,++l)){if(l-=u,c&&O.DEBUG&&l>15&&(e>Rr||e!==xr(e)))throw Error(Br+p.s*e);if((s=s-u-1)>b)p.c=p.e=null;else if(s<v)p.c=[p.e=0];else{if(p.e=s,p.c=[],u=(s+1)%Cr,s<0&&(u+=Cr),u<l){for(u&&p.c.push(+f.slice(0,u)),l-=Cr;u<l;)p.c.push(+f.slice(u,u+=Cr));u=Cr-(f=f.slice(u)).length}else u-=l;for(;u--;f+="0");p.c.push(+f)}}else p.c=[p.e=0]}function x(e,t,r,n){var o,i,a,s,u;if(null==r?r=y:Mr(r,0,8),!e.c)return e.toString();if(o=e.c[0],a=e.e,null==t)u=Fr(e.c),u=1==n||2==n&&(a<=m||a>=g)?Vr(u,a):qr(u,a,"0");else if(i=(e=I(new O(e),t,r)).e,s=(u=Fr(e.c)).length,1==n||2==n&&(t<=i||i<=m)){for(;s<t;u+="0",s++);u=Vr(u,i)}else if(t-=a+(2===n&&i>a),u=qr(u,i,"0"),i+1>s){if(--t>0)for(u+=".";t--;u+="0");}else if((t+=i-s)>0)for(i+1==s&&(u+=".");t--;u+="0");return e.s<0&&o?"-"+u:u}function P(e,t){for(var r,n,o=1,i=new O(e[0]);o<e.length;o++)(!(n=new O(e[o])).s||(r=jr(i,n))===t||0===r&&i.s===t)&&(i=n);return i}function B(e,t,r){for(var n=1,o=t.length;!t[--o];t.pop());for(o=t[0];o>=10;o/=10,n++);return(r=n+r*Cr-1)>b?e.c=e.e=null:r<v?e.c=[e.e=0]:(e.e=r,e.c=t),e}function I(e,t,r,n){var o,i,a,s,u,c,l,f=e.c,p=_r;if(f){e:{for(o=1,s=f[0];s>=10;s/=10,o++);if((i=t-o)<0)i+=Cr,a=t,u=f[c=0],l=xr(u/p[o-a-1]%10);else if((c=Or((i+1)/Cr))>=f.length){if(!n)break e;for(;f.length<=c;f.push(0));u=l=0,o=1,a=(i%=Cr)-Cr+1}else{for(u=s=f[c],o=1;s>=10;s/=10,o++);l=(a=(i%=Cr)-Cr+o)<0?0:xr(u/p[o-a-1]%10)}if(n=n||t<0||null!=f[c+1]||(a<0?u:u%p[o-a-1]),n=r<4?(l||n)&&(0==r||r==(e.s<0?3:2)):l>5||5==l&&(4==r||n||6==r&&(i>0?a>0?u/p[o-a]:0:f[c-1])%10&1||r==(e.s<0?8:7)),t<1||!f[0])return f.length=0,n?(t-=e.e+1,f[0]=p[(Cr-t%Cr)%Cr],e.e=-t||0):f[0]=e.e=0,e;if(0==i?(f.length=c,s=1,c--):(f.length=c+1,s=p[Cr-i],f[c]=a>0?xr(u/p[o-a]%p[a])*s:0),n)for(;;){if(0==c){for(i=1,a=f[0];a>=10;a/=10,i++);for(a=f[0]+=s,s=1;a>=10;a/=10,s++);i!=s&&(e.e++,f[0]==Ir&&(f[0]=1));break}if(f[c]+=s,f[c]!=Ir)break;f[c--]=0,s=1}for(i=f.length;0===f[--i];f.pop());}e.e>b?e.c=e.e=null:e.e<v&&(e.c=[e.e=0])}return e}function C(e){var t,r=e.e;return null===r?e.toString():(t=Fr(e.c),t=r<=m||r>=g?Vr(t,r):qr(t,r,"0"),e.s<0?"-"+t:t)}return O.clone=e,O.ROUND_UP=0,O.ROUND_DOWN=1,O.ROUND_CEIL=2,O.ROUND_FLOOR=3,O.ROUND_HALF_UP=4,O.ROUND_HALF_DOWN=5,O.ROUND_HALF_EVEN=6,O.ROUND_HALF_CEIL=7,O.ROUND_HALF_FLOOR=8,O.EUCLID=9,O.config=O.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(Pr+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(Mr(r=e[t],0,Nr,t),h=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(Mr(r=e[t],0,8,t),y=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((r=e[t])&&r.pop?(Mr(r[0],-Nr,0,t),Mr(r[1],0,Nr,t),m=r[0],g=r[1]):(Mr(r,-Nr,Nr,t),m=-(g=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if((r=e[t])&&r.pop)Mr(r[0],-Nr,-1,t),Mr(r[1],1,Nr,t),v=r[0],b=r[1];else{if(Mr(r,-Nr,Nr,t),!r)throw Error(Pr+t+" cannot be zero: "+r);v=-(b=r<0?-r:r)}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(Pr+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw w=!r,Error(Pr+"crypto unavailable");w=r}else w=r}if(e.hasOwnProperty(t="MODULO_MODE")&&(Mr(r=e[t],0,9,t),S=r),e.hasOwnProperty(t="POW_PRECISION")&&(Mr(r=e[t],0,Nr,t),E=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(Pr+t+" not an object: "+r);k=r}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.?$|[+\-.\s]|(.).*\1/.test(r))throw Error(Pr+t+" invalid: "+r);T="0123456789"==r.slice(0,10),A=r}}return{DECIMAL_PLACES:h,ROUNDING_MODE:y,EXPONENTIAL_AT:[m,g],RANGE:[v,b],CRYPTO:w,MODULO_MODE:S,POW_PRECISION:E,FORMAT:k,ALPHABET:A}},O.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!O.DEBUG)return!0;var t,r,n=e.c,o=e.e,i=e.s;e:if("[object Array]"=={}.toString.call(n)){if((1===i||-1===i)&&o>=-Nr&&o<=Nr&&o===xr(o)){if(0===n[0]){if(0===o&&1===n.length)return!0;break e}if((t=(o+1)%Cr)<1&&(t+=Cr),String(n[0]).length==t){for(t=0;t<n.length;t++)if((r=n[t])<0||r>=Ir||r!==xr(r))break e;if(0!==r)return!0}}}else if(null===n&&null===o&&(null===i||1===i||-1===i))return!0;throw Error(Pr+"Invalid BigNumber: "+e)},O.maximum=O.max=function(){return P(arguments,-1)},O.minimum=O.min=function(){return P(arguments,1)},O.random=(i=9007199254740992,a=Math.random()*i&2097151?function(){return xr(Math.random()*i)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,r,n,o,i,s=0,u=[],c=new O(d);if(null==e?e=h:Mr(e,0,Nr),o=Or(e/Cr),w)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(o*=2));s<o;)(i=131072*t[s]+(t[s+1]>>>11))>=9e15?(r=crypto.getRandomValues(new Uint32Array(2)),t[s]=r[0],t[s+1]=r[1]):(u.push(i%1e14),s+=2);s=o/2}else{if(!crypto.randomBytes)throw w=!1,Error(Pr+"crypto unavailable");for(t=crypto.randomBytes(o*=7);s<o;)(i=281474976710656*(31&t[s])+1099511627776*t[s+1]+4294967296*t[s+2]+16777216*t[s+3]+(t[s+4]<<16)+(t[s+5]<<8)+t[s+6])>=9e15?crypto.randomBytes(7).copy(t,s):(u.push(i%1e14),s+=7);s=o/7}if(!w)for(;s<o;)(i=a())<9e15&&(u[s++]=i%1e14);for(o=u[--s],e%=Cr,o&&e&&(i=_r[Cr-e],u[s]=xr(o/i)*i);0===u[s];u.pop(),s--);if(s<0)u=[n=0];else{for(n=-1;0===u[0];u.splice(0,1),n-=Cr);for(s=1,i=u[0];i>=10;i/=10,s++);s<Cr&&(n-=Cr-s)}return c.e=n,c.c=u,c}),O.sum=function(){for(var e=1,t=arguments,r=new O(t[0]);e<t.length;)r=r.plus(t[e++]);return r},n=function(){var e="0123456789";function t(e,t,r,n){for(var o,i,a=[0],s=0,u=e.length;s<u;){for(i=a.length;i--;a[i]*=t);for(a[0]+=n.indexOf(e.charAt(s++)),o=0;o<a.length;o++)a[o]>r-1&&(null==a[o+1]&&(a[o+1]=0),a[o+1]+=a[o]/r|0,a[o]%=r)}return a.reverse()}return function(n,o,i,a,s){var u,c,l,f,p,d,m,g,v=n.indexOf("."),b=h,w=y;for(v>=0&&(f=E,E=0,n=n.replace(".",""),d=(g=new O(o)).pow(n.length-v),E=f,g.c=t(qr(Fr(d.c),d.e,"0"),10,i,e),g.e=g.c.length),l=f=(m=t(n,o,i,s?(u=A,e):(u=e,A))).length;0==m[--f];m.pop());if(!m[0])return u.charAt(0);if(v<0?--l:(d.c=m,d.e=l,d.s=a,m=(d=r(d,g,b,w,i)).c,p=d.r,l=d.e),v=m[c=l+b+1],f=i/2,p=p||c<0||null!=m[c+1],p=w<4?(null!=v||p)&&(0==w||w==(d.s<0?3:2)):v>f||v==f&&(4==w||p||6==w&&1&m[c-1]||w==(d.s<0?8:7)),c<1||!m[0])n=p?qr(u.charAt(1),-b,u.charAt(0)):u.charAt(0);else{if(m.length=c,p)for(--i;++m[--c]>i;)m[c]=0,c||(++l,m=[1].concat(m));for(f=m.length;!m[--f];);for(v=0,n="";v<=f;n+=u.charAt(m[v++]));n=qr(n,l,u.charAt(0))}return n}}(),r=function(){function e(e,t,r){var n,o,i,a,s=0,u=e.length,c=t%Ur,l=t/Ur|0;for(e=e.slice();u--;)s=((o=c*(i=e[u]%Ur)+(n=l*i+(a=e[u]/Ur|0)*c)%Ur*Ur+s)/r|0)+(n/Ur|0)+l*a,e[u]=o%r;return s&&(e=[s].concat(e)),e}function t(e,t,r,n){var o,i;if(r!=n)i=r>n?1:-1;else for(o=i=0;o<r;o++)if(e[o]!=t[o]){i=e[o]>t[o]?1:-1;break}return i}function r(e,t,r,n){for(var o=0;r--;)e[r]-=o,o=e[r]<t[r]?1:0,e[r]=o*n+e[r]-t[r];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(n,o,i,a,s){var u,c,l,f,p,d,h,y,m,g,v,b,w,S,E,k,A,T=n.s==o.s?1:-1,x=n.c,P=o.c;if(!(x&&x[0]&&P&&P[0]))return new O(n.s&&o.s&&(x?!P||x[0]!=P[0]:P)?x&&0==x[0]||!P?0*T:T/0:NaN);for(m=(y=new O(T)).c=[],T=i+(c=n.e-o.e)+1,s||(s=Ir,c=Lr(n.e/Cr)-Lr(o.e/Cr),T=T/Cr|0),l=0;P[l]==(x[l]||0);l++);if(P[l]>(x[l]||0)&&c--,T<0)m.push(1),f=!0;else{for(S=x.length,k=P.length,l=0,T+=2,(p=xr(s/(P[0]+1)))>1&&(P=e(P,p,s),x=e(x,p,s),k=P.length,S=x.length),w=k,v=(g=x.slice(0,k)).length;v<k;g[v++]=0);A=P.slice(),A=[0].concat(A),E=P[0],P[1]>=s/2&&E++;do{if(p=0,(u=t(P,g,k,v))<0){if(b=g[0],k!=v&&(b=b*s+(g[1]||0)),(p=xr(b/E))>1)for(p>=s&&(p=s-1),h=(d=e(P,p,s)).length,v=g.length;1==t(d,g,h,v);)p--,r(d,k<h?A:P,h,s),h=d.length,u=1;else 0==p&&(u=p=1),h=(d=P.slice()).length;if(h<v&&(d=[0].concat(d)),r(g,d,v,s),v=g.length,-1==u)for(;t(P,g,k,v)<1;)p++,r(g,k<v?A:P,v,s),v=g.length}else 0===u&&(p++,g=[0]);m[l++]=p,g[0]?g[v++]=x[w]||0:(g=[x[w]],v=1)}while((w++<S||null!=g[0])&&T--);f=null!=g[0],m[0]||m.splice(0,1)}if(s==Ir){for(l=1,T=m[0];T>=10;T/=10,l++);I(y,i+(y.e=l+c*Cr-1)+1,a,f)}else y.e=c,y.r=+f;return y}}(),s=/^(-?)0([xbo])(?=\w[\w.]*$)/i,u=/^([^.]+)\.$/,c=/^\.([^.]+)$/,l=/^-?(Infinity|NaN)$/,f=/^\s*\+(?=[\w.])|^\s+|\s+$/g,o=function(e,t,r,n){var o,i=r?t:t.replace(f,"");if(l.test(i))e.s=isNaN(i)?null:i<0?-1:1;else{if(!r&&(i=i.replace(s,function(e,t,r){return o="x"==(r=r.toLowerCase())?16:"b"==r?2:8,n&&n!=o?e:t}),n&&(o=n,i=i.replace(u,"$1").replace(c,"0.$1")),t!=i))return new O(i,o);if(O.DEBUG)throw Error(Pr+"Not a"+(n?" base "+n:"")+" number: "+t);e.s=null}e.c=e.e=null},p.absoluteValue=p.abs=function(){var e=new O(this);return e.s<0&&(e.s=1),e},p.comparedTo=function(e,t){return jr(this,new O(e,t))},p.decimalPlaces=p.dp=function(e,t){var r,n,o,i=this;if(null!=e)return Mr(e,0,Nr),null==t?t=y:Mr(t,0,8),I(new O(i),e+i.e+1,t);if(!(r=i.c))return null;if(n=((o=r.length-1)-Lr(this.e/Cr))*Cr,o=r[o])for(;o%10==0;o/=10,n--);return n<0&&(n=0),n},p.dividedBy=p.div=function(e,t){return r(this,new O(e,t),h,y)},p.dividedToIntegerBy=p.idiv=function(e,t){return r(this,new O(e,t),0,1)},p.exponentiatedBy=p.pow=function(e,t){var r,n,o,i,a,s,u,c,l=this;if((e=new O(e)).c&&!e.isInteger())throw Error(Pr+"Exponent not an integer: "+C(e));if(null!=t&&(t=new O(t)),a=e.e>14,!l.c||!l.c[0]||1==l.c[0]&&!l.e&&1==l.c.length||!e.c||!e.c[0])return c=new O(Math.pow(+C(l),a?e.s*(2-Dr(e)):+C(e))),t?c.mod(t):c;if(s=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new O(NaN);(n=!s&&l.isInteger()&&t.isInteger())&&(l=l.mod(t))}else{if(e.e>9&&(l.e>0||l.e<-1||(0==l.e?l.c[0]>1||a&&l.c[1]>=24e7:l.c[0]<8e13||a&&l.c[0]<=9999975e7)))return i=l.s<0&&Dr(e)?-0:0,l.e>-1&&(i=1/i),new O(s?1/i:i);E&&(i=Or(E/Cr+2))}for(a?(r=new O(.5),s&&(e.s=1),u=Dr(e)):u=(o=Math.abs(+C(e)))%2,c=new O(d);;){if(u){if(!(c=c.times(l)).c)break;i?c.c.length>i&&(c.c.length=i):n&&(c=c.mod(t))}if(o){if(0===(o=xr(o/2)))break;u=o%2}else if(I(e=e.times(r),e.e+1,1),e.e>14)u=Dr(e);else{if(0===(o=+C(e)))break;u=o%2}l=l.times(l),i?l.c&&l.c.length>i&&(l.c.length=i):n&&(l=l.mod(t))}return n?c:(s&&(c=d.div(c)),t?c.mod(t):i?I(c,E,y,undefined):c)},p.integerValue=function(e){var t=new O(this);return null==e?e=y:Mr(e,0,8),I(t,t.e+1,e)},p.isEqualTo=p.eq=function(e,t){return 0===jr(this,new O(e,t))},p.isFinite=function(){return!!this.c},p.isGreaterThan=p.gt=function(e,t){return jr(this,new O(e,t))>0},p.isGreaterThanOrEqualTo=p.gte=function(e,t){return 1===(t=jr(this,new O(e,t)))||0===t},p.isInteger=function(){return!!this.c&&Lr(this.e/Cr)>this.c.length-2},p.isLessThan=p.lt=function(e,t){return jr(this,new O(e,t))<0},p.isLessThanOrEqualTo=p.lte=function(e,t){return-1===(t=jr(this,new O(e,t)))||0===t},p.isNaN=function(){return!this.s},p.isNegative=function(){return this.s<0},p.isPositive=function(){return this.s>0},p.isZero=function(){return!!this.c&&0==this.c[0]},p.minus=function(e,t){var r,n,o,i,a=this,s=a.s;if(t=(e=new O(e,t)).s,!s||!t)return new O(NaN);if(s!=t)return e.s=-t,a.plus(e);var u=a.e/Cr,c=e.e/Cr,l=a.c,f=e.c;if(!u||!c){if(!l||!f)return l?(e.s=-t,e):new O(f?a:NaN);if(!l[0]||!f[0])return f[0]?(e.s=-t,e):new O(l[0]?a:3==y?-0:0)}if(u=Lr(u),c=Lr(c),l=l.slice(),s=u-c){for((i=s<0)?(s=-s,o=l):(c=u,o=f),o.reverse(),t=s;t--;o.push(0));o.reverse()}else for(n=(i=(s=l.length)<(t=f.length))?s:t,s=t=0;t<n;t++)if(l[t]!=f[t]){i=l[t]<f[t];break}if(i&&(o=l,l=f,f=o,e.s=-e.s),(t=(n=f.length)-(r=l.length))>0)for(;t--;l[r++]=0);for(t=Ir-1;n>s;){if(l[--n]<f[n]){for(r=n;r&&!l[--r];l[r]=t);--l[r],l[n]+=Ir}l[n]-=f[n]}for(;0==l[0];l.splice(0,1),--c);return l[0]?B(e,l,c):(e.s=3==y?-1:1,e.c=[e.e=0],e)},p.modulo=p.mod=function(e,t){var n,o,i=this;return e=new O(e,t),!i.c||!e.s||e.c&&!e.c[0]?new O(NaN):!e.c||i.c&&!i.c[0]?new O(i):(9==S?(o=e.s,e.s=1,n=r(i,e,0,3),e.s=o,n.s*=o):n=r(i,e,0,S),(e=i.minus(n.times(e))).c[0]||1!=S||(e.s=i.s),e)},p.multipliedBy=p.times=function(e,t){var r,n,o,i,a,s,u,c,l,f,p,d,h,y,m,g=this,v=g.c,b=(e=new O(e,t)).c;if(!(v&&b&&v[0]&&b[0]))return!g.s||!e.s||v&&!v[0]&&!b||b&&!b[0]&&!v?e.c=e.e=e.s=null:(e.s*=g.s,v&&b?(e.c=[0],e.e=0):e.c=e.e=null),e;for(n=Lr(g.e/Cr)+Lr(e.e/Cr),e.s*=g.s,(u=v.length)<(f=b.length)&&(h=v,v=b,b=h,o=u,u=f,f=o),o=u+f,h=[];o--;h.push(0));for(y=Ir,m=Ur,o=f;--o>=0;){for(r=0,p=b[o]%m,d=b[o]/m|0,i=o+(a=u);i>o;)r=((c=p*(c=v[--a]%m)+(s=d*c+(l=v[a]/m|0)*p)%m*m+h[i]+r)/y|0)+(s/m|0)+d*l,h[i--]=c%y;h[i]=r}return r?++n:h.splice(0,1),B(e,h,n)},p.negated=function(){var e=new O(this);return e.s=-e.s||null,e},p.plus=function(e,t){var r,n=this,o=n.s;if(t=(e=new O(e,t)).s,!o||!t)return new O(NaN);if(o!=t)return e.s=-t,n.minus(e);var i=n.e/Cr,a=e.e/Cr,s=n.c,u=e.c;if(!i||!a){if(!s||!u)return new O(o/0);if(!s[0]||!u[0])return u[0]?e:new O(s[0]?n:0*o)}if(i=Lr(i),a=Lr(a),s=s.slice(),o=i-a){for(o>0?(a=i,r=u):(o=-o,r=s),r.reverse();o--;r.push(0));r.reverse()}for((o=s.length)-(t=u.length)<0&&(r=u,u=s,s=r,t=o),o=0;t;)o=(s[--t]=s[t]+u[t]+o)/Ir|0,s[t]=Ir===s[t]?0:s[t]%Ir;return o&&(s=[o].concat(s),++a),B(e,s,a)},p.precision=p.sd=function(e,t){var r,n,o,i=this;if(null!=e&&e!==!!e)return Mr(e,1,Nr),null==t?t=y:Mr(t,0,8),I(new O(i),e,t);if(!(r=i.c))return null;if(n=(o=r.length-1)*Cr+1,o=r[o]){for(;o%10==0;o/=10,n--);for(o=r[0];o>=10;o/=10,n++);}return e&&i.e+1>n&&(n=i.e+1),n},p.shiftedBy=function(e){return Mr(e,-9007199254740991,Rr),this.times("1e"+e)},p.squareRoot=p.sqrt=function(){var e,t,n,o,i,a=this,s=a.c,u=a.s,c=a.e,l=h+4,f=new O("0.5");if(1!==u||!s||!s[0])return new O(!u||u<0&&(!s||s[0])?NaN:s?a:1/0);if(0==(u=Math.sqrt(+C(a)))||u==1/0?(((t=Fr(s)).length+c)%2==0&&(t+="0"),u=Math.sqrt(+t),c=Lr((c+1)/2)-(c<0||c%2),n=new O(t=u==1/0?"5e"+c:(t=u.toExponential()).slice(0,t.indexOf("e")+1)+c)):n=new O(u+""),n.c[0])for((u=(c=n.e)+l)<3&&(u=0);;)if(i=n,n=f.times(i.plus(r(a,i,l,1))),Fr(i.c).slice(0,u)===(t=Fr(n.c)).slice(0,u)){if(n.e<c&&--u,"9999"!=(t=t.slice(u-3,u+1))&&(o||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(I(n,n.e+h+2,1),e=!n.times(n).eq(a));break}if(!o&&(I(i,i.e+h+2,0),i.times(i).eq(a))){n=i;break}l+=4,u+=4,o=1}return I(n,n.e+h+1,y,e)},p.toExponential=function(e,t){return null!=e&&(Mr(e,0,Nr),e++),x(this,e,t,1)},p.toFixed=function(e,t){return null!=e&&(Mr(e,0,Nr),e=e+this.e+1),x(this,e,t)},p.toFormat=function(e,t,r){var n,o=this;if(null==r)null!=e&&t&&"object"==typeof t?(r=t,t=null):e&&"object"==typeof e?(r=e,e=t=null):r=k;else if("object"!=typeof r)throw Error(Pr+"Argument not an object: "+r);if(n=o.toFixed(e,t),o.c){var i,a=n.split("."),s=+r.groupSize,u=+r.secondaryGroupSize,c=r.groupSeparator||"",l=a[0],f=a[1],p=o.s<0,d=p?l.slice(1):l,h=d.length;if(u&&(i=s,s=u,u=i,h-=i),s>0&&h>0){for(i=h%s||s,l=d.substr(0,i);i<h;i+=s)l+=c+d.substr(i,s);u>0&&(l+=c+d.slice(i)),p&&(l="-"+l)}n=f?l+(r.decimalSeparator||"")+((u=+r.fractionGroupSize)?f.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+(r.fractionGroupSeparator||"")):f):l}return(r.prefix||"")+n+(r.suffix||"")},p.toFraction=function(e){var t,n,o,i,a,s,u,c,l,f,p,h,m=this,g=m.c;if(null!=e&&(!(u=new O(e)).isInteger()&&(u.c||1!==u.s)||u.lt(d)))throw Error(Pr+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+C(u));if(!g)return new O(m);for(t=new O(d),l=n=new O(d),o=c=new O(d),h=Fr(g),a=t.e=h.length-m.e-1,t.c[0]=_r[(s=a%Cr)<0?Cr+s:s],e=!e||u.comparedTo(t)>0?a>0?t:l:u,s=b,b=1/0,u=new O(h),c.c[0]=0;f=r(u,t,0,1),1!=(i=n.plus(f.times(o))).comparedTo(e);)n=o,o=i,l=c.plus(f.times(i=l)),c=i,t=u.minus(f.times(i=t)),u=i;return i=r(e.minus(n),o,0,1),c=c.plus(i.times(l)),n=n.plus(i.times(o)),c.s=l.s=m.s,p=r(l,o,a*=2,y).minus(m).abs().comparedTo(r(c,n,a,y).minus(m).abs())<1?[l,o]:[c,n],b=s,p},p.toNumber=function(){return+C(this)},p.toPrecision=function(e,t){return null!=e&&Mr(e,1,Nr),x(this,e,t,2)},p.toString=function(e){var t,r=this,o=r.s,i=r.e;return null===i?o?(t="Infinity",o<0&&(t="-"+t)):t="NaN":(null==e?t=i<=m||i>=g?Vr(Fr(r.c),i):qr(Fr(r.c),i,"0"):10===e&&T?t=qr(Fr((r=I(new O(r),h+i+1,y)).c),r.e,"0"):(Mr(e,2,A.length,"Base"),t=n(qr(Fr(r.c),i,"0"),10,e,o,!0)),o<0&&r.c[0]&&(t="-"+t)),t},p.valueOf=p.toJSON=function(){return C(this)},p._isBigNumber=!0,p[Symbol.toStringTag]="BigNumber",p[Symbol.for("nodejs.util.inspect.custom")]=p.valueOf,null!=t&&O.set(t),O}();var Hr=Kr.clone();Hr.DEBUG=!0;const zr=Hr;function Xr(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,o,i,a,s=[],u=!0,c=!1;try{if(i=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;u=!1}else for(;!(u=(n=i.call(r)).done)&&(s.push(n.value),s.length!==t);u=!0);}catch(e){c=!0,o=e}finally{try{if(!u&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw o}}return s}}(e,t)||function(e,t){if(e){if("string"==typeof e)return $r(e,t);var r={}.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?$r(e,t):void 0}}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function $r(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n}var Gr=2147483647;function Wr(e){return Wr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Wr(e)}function Yr(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function Zr(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Yr(Object(r),!0).forEach(function(t){Jr(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Yr(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function Jr(e,t,r){return(t=en(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function Qr(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,en(n.key),n)}}function en(e){var t=function(e,t){if("object"!=Wr(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Wr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Wr(t)?t:t+""}var tn=function(){return function(e,t,r){return t&&Qr(e.prototype,t),r&&Qr(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t,r,n){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),!(t&&t instanceof yr))throw new Error("assetA is invalid");if(!(r&&r instanceof yr))throw new Error("assetB is invalid");if(-1!==yr.compare(t,r))throw new Error("Assets are not in lexicographic order");if(!n||n!==vr)throw new Error("fee is invalid");this.assetA=t,this.assetB=r,this.fee=n},[{key:"toXDRObject",value:function(){var e=new i.LiquidityPoolConstantProductParameters({assetA:this.assetA.toXDRObject(),assetB:this.assetB.toXDRObject(),fee:this.fee}),t=new i.LiquidityPoolParameters("liquidityPoolConstantProduct",e);return new i.ChangeTrustAsset("assetTypePoolShare",t)}},{key:"getLiquidityPoolParameters",value:function(){return Zr(Zr({},this),{},{assetA:this.assetA,assetB:this.assetB,fee:this.fee})}},{key:"getAssetType",value:function(){return"liquidity_pool_shares"}},{key:"equals",value:function(e){return this.assetA.equals(e.assetA)&&this.assetB.equals(e.assetB)&&this.fee===e.fee}},{key:"toString",value:function(){var e=br("constant_product",this.getLiquidityPoolParameters()).toString("hex");return"liquidity_pool:".concat(e)}}],[{key:"fromOperation",value:function(e){var t=e.switch();if(t===i.AssetType.assetTypePoolShare()){var r=e.liquidityPool().constantProduct();return new this(yr.fromOperation(r.assetA()),yr.fromOperation(r.assetB()),r.fee())}throw new Error("Invalid asset type: ".concat(t.name))}}])}();function rn(e){return rn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},rn(e)}function nn(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,on(n.key),n)}}function on(e){var t=function(e,t){if("object"!=rn(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=rn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==rn(t)?t:t+""}var an=function(){return function(e,t,r){return t&&nn(e.prototype,t),r&&nn(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t,r){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),t&&!tr.isValidEd25519PublicKey(t))throw new Error("Destination is invalid");if(this._destination=t,r){if(!(r instanceof i.ClaimPredicate))throw new Error("Predicate should be an xdr.ClaimPredicate");this._predicate=r}else this._predicate=i.ClaimPredicate.claimPredicateUnconditional()},[{key:"toXDRObject",value:function(){var e=new i.ClaimantV0({destination:lr.fromPublicKey(this._destination).xdrAccountId(),predicate:this._predicate});return i.Claimant.claimantTypeV0(e)}},{key:"destination",get:function(){return this._destination},set:function(e){throw new Error("Claimant is immutable")}},{key:"predicate",get:function(){return this._predicate},set:function(e){throw new Error("Claimant is immutable")}}],[{key:"predicateUnconditional",value:function(){return i.ClaimPredicate.claimPredicateUnconditional()}},{key:"predicateAnd",value:function(e,t){if(!(e instanceof i.ClaimPredicate))throw new Error("left Predicate should be an xdr.ClaimPredicate");if(!(t instanceof i.ClaimPredicate))throw new Error("right Predicate should be an xdr.ClaimPredicate");return i.ClaimPredicate.claimPredicateAnd([e,t])}},{key:"predicateOr",value:function(e,t){if(!(e instanceof i.ClaimPredicate))throw new Error("left Predicate should be an xdr.ClaimPredicate");if(!(t instanceof i.ClaimPredicate))throw new Error("right Predicate should be an xdr.ClaimPredicate");return i.ClaimPredicate.claimPredicateOr([e,t])}},{key:"predicateNot",value:function(e){if(!(e instanceof i.ClaimPredicate))throw new Error("right Predicate should be an xdr.ClaimPredicate");return i.ClaimPredicate.claimPredicateNot(e)}},{key:"predicateBeforeAbsoluteTime",value:function(e){return i.ClaimPredicate.claimPredicateBeforeAbsoluteTime(i.Int64.fromString(e))}},{key:"predicateBeforeRelativeTime",value:function(e){return i.ClaimPredicate.claimPredicateBeforeRelativeTime(i.Int64.fromString(e))}},{key:"fromXDR",value:function(e){var t;if(e.switch()===i.ClaimantType.claimantTypeV0())return t=e.v0(),new this(tr.encodeEd25519PublicKey(t.destination().ed25519()),t.predicate());throw new Error("Invalid claimant type: ".concat(e.switch().name))}}])}();function sn(e){return sn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},sn(e)}function un(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,cn(n.key),n)}}function cn(e){var t=function(e,t){if("object"!=sn(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=sn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==sn(t)?t:t+""}var ln=function(){return function(e,t,r){return t&&un(e.prototype,t),r&&un(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),!t)throw new Error("liquidityPoolId cannot be empty");if(!/^[a-f0-9]{64}$/.test(t))throw new Error("Liquidity pool ID is not a valid hash");this.liquidityPoolId=t},[{key:"toXDRObject",value:function(){var e=i.PoolId.fromXDR(this.liquidityPoolId,"hex");return new i.TrustLineAsset("assetTypePoolShare",e)}},{key:"getLiquidityPoolId",value:function(){return String(this.liquidityPoolId)}},{key:"getAssetType",value:function(){return"liquidity_pool_shares"}},{key:"equals",value:function(e){return this.liquidityPoolId===e.getLiquidityPoolId()}},{key:"toString",value:function(){return"liquidity_pool:".concat(this.liquidityPoolId)}}],[{key:"fromOperation",value:function(e){var t=e.switch();if(t===i.AssetType.assetTypePoolShare())return new this(e.liquidityPoolId().toString("hex"));throw new Error("Invalid asset type: ".concat(t.name))}}])}();var fn=r(8287).Buffer;function pn(e){return tr.isValidMed25519PublicKey(e)?function(e){var t=tr.decodeMed25519PublicKey(e);return i.MuxedAccount.keyTypeMuxedEd25519(new i.MuxedAccountMed25519({id:i.Uint64.fromXDR(t.subarray(-8)),ed25519:t.subarray(0,-8)}))}(e):i.MuxedAccount.keyTypeEd25519(tr.decodeEd25519PublicKey(e))}function dn(e){return e.switch().value===i.CryptoKeyType.keyTypeMuxedEd25519().value?function(e){if(e.switch()===i.CryptoKeyType.keyTypeEd25519())return dn(e);var t=e.med25519();return tr.encodeMed25519PublicKey(fn.concat([t.ed25519(),t.id().toXDR("raw")]))}(e):tr.encodeEd25519PublicKey(e.ed25519())}function hn(e,t){if(!tr.isValidEd25519PublicKey(e))throw new Error("address should be a Stellar account ID (G...)");if("string"!=typeof t)throw new Error("id should be a string representing a number (uint64)");return i.MuxedAccount.keyTypeMuxedEd25519(new i.MuxedAccountMed25519({id:i.Uint64.fromString(t),ed25519:tr.decodeEd25519PublicKey(e)}))}function yn(e){if(tr.isValidEd25519PublicKey(e))return e;if(!tr.isValidMed25519PublicKey(e))throw new TypeError("expected muxed account (M...), got ".concat(e));var t=pn(e);return tr.encodeEd25519PublicKey(t.med25519().ed25519())}function mn(e){if("string"!=typeof e||72!==e.length)throw new Error("must provide a valid claimable balance id")}var gn=r(8287).Buffer;var vn=r(8287).Buffer;function bn(e,t){if(e>=0&&e<=255)return!0;throw new Error("".concat(t," value must be between 0 and 255"))}var wn=r(8287).Buffer;function Sn(e){return Sn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Sn(e)}var En=r(8287).Buffer;function kn(e){return kn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},kn(e)}function An(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Tn(n.key),n)}}function Tn(e){var t=function(e,t){if("object"!=kn(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=kn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==kn(t)?t:t+""}var On=function(){function e(t){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),tr.isValidEd25519PublicKey(t))this._type="account",this._key=tr.decodeEd25519PublicKey(t);else if(tr.isValidContract(t))this._type="contract",this._key=tr.decodeContract(t);else if(tr.isValidMed25519PublicKey(t))this._type="muxedAccount",this._key=tr.decodeMed25519PublicKey(t);else if(tr.isValidClaimableBalance(t))this._type="claimableBalance",this._key=tr.decodeClaimableBalance(t);else{if(!tr.isValidLiquidityPool(t))throw new Error("Unsupported address type: ".concat(t));this._type="liquidityPool",this._key=tr.decodeLiquidityPool(t)}}return function(e,t,r){return t&&An(e.prototype,t),r&&An(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(e,[{key:"toString",value:function(){switch(this._type){case"account":return tr.encodeEd25519PublicKey(this._key);case"contract":return tr.encodeContract(this._key);case"claimableBalance":return tr.encodeClaimableBalance(this._key);case"liquidityPool":return tr.encodeLiquidityPool(this._key);case"muxedAccount":return tr.encodeMed25519PublicKey(this._key);default:throw new Error("Unsupported address type")}}},{key:"toScVal",value:function(){return i.ScVal.scvAddress(this.toScAddress())}},{key:"toScAddress",value:function(){switch(this._type){case"account":return i.ScAddress.scAddressTypeAccount(i.PublicKey.publicKeyTypeEd25519(this._key));case"contract":return i.ScAddress.scAddressTypeContract(this._key);case"liquidityPool":return i.ScAddress.scAddressTypeLiquidityPool(this._key);case"claimableBalance":return i.ScAddress.scAddressTypeClaimableBalance(new i.ClaimableBalanceId("claimableBalanceIdTypeV".concat(this._key.at(0)),this._key.subarray(1)));case"muxedAccount":return i.ScAddress.scAddressTypeMuxedAccount(new i.MuxedEd25519Account({ed25519:this._key.subarray(0,32),id:i.Uint64.fromXDR(this._key.subarray(32,40),"raw")}));default:throw new Error("Unsupported address type: ".concat(this._type))}}},{key:"toBuffer",value:function(){return this._key}}],[{key:"fromString",value:function(t){return new e(t)}},{key:"account",value:function(t){return new e(tr.encodeEd25519PublicKey(t))}},{key:"contract",value:function(t){return new e(tr.encodeContract(t))}},{key:"claimableBalance",value:function(t){return new e(tr.encodeClaimableBalance(t))}},{key:"liquidityPool",value:function(t){return new e(tr.encodeLiquidityPool(t))}},{key:"muxedAccount",value:function(t){return new e(tr.encodeMed25519PublicKey(t))}},{key:"fromScVal",value:function(t){return e.fromScAddress(t.address())}},{key:"fromScAddress",value:function(t){switch(t.switch().value){case i.ScAddressType.scAddressTypeAccount().value:return e.account(t.accountId().ed25519());case i.ScAddressType.scAddressTypeContract().value:return e.contract(t.contractId());case i.ScAddressType.scAddressTypeMuxedAccount().value:var r=En.concat([t.muxedAccount().ed25519(),t.muxedAccount().id().toXDR("raw")]);return e.muxedAccount(r);case i.ScAddressType.scAddressTypeClaimableBalance().value:return e.claimableBalance(t.claimableBalanceId());case i.ScAddressType.scAddressTypeLiquidityPool().value:return e.liquidityPool(t.liquidityPoolId());default:throw new Error("Unsupported address type: ".concat(t.switch().name))}}}])}(),xn=r(8287).Buffer;function Pn(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,o,i,a,s=[],u=!0,c=!1;try{if(i=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;u=!1}else for(;!(u=(n=i.call(r)).done)&&(s.push(n.value),s.length!==t);u=!0);}catch(e){c=!0,o=e}finally{try{if(!u&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw o}}return s}}(e,t)||function(e,t){if(e){if("string"==typeof e)return Bn(e,t);var r={}.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Bn(e,t):void 0}}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Bn(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n}function In(e){return In="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},In(e)}function Cn(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Rn(n.key),n)}}function Rn(e){var t=function(e,t){if("object"!=In(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=In(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==In(t)?t:t+""}var _n=1e7,Un=1,Nn=2,Ln=4,Fn=8,jn=function(){return function(e,t,r){return t&&Cn(e.prototype,t),r&&Cn(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)},null,[{key:"setSourceAccount",value:function(e,t){if(t.source)try{e.sourceAccount=pn(t.source)}catch(e){throw new Error("Source address is invalid")}}},{key:"fromXDRObject",value:function(e){var t={};e.sourceAccount()&&(t.source=dn(e.sourceAccount()));var r=e.body().value(),n=e.body().switch().name;switch(n){case"createAccount":t.type="createAccount",t.destination=Mn(r.destination()),t.startingBalance=this._fromXDRAmount(r.startingBalance());break;case"payment":t.type="payment",t.destination=dn(r.destination()),t.asset=yr.fromOperation(r.asset()),t.amount=this._fromXDRAmount(r.amount());break;case"pathPaymentStrictReceive":t.type="pathPaymentStrictReceive",t.sendAsset=yr.fromOperation(r.sendAsset()),t.sendMax=this._fromXDRAmount(r.sendMax()),t.destination=dn(r.destination()),t.destAsset=yr.fromOperation(r.destAsset()),t.destAmount=this._fromXDRAmount(r.destAmount()),t.path=[];var o=r.path();Object.keys(o).forEach(function(e){t.path.push(yr.fromOperation(o[e]))});break;case"pathPaymentStrictSend":t.type="pathPaymentStrictSend",t.sendAsset=yr.fromOperation(r.sendAsset()),t.sendAmount=this._fromXDRAmount(r.sendAmount()),t.destination=dn(r.destination()),t.destAsset=yr.fromOperation(r.destAsset()),t.destMin=this._fromXDRAmount(r.destMin()),t.path=[];var a=r.path();Object.keys(a).forEach(function(e){t.path.push(yr.fromOperation(a[e]))});break;case"changeTrust":if(t.type="changeTrust",r.line().switch()===i.AssetType.assetTypePoolShare())t.line=tn.fromOperation(r.line());else t.line=yr.fromOperation(r.line());t.limit=this._fromXDRAmount(r.limit());break;case"allowTrust":t.type="allowTrust",t.trustor=Mn(r.trustor()),t.assetCode=r.asset().value().toString(),t.assetCode=Ht(t.assetCode,"\0"),t.authorize=r.authorize();break;case"setOptions":if(t.type="setOptions",r.inflationDest()&&(t.inflationDest=Mn(r.inflationDest())),t.clearFlags=r.clearFlags(),t.setFlags=r.setFlags(),t.masterWeight=r.masterWeight(),t.lowThreshold=r.lowThreshold(),t.medThreshold=r.medThreshold(),t.highThreshold=r.highThreshold(),t.homeDomain=void 0!==r.homeDomain()?r.homeDomain().toString("ascii"):void 0,r.signer()){var s={},u=r.signer().key().arm();if("ed25519"===u)s.ed25519PublicKey=Mn(r.signer().key());else if("preAuthTx"===u)s.preAuthTx=r.signer().key().preAuthTx();else if("hashX"===u)s.sha256Hash=r.signer().key().hashX();else if("ed25519SignedPayload"===u){var c=r.signer().key().ed25519SignedPayload();s.ed25519SignedPayload=tr.encodeSignedPayload(c.toXDR())}s.weight=r.signer().weight(),t.signer=s}break;case"manageOffer":case"manageSellOffer":t.type="manageSellOffer",t.selling=yr.fromOperation(r.selling()),t.buying=yr.fromOperation(r.buying()),t.amount=this._fromXDRAmount(r.amount()),t.price=this._fromXDRPrice(r.price()),t.offerId=r.offerId().toString();break;case"manageBuyOffer":t.type="manageBuyOffer",t.selling=yr.fromOperation(r.selling()),t.buying=yr.fromOperation(r.buying()),t.buyAmount=this._fromXDRAmount(r.buyAmount()),t.price=this._fromXDRPrice(r.price()),t.offerId=r.offerId().toString();break;case"createPassiveOffer":case"createPassiveSellOffer":t.type="createPassiveSellOffer",t.selling=yr.fromOperation(r.selling()),t.buying=yr.fromOperation(r.buying()),t.amount=this._fromXDRAmount(r.amount()),t.price=this._fromXDRPrice(r.price());break;case"accountMerge":t.type="accountMerge",t.destination=dn(r);break;case"manageData":t.type="manageData",t.name=r.dataName().toString("ascii"),t.value=r.dataValue();break;case"inflation":t.type="inflation";break;case"bumpSequence":t.type="bumpSequence",t.bumpTo=r.bumpTo().toString();break;case"createClaimableBalance":t.type="createClaimableBalance",t.asset=yr.fromOperation(r.asset()),t.amount=this._fromXDRAmount(r.amount()),t.claimants=[],r.claimants().forEach(function(e){t.claimants.push(an.fromXDR(e))});break;case"claimClaimableBalance":t.type="claimClaimableBalance",t.balanceId=r.toXDR("hex");break;case"beginSponsoringFutureReserves":t.type="beginSponsoringFutureReserves",t.sponsoredId=Mn(r.sponsoredId());break;case"endSponsoringFutureReserves":t.type="endSponsoringFutureReserves";break;case"revokeSponsorship":!function(e,t){switch(e.switch().name){case"revokeSponsorshipLedgerEntry":var r=e.ledgerKey();switch(r.switch().name){case i.LedgerEntryType.account().name:t.type="revokeAccountSponsorship",t.account=Mn(r.account().accountId());break;case i.LedgerEntryType.trustline().name:t.type="revokeTrustlineSponsorship",t.account=Mn(r.trustLine().accountId());var n=r.trustLine().asset();if(n.switch()===i.AssetType.assetTypePoolShare())t.asset=ln.fromOperation(n);else t.asset=yr.fromOperation(n);break;case i.LedgerEntryType.offer().name:t.type="revokeOfferSponsorship",t.seller=Mn(r.offer().sellerId()),t.offerId=r.offer().offerId().toString();break;case i.LedgerEntryType.data().name:t.type="revokeDataSponsorship",t.account=Mn(r.data().accountId()),t.name=r.data().dataName().toString("ascii");break;case i.LedgerEntryType.claimableBalance().name:t.type="revokeClaimableBalanceSponsorship",t.balanceId=r.claimableBalance().balanceId().toXDR("hex");break;case i.LedgerEntryType.liquidityPool().name:t.type="revokeLiquidityPoolSponsorship",t.liquidityPoolId=r.liquidityPool().liquidityPoolId().toString("hex");break;default:throw new Error("Unknown ledgerKey: ".concat(e.switch().name))}break;case"revokeSponsorshipSigner":t.type="revokeSignerSponsorship",t.account=Mn(e.signer().accountId()),t.signer=function(e){var t={};switch(e.switch().name){case i.SignerKeyType.signerKeyTypeEd25519().name:t.ed25519PublicKey=tr.encodeEd25519PublicKey(e.ed25519());break;case i.SignerKeyType.signerKeyTypePreAuthTx().name:t.preAuthTx=e.preAuthTx().toString("hex");break;case i.SignerKeyType.signerKeyTypeHashX().name:t.sha256Hash=e.hashX().toString("hex");break;default:throw new Error("Unknown signerKey: ".concat(e.switch().name))}return t}(e.signer().signerKey());break;default:throw new Error("Unknown revokeSponsorship: ".concat(e.switch().name))}}(r,t);break;case"clawback":t.type="clawback",t.amount=this._fromXDRAmount(r.amount()),t.from=dn(r.from()),t.asset=yr.fromOperation(r.asset());break;case"clawbackClaimableBalance":t.type="clawbackClaimableBalance",t.balanceId=r.toXDR("hex");break;case"setTrustLineFlags":t.type="setTrustLineFlags",t.asset=yr.fromOperation(r.asset()),t.trustor=Mn(r.trustor());var l=r.clearFlags(),f=r.setFlags(),p={authorized:i.TrustLineFlags.authorizedFlag(),authorizedToMaintainLiabilities:i.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),clawbackEnabled:i.TrustLineFlags.trustlineClawbackEnabledFlag()};t.flags={},Object.keys(p).forEach(function(e){var r;t.flags[e]=(r=p[e].value,!!(f&r)||!(l&r)&&void 0)});break;case"liquidityPoolDeposit":t.type="liquidityPoolDeposit",t.liquidityPoolId=r.liquidityPoolId().toString("hex"),t.maxAmountA=this._fromXDRAmount(r.maxAmountA()),t.maxAmountB=this._fromXDRAmount(r.maxAmountB()),t.minPrice=this._fromXDRPrice(r.minPrice()),t.maxPrice=this._fromXDRPrice(r.maxPrice());break;case"liquidityPoolWithdraw":t.type="liquidityPoolWithdraw",t.liquidityPoolId=r.liquidityPoolId().toString("hex"),t.amount=this._fromXDRAmount(r.amount()),t.minAmountA=this._fromXDRAmount(r.minAmountA()),t.minAmountB=this._fromXDRAmount(r.minAmountB());break;case"invokeHostFunction":var d;t.type="invokeHostFunction",t.func=r.hostFunction(),t.auth=null!==(d=r.auth())&&void 0!==d?d:[];break;case"extendFootprintTtl":t.type="extendFootprintTtl",t.extendTo=r.extendTo();break;case"restoreFootprint":t.type="restoreFootprint";break;default:throw new Error("Unknown operation: ".concat(n))}return t}},{key:"isValidAmount",value:function(e){var t,r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("string"!=typeof e)return!1;try{t=new zr(e)}catch(e){return!1}return!(!r&&t.isZero()||t.isNegative()||t.times(_n).gt(new zr("9223372036854775807").toString())||t.decimalPlaces()>7||t.isNaN()||!t.isFinite())}},{key:"constructAmountRequirementsError",value:function(e){return"".concat(e," argument must be of type String, represent a positive number and have at most 7 digits after the decimal")}},{key:"_checkUnsignedIntValue",value:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(void 0!==t)switch("string"==typeof t&&(t=parseFloat(t)),!0){case"number"!=typeof t||!Number.isFinite(t)||t%1!=0:throw new Error("".concat(e," value is invalid"));case t<0:throw new Error("".concat(e," value must be unsigned"));case!r||r&&r(t,e):return t;default:throw new Error("".concat(e," value is invalid"))}}},{key:"_toXDRAmount",value:function(e){var t=new zr(e).times(_n);return n.Hyper.fromString(t.toString())}},{key:"_fromXDRAmount",value:function(e){return new zr(e).div(_n).toFixed(7)}},{key:"_fromXDRPrice",value:function(e){return new zr(e.n()).div(new zr(e.d())).toString()}},{key:"_toXDRPrice",value:function(e){var t;if(e.n&&e.d)t=new i.Price(e);else{var r=function(e){for(var t,r,n=new zr(e),o=[[new zr(0),new zr(1)],[new zr(1),new zr(0)]],i=2;!n.gt(Gr);){t=n.integerValue(zr.ROUND_FLOOR),r=n.minus(t);var a=t.times(o[i-1][0]).plus(o[i-2][0]),s=t.times(o[i-1][1]).plus(o[i-2][1]);if(a.gt(Gr)||s.gt(Gr))break;if(o.push([a,s]),r.eq(0))break;n=new zr(1).div(r),i+=1}var u=Xr(o[o.length-1],2),c=u[0],l=u[1];if(c.isZero()||l.isZero())throw new Error("Couldn't find approximation");return[c.toNumber(),l.toNumber()]}(e);t=new i.Price({n:parseInt(r[0],10),d:parseInt(r[1],10)})}if(t.n()<0||t.d()<0)throw new Error("price must be positive");return t}}])}();function Mn(e){return tr.encodeEd25519PublicKey(e.ed25519())}jn.accountMerge=function(e){var t={};try{t.body=i.OperationBody.accountMerge(pn(e.destination))}catch(e){throw new Error("destination is invalid")}return this.setSourceAccount(t,e),new i.Operation(t)},jn.allowTrust=function(e){if(!tr.isValidEd25519PublicKey(e.trustor))throw new Error("trustor is invalid");var t={};if(t.trustor=lr.fromPublicKey(e.trustor).xdrAccountId(),e.assetCode.length<=4){var r=e.assetCode.padEnd(4,"\0");t.asset=i.AssetCode.assetTypeCreditAlphanum4(r)}else{if(!(e.assetCode.length<=12))throw new Error("Asset code must be 12 characters at max.");var n=e.assetCode.padEnd(12,"\0");t.asset=i.AssetCode.assetTypeCreditAlphanum12(n)}"boolean"==typeof e.authorize?e.authorize?t.authorize=i.TrustLineFlags.authorizedFlag().value:t.authorize=0:t.authorize=e.authorize;var o=new i.AllowTrustOp(t),a={};return a.body=i.OperationBody.allowTrust(o),this.setSourceAccount(a,e),new i.Operation(a)},jn.bumpSequence=function(e){var t={};if("string"!=typeof e.bumpTo)throw new Error("bumpTo must be a string");try{new zr(e.bumpTo)}catch(e){throw new Error("bumpTo must be a stringified number")}t.bumpTo=n.Hyper.fromString(e.bumpTo);var r=new i.BumpSequenceOp(t),o={};return o.body=i.OperationBody.bumpSequence(r),this.setSourceAccount(o,e),new i.Operation(o)},jn.changeTrust=function(e){var t={};if(e.asset instanceof yr)t.line=e.asset.toChangeTrustXDRObject();else{if(!(e.asset instanceof tn))throw new TypeError("asset must be Asset or LiquidityPoolAsset");t.line=e.asset.toXDRObject()}if(void 0!==e.limit&&!this.isValidAmount(e.limit,!0))throw new TypeError(this.constructAmountRequirementsError("limit"));e.limit?t.limit=this._toXDRAmount(e.limit):t.limit=n.Hyper.fromString(new zr("9223372036854775807").toString()),e.source&&(t.source=e.source.masterKeypair);var r=new i.ChangeTrustOp(t),o={};return o.body=i.OperationBody.changeTrust(r),this.setSourceAccount(o,e),new i.Operation(o)},jn.createAccount=function(e){if(!tr.isValidEd25519PublicKey(e.destination))throw new Error("destination is invalid");if(!this.isValidAmount(e.startingBalance,!0))throw new TypeError(this.constructAmountRequirementsError("startingBalance"));var t={};t.destination=lr.fromPublicKey(e.destination).xdrAccountId(),t.startingBalance=this._toXDRAmount(e.startingBalance);var r=new i.CreateAccountOp(t),n={};return n.body=i.OperationBody.createAccount(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.createClaimableBalance=function(e){if(!(e.asset instanceof yr))throw new Error("must provide an asset for create claimable balance operation");if(!this.isValidAmount(e.amount))throw new TypeError(this.constructAmountRequirementsError("amount"));if(!Array.isArray(e.claimants)||0===e.claimants.length)throw new Error("must provide at least one claimant");var t={};t.asset=e.asset.toXDRObject(),t.amount=this._toXDRAmount(e.amount),t.claimants=Object.values(e.claimants).map(function(e){return e.toXDRObject()});var r=new i.CreateClaimableBalanceOp(t),n={};return n.body=i.OperationBody.createClaimableBalance(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.claimClaimableBalance=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};mn(e.balanceId);var t={};t.balanceId=i.ClaimableBalanceId.fromXDR(e.balanceId,"hex");var r=new i.ClaimClaimableBalanceOp(t),n={};return n.body=i.OperationBody.claimClaimableBalance(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.clawbackClaimableBalance=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};mn(e.balanceId);var t={balanceId:i.ClaimableBalanceId.fromXDR(e.balanceId,"hex")},r={body:i.OperationBody.clawbackClaimableBalance(new i.ClawbackClaimableBalanceOp(t))};return this.setSourceAccount(r,e),new i.Operation(r)},jn.createPassiveSellOffer=function(e){var t={};if(t.selling=e.selling.toXDRObject(),t.buying=e.buying.toXDRObject(),!this.isValidAmount(e.amount))throw new TypeError(this.constructAmountRequirementsError("amount"));if(t.amount=this._toXDRAmount(e.amount),void 0===e.price)throw new TypeError("price argument is required");t.price=this._toXDRPrice(e.price);var r=new i.CreatePassiveSellOfferOp(t),n={};return n.body=i.OperationBody.createPassiveSellOffer(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.inflation=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={};return t.body=i.OperationBody.inflation(),this.setSourceAccount(t,e),new i.Operation(t)},jn.manageData=function(e){var t={};if(!("string"==typeof e.name&&e.name.length<=64))throw new Error("name must be a string, up to 64 characters");if(t.dataName=e.name,"string"!=typeof e.value&&!gn.isBuffer(e.value)&&null!==e.value)throw new Error("value must be a string, Buffer or null");if("string"==typeof e.value?t.dataValue=gn.from(e.value):t.dataValue=e.value,null!==t.dataValue&&t.dataValue.length>64)throw new Error("value cannot be longer that 64 bytes");var r=new i.ManageDataOp(t),n={};return n.body=i.OperationBody.manageData(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.manageSellOffer=function(e){var t={};if(t.selling=e.selling.toXDRObject(),t.buying=e.buying.toXDRObject(),!this.isValidAmount(e.amount,!0))throw new TypeError(this.constructAmountRequirementsError("amount"));if(t.amount=this._toXDRAmount(e.amount),void 0===e.price)throw new TypeError("price argument is required");t.price=this._toXDRPrice(e.price),void 0!==e.offerId?e.offerId=e.offerId.toString():e.offerId="0",t.offerId=n.Hyper.fromString(e.offerId);var r=new i.ManageSellOfferOp(t),o={};return o.body=i.OperationBody.manageSellOffer(r),this.setSourceAccount(o,e),new i.Operation(o)},jn.manageBuyOffer=function(e){var t={};if(t.selling=e.selling.toXDRObject(),t.buying=e.buying.toXDRObject(),!this.isValidAmount(e.buyAmount,!0))throw new TypeError(this.constructAmountRequirementsError("buyAmount"));if(t.buyAmount=this._toXDRAmount(e.buyAmount),void 0===e.price)throw new TypeError("price argument is required");t.price=this._toXDRPrice(e.price),void 0!==e.offerId?e.offerId=e.offerId.toString():e.offerId="0",t.offerId=n.Hyper.fromString(e.offerId);var r=new i.ManageBuyOfferOp(t),o={};return o.body=i.OperationBody.manageBuyOffer(r),this.setSourceAccount(o,e),new i.Operation(o)},jn.pathPaymentStrictReceive=function(e){switch(!0){case!e.sendAsset:throw new Error("Must specify a send asset");case!this.isValidAmount(e.sendMax):throw new TypeError(this.constructAmountRequirementsError("sendMax"));case!e.destAsset:throw new Error("Must provide a destAsset for a payment operation");case!this.isValidAmount(e.destAmount):throw new TypeError(this.constructAmountRequirementsError("destAmount"))}var t={};t.sendAsset=e.sendAsset.toXDRObject(),t.sendMax=this._toXDRAmount(e.sendMax);try{t.destination=pn(e.destination)}catch(e){throw new Error("destination is invalid")}t.destAsset=e.destAsset.toXDRObject(),t.destAmount=this._toXDRAmount(e.destAmount);var r=e.path?e.path:[];t.path=r.map(function(e){return e.toXDRObject()});var n=new i.PathPaymentStrictReceiveOp(t),o={};return o.body=i.OperationBody.pathPaymentStrictReceive(n),this.setSourceAccount(o,e),new i.Operation(o)},jn.pathPaymentStrictSend=function(e){switch(!0){case!e.sendAsset:throw new Error("Must specify a send asset");case!this.isValidAmount(e.sendAmount):throw new TypeError(this.constructAmountRequirementsError("sendAmount"));case!e.destAsset:throw new Error("Must provide a destAsset for a payment operation");case!this.isValidAmount(e.destMin):throw new TypeError(this.constructAmountRequirementsError("destMin"))}var t={};t.sendAsset=e.sendAsset.toXDRObject(),t.sendAmount=this._toXDRAmount(e.sendAmount);try{t.destination=pn(e.destination)}catch(e){throw new Error("destination is invalid")}t.destAsset=e.destAsset.toXDRObject(),t.destMin=this._toXDRAmount(e.destMin);var r=e.path?e.path:[];t.path=r.map(function(e){return e.toXDRObject()});var n=new i.PathPaymentStrictSendOp(t),o={};return o.body=i.OperationBody.pathPaymentStrictSend(n),this.setSourceAccount(o,e),new i.Operation(o)},jn.payment=function(e){if(!e.asset)throw new Error("Must provide an asset for a payment operation");if(!this.isValidAmount(e.amount))throw new TypeError(this.constructAmountRequirementsError("amount"));var t={};try{t.destination=pn(e.destination)}catch(e){throw new Error("destination is invalid")}t.asset=e.asset.toXDRObject(),t.amount=this._toXDRAmount(e.amount);var r=new i.PaymentOp(t),n={};return n.body=i.OperationBody.payment(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.setOptions=function(e){var t={};if(e.inflationDest){if(!tr.isValidEd25519PublicKey(e.inflationDest))throw new Error("inflationDest is invalid");t.inflationDest=lr.fromPublicKey(e.inflationDest).xdrAccountId()}if(t.clearFlags=this._checkUnsignedIntValue("clearFlags",e.clearFlags),t.setFlags=this._checkUnsignedIntValue("setFlags",e.setFlags),t.masterWeight=this._checkUnsignedIntValue("masterWeight",e.masterWeight,bn),t.lowThreshold=this._checkUnsignedIntValue("lowThreshold",e.lowThreshold,bn),t.medThreshold=this._checkUnsignedIntValue("medThreshold",e.medThreshold,bn),t.highThreshold=this._checkUnsignedIntValue("highThreshold",e.highThreshold,bn),void 0!==e.homeDomain&&"string"!=typeof e.homeDomain)throw new TypeError("homeDomain argument must be of type String");if(t.homeDomain=e.homeDomain,e.signer){var r,n=this._checkUnsignedIntValue("signer.weight",e.signer.weight,bn),o=0;if(e.signer.ed25519PublicKey){if(!tr.isValidEd25519PublicKey(e.signer.ed25519PublicKey))throw new Error("signer.ed25519PublicKey is invalid.");var a=tr.decodeEd25519PublicKey(e.signer.ed25519PublicKey);r=new i.SignerKey.signerKeyTypeEd25519(a),o+=1}if(e.signer.preAuthTx){if("string"==typeof e.signer.preAuthTx&&(e.signer.preAuthTx=vn.from(e.signer.preAuthTx,"hex")),!vn.isBuffer(e.signer.preAuthTx)||32!==e.signer.preAuthTx.length)throw new Error("signer.preAuthTx must be 32 bytes Buffer.");r=new i.SignerKey.signerKeyTypePreAuthTx(e.signer.preAuthTx),o+=1}if(e.signer.sha256Hash){if("string"==typeof e.signer.sha256Hash&&(e.signer.sha256Hash=vn.from(e.signer.sha256Hash,"hex")),!vn.isBuffer(e.signer.sha256Hash)||32!==e.signer.sha256Hash.length)throw new Error("signer.sha256Hash must be 32 bytes Buffer.");r=new i.SignerKey.signerKeyTypeHashX(e.signer.sha256Hash),o+=1}if(e.signer.ed25519SignedPayload){if(!tr.isValidSignedPayload(e.signer.ed25519SignedPayload))throw new Error("signer.ed25519SignedPayload is invalid.");var s=tr.decodeSignedPayload(e.signer.ed25519SignedPayload),u=i.SignerKeyEd25519SignedPayload.fromXDR(s);r=i.SignerKey.signerKeyTypeEd25519SignedPayload(u),o+=1}if(1!==o)throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");t.signer=new i.Signer({key:r,weight:n})}var c=new i.SetOptionsOp(t),l={};return l.body=i.OperationBody.setOptions(c),this.setSourceAccount(l,e),new i.Operation(l)},jn.beginSponsoringFutureReserves=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!tr.isValidEd25519PublicKey(e.sponsoredId))throw new Error("sponsoredId is invalid");var t=new i.BeginSponsoringFutureReservesOp({sponsoredId:lr.fromPublicKey(e.sponsoredId).xdrAccountId()}),r={};return r.body=i.OperationBody.beginSponsoringFutureReserves(t),this.setSourceAccount(r,e),new i.Operation(r)},jn.endSponsoringFutureReserves=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={};return t.body=i.OperationBody.endSponsoringFutureReserves(),this.setSourceAccount(t,e),new i.Operation(t)},jn.revokeAccountSponsorship=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!tr.isValidEd25519PublicKey(e.account))throw new Error("account is invalid");var t=i.LedgerKey.account(new i.LedgerKeyAccount({accountId:lr.fromPublicKey(e.account).xdrAccountId()})),r=i.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t),n={};return n.body=i.OperationBody.revokeSponsorship(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.revokeTrustlineSponsorship=function(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!tr.isValidEd25519PublicKey(t.account))throw new Error("account is invalid");if(t.asset instanceof yr)e=t.asset.toTrustLineXDRObject();else{if(!(t.asset instanceof ln))throw new TypeError("asset must be an Asset or LiquidityPoolId");e=t.asset.toXDRObject()}var r=i.LedgerKey.trustline(new i.LedgerKeyTrustLine({accountId:lr.fromPublicKey(t.account).xdrAccountId(),asset:e})),n=i.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(r),o={};return o.body=i.OperationBody.revokeSponsorship(n),this.setSourceAccount(o,t),new i.Operation(o)},jn.revokeOfferSponsorship=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!tr.isValidEd25519PublicKey(e.seller))throw new Error("seller is invalid");if("string"!=typeof e.offerId)throw new Error("offerId is invalid");var t=i.LedgerKey.offer(new i.LedgerKeyOffer({sellerId:lr.fromPublicKey(e.seller).xdrAccountId(),offerId:i.Int64.fromString(e.offerId)})),r=i.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t),n={};return n.body=i.OperationBody.revokeSponsorship(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.revokeDataSponsorship=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!tr.isValidEd25519PublicKey(e.account))throw new Error("account is invalid");if("string"!=typeof e.name||e.name.length>64)throw new Error("name must be a string, up to 64 characters");var t=i.LedgerKey.data(new i.LedgerKeyData({accountId:lr.fromPublicKey(e.account).xdrAccountId(),dataName:e.name})),r=i.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t),n={};return n.body=i.OperationBody.revokeSponsorship(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.revokeClaimableBalanceSponsorship=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("string"!=typeof e.balanceId)throw new Error("balanceId is invalid");var t=i.LedgerKey.claimableBalance(new i.LedgerKeyClaimableBalance({balanceId:i.ClaimableBalanceId.fromXDR(e.balanceId,"hex")})),r=i.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t),n={};return n.body=i.OperationBody.revokeSponsorship(r),this.setSourceAccount(n,e),new i.Operation(n)},jn.revokeLiquidityPoolSponsorship=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("string"!=typeof e.liquidityPoolId)throw new Error("liquidityPoolId is invalid");var t=i.LedgerKey.liquidityPool(new i.LedgerKeyLiquidityPool({liquidityPoolId:i.PoolId.fromXDR(e.liquidityPoolId,"hex")})),r=i.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t),n={body:i.OperationBody.revokeSponsorship(r)};return this.setSourceAccount(n,e),new i.Operation(n)},jn.revokeSignerSponsorship=function(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!tr.isValidEd25519PublicKey(t.account))throw new Error("account is invalid");if(t.signer.ed25519PublicKey){if(!tr.isValidEd25519PublicKey(t.signer.ed25519PublicKey))throw new Error("signer.ed25519PublicKey is invalid.");var r=tr.decodeEd25519PublicKey(t.signer.ed25519PublicKey);e=new i.SignerKey.signerKeyTypeEd25519(r)}else if(t.signer.preAuthTx){var n;if(n="string"==typeof t.signer.preAuthTx?wn.from(t.signer.preAuthTx,"hex"):t.signer.preAuthTx,!wn.isBuffer(n)||32!==n.length)throw new Error("signer.preAuthTx must be 32 bytes Buffer.");e=new i.SignerKey.signerKeyTypePreAuthTx(n)}else{if(!t.signer.sha256Hash)throw new Error("signer is invalid");var o;if(o="string"==typeof t.signer.sha256Hash?wn.from(t.signer.sha256Hash,"hex"):t.signer.sha256Hash,!wn.isBuffer(o)||32!==o.length)throw new Error("signer.sha256Hash must be 32 bytes Buffer.");e=new i.SignerKey.signerKeyTypeHashX(o)}var a=new i.RevokeSponsorshipOpSigner({accountId:lr.fromPublicKey(t.account).xdrAccountId(),signerKey:e}),s=i.RevokeSponsorshipOp.revokeSponsorshipSigner(a),u={};return u.body=i.OperationBody.revokeSponsorship(s),this.setSourceAccount(u,t),new i.Operation(u)},jn.clawback=function(e){var t={};if(!this.isValidAmount(e.amount))throw new TypeError(this.constructAmountRequirementsError("amount"));t.amount=this._toXDRAmount(e.amount),t.asset=e.asset.toXDRObject();try{t.from=pn(e.from)}catch(e){throw new Error("from address is invalid")}var r={body:i.OperationBody.clawback(new i.ClawbackOp(t))};return this.setSourceAccount(r,e),new i.Operation(r)},jn.setTrustLineFlags=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={};if("object"!==Sn(e.flags)||0===Object.keys(e.flags).length)throw new Error("opts.flags must be a map of boolean flags to modify");var r={authorized:i.TrustLineFlags.authorizedFlag(),authorizedToMaintainLiabilities:i.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),clawbackEnabled:i.TrustLineFlags.trustlineClawbackEnabledFlag()},n=0,o=0;Object.keys(e.flags).forEach(function(t){if(!Object.prototype.hasOwnProperty.call(r,t))throw new Error("unsupported flag name specified: ".concat(t));var i=e.flags[t],a=r[t].value;!0===i?o|=a:!1===i&&(n|=a)}),t.trustor=lr.fromPublicKey(e.trustor).xdrAccountId(),t.asset=e.asset.toXDRObject(),t.clearFlags=n,t.setFlags=o;var a={body:i.OperationBody.setTrustLineFlags(new i.SetTrustLineFlagsOp(t))};return this.setSourceAccount(a,e),new i.Operation(a)},jn.liquidityPoolDeposit=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.liquidityPoolId,r=e.maxAmountA,n=e.maxAmountB,o=e.minPrice,a=e.maxPrice,s={};if(!t)throw new TypeError("liquidityPoolId argument is required");if(s.liquidityPoolId=i.PoolId.fromXDR(t,"hex"),!this.isValidAmount(r,!0))throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));if(s.maxAmountA=this._toXDRAmount(r),!this.isValidAmount(n,!0))throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));if(s.maxAmountB=this._toXDRAmount(n),void 0===o)throw new TypeError("minPrice argument is required");if(s.minPrice=this._toXDRPrice(o),void 0===a)throw new TypeError("maxPrice argument is required");s.maxPrice=this._toXDRPrice(a);var u=new i.LiquidityPoolDepositOp(s),c={body:i.OperationBody.liquidityPoolDeposit(u)};return this.setSourceAccount(c,e),new i.Operation(c)},jn.liquidityPoolWithdraw=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t={};if(!e.liquidityPoolId)throw new TypeError("liquidityPoolId argument is required");if(t.liquidityPoolId=i.PoolId.fromXDR(e.liquidityPoolId,"hex"),!this.isValidAmount(e.amount))throw new TypeError(this.constructAmountRequirementsError("amount"));if(t.amount=this._toXDRAmount(e.amount),!this.isValidAmount(e.minAmountA,!0))throw new TypeError(this.constructAmountRequirementsError("minAmountA"));if(t.minAmountA=this._toXDRAmount(e.minAmountA),!this.isValidAmount(e.minAmountB,!0))throw new TypeError(this.constructAmountRequirementsError("minAmountB"));t.minAmountB=this._toXDRAmount(e.minAmountB);var r=new i.LiquidityPoolWithdrawOp(t),n={body:i.OperationBody.liquidityPoolWithdraw(r)};return this.setSourceAccount(n,e),new i.Operation(n)},jn.invokeHostFunction=function(e){if(!e.func)throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(e),")"));e.func.switch().value===i.HostFunctionType.hostFunctionTypeInvokeContract().value&&e.func.invokeContract().args().forEach(function(e){var t;try{t=On.fromScVal(e)}catch(e){return}switch(t._type){case"claimableBalance":case"liquidityPool":throw new TypeError("claimable balances and liquidity pools cannot be arguments to invokeHostFunction")}});var t=new i.InvokeHostFunctionOp({hostFunction:e.func,auth:e.auth||[]}),r={body:i.OperationBody.invokeHostFunction(t)};return this.setSourceAccount(r,e),new i.Operation(r)},jn.extendFootprintTtl=function(e){var t;if((null!==(t=e.extendTo)&&void 0!==t?t:-1)<=0)throw new RangeError("extendTo has to be positive");var r=new i.ExtendFootprintTtlOp({ext:new i.ExtensionPoint(0),extendTo:e.extendTo}),n={body:i.OperationBody.extendFootprintTtl(r)};return this.setSourceAccount(n,e),new i.Operation(n)},jn.restoreFootprint=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=new i.RestoreFootprintOp({ext:new i.ExtensionPoint(0)}),r={body:i.OperationBody.restoreFootprint(t)};return this.setSourceAccount(r,null!=e?e:{}),new i.Operation(r)},jn.createStellarAssetContract=function(e){var t=e.asset;if("string"==typeof t){var r=Pn(t.split(":"),2),n=r[0],o=r[1];t=new yr(n,o)}if(!(t instanceof yr))throw new TypeError("expected Asset in 'opts.asset', got ".concat(t));return this.invokeHostFunction({source:e.source,auth:e.auth,func:i.HostFunction.hostFunctionTypeCreateContract(new i.CreateContractArgs({executable:i.ContractExecutable.contractExecutableStellarAsset(),contractIdPreimage:i.ContractIdPreimage.contractIdPreimageFromAsset(t.toXDRObject())}))})},jn.invokeContractFunction=function(e){var t=new On(e.contract);if("contract"!==t._type)throw new TypeError("expected contract strkey instance, got ".concat(t));return this.invokeHostFunction({source:e.source,auth:e.auth,func:i.HostFunction.hostFunctionTypeInvokeContract(new i.InvokeContractArgs({contractAddress:t.toScAddress(),functionName:e.function,args:e.args}))})},jn.createCustomContract=function(e){var t,r=xn.from(e.salt||lr.random().xdrPublicKey().value());if(!e.wasmHash||32!==e.wasmHash.length)throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(e.wasmHash));if(32!==r.length)throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(e.wasmHash));return this.invokeHostFunction({source:e.source,auth:e.auth,func:i.HostFunction.hostFunctionTypeCreateContractV2(new i.CreateContractArgsV2({executable:i.ContractExecutable.contractExecutableWasm(xn.from(e.wasmHash)),contractIdPreimage:i.ContractIdPreimage.contractIdPreimageFromAddress(new i.ContractIdPreimageFromAddress({address:e.address.toScAddress(),salt:r})),constructorArgs:null!==(t=e.constructorArgs)&&void 0!==t?t:[]}))})},jn.uploadContractWasm=function(e){return this.invokeHostFunction({source:e.source,auth:e.auth,func:i.HostFunction.hostFunctionTypeUploadContractWasm(xn.from(e.wasm))})};var Dn=r(8287).Buffer;function Vn(e){return Vn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Vn(e)}function qn(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Kn(n.key),n)}}function Kn(e){var t=function(e,t){if("object"!=Vn(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Vn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Vn(t)?t:t+""}var Hn="none",zn="id",Xn="text",$n="hash",Gn="return",Wn=function(){function e(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;switch(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._type=t,this._value=r,this._type){case Hn:break;case zn:e._validateIdValue(r);break;case Xn:e._validateTextValue(r);break;case $n:case Gn:e._validateHashValue(r),"string"==typeof r&&(this._value=Dn.from(r,"hex"));break;default:throw new Error("Invalid memo type")}}return function(e,t,r){return t&&qn(e.prototype,t),r&&qn(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(e,[{key:"type",get:function(){return this._type},set:function(e){throw new Error("Memo is immutable")}},{key:"value",get:function(){switch(this._type){case Hn:return null;case zn:case Xn:return this._value;case $n:case Gn:return Dn.from(this._value);default:throw new Error("Invalid memo type")}},set:function(e){throw new Error("Memo is immutable")}},{key:"toXDRObject",value:function(){switch(this._type){case Hn:return i.Memo.memoNone();case zn:return i.Memo.memoId(n.UnsignedHyper.fromString(this._value));case Xn:return i.Memo.memoText(this._value);case $n:return i.Memo.memoHash(this._value);case Gn:return i.Memo.memoReturn(this._value);default:return null}}}],[{key:"_validateIdValue",value:function(e){var t,r=new Error("Expects a int64 as a string. Got ".concat(e));if("string"!=typeof e)throw r;try{t=new zr(e)}catch(e){throw r}if(!t.isFinite())throw r;if(t.isNaN())throw r}},{key:"_validateTextValue",value:function(e){if(!i.Memo.armTypeForArm("text").isValid(e))throw new Error("Expects string, array or buffer, max 28 bytes")}},{key:"_validateHashValue",value:function(e){var t,r=new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(e));if(null==e)throw r;if("string"==typeof e){if(!/^[0-9A-Fa-f]{64}$/g.test(e))throw r;t=Dn.from(e,"hex")}else{if(!Dn.isBuffer(e))throw r;t=Dn.from(e)}if(!t.length||32!==t.length)throw r}},{key:"none",value:function(){return new e(Hn)}},{key:"text",value:function(t){return new e(Xn,t)}},{key:"id",value:function(t){return new e(zn,t)}},{key:"hash",value:function(t){return new e($n,t)}},{key:"return",value:function(t){return new e(Gn,t)}},{key:"fromXDRObject",value:function(t){switch(t.arm()){case"id":return e.id(t.value().toString());case"text":return e.text(t.value());case"hash":return e.hash(t.value());case"retHash":return e.return(t.value())}if(void 0===t.value())return e.none();throw new Error("Unknown type")}}])}(),Yn=r(8287).Buffer;function Zn(e){return Zn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Zn(e)}function Jn(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Qn(n.key),n)}}function Qn(e){var t=function(e,t){if("object"!=Zn(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Zn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Zn(t)?t:t+""}function eo(e,t,r){return t=ro(t),function(e,t){if(t&&("object"==Zn(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,to()?Reflect.construct(t,r||[],ro(e).constructor):t.apply(e,r))}function to(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(to=function(){return!!e})()}function ro(e){return ro=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},ro(e)}function no(e,t){return no=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},no(e,t)}var oo=function(e){function t(e,r){var n;if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),"string"==typeof e){var o=Yn.from(e,"base64");e=i.TransactionEnvelope.fromXDR(o)}var a=e.switch();if(a!==i.EnvelopeType.envelopeTypeTxV0()&&a!==i.EnvelopeType.envelopeTypeTx())throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(a.name,"."));var s=e.value(),u=s.tx(),c=u.fee().toString();if((n=eo(this,t,[u,(s.signatures()||[]).slice(),c,r]))._envelopeType=a,n._memo=u.memo(),n._sequence=u.seqNum().toString(),n._envelopeType===i.EnvelopeType.envelopeTypeTxV0())n._source=tr.encodeEd25519PublicKey(n.tx.sourceAccountEd25519());else n._source=dn(n.tx.sourceAccount());var l=null,f=null;switch(n._envelopeType){case i.EnvelopeType.envelopeTypeTxV0():f=u.timeBounds();break;case i.EnvelopeType.envelopeTypeTx():switch(u.cond().switch()){case i.PreconditionType.precondTime():f=u.cond().timeBounds();break;case i.PreconditionType.precondV2():f=(l=u.cond().v2()).timeBounds()}}if(f&&(n._timeBounds={minTime:f.minTime().toString(),maxTime:f.maxTime().toString()}),l){var p=l.ledgerBounds();p&&(n._ledgerBounds={minLedger:p.minLedger(),maxLedger:p.maxLedger()});var d=l.minSeqNum();d&&(n._minAccountSequence=d.toString()),n._minAccountSequenceAge=l.minSeqAge(),n._minAccountSequenceLedgerGap=l.minSeqLedgerGap(),n._extraSigners=l.extraSigners()}var h=u.operations()||[];return n._operations=h.map(function(e){return jn.fromXDRObject(e)}),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&no(e,t)}(t,e),function(e,t,r){return t&&Jn(e.prototype,t),r&&Jn(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(t,[{key:"timeBounds",get:function(){return this._timeBounds},set:function(e){throw new Error("Transaction is immutable")}},{key:"ledgerBounds",get:function(){return this._ledgerBounds},set:function(e){throw new Error("Transaction is immutable")}},{key:"minAccountSequence",get:function(){return this._minAccountSequence},set:function(e){throw new Error("Transaction is immutable")}},{key:"minAccountSequenceAge",get:function(){return this._minAccountSequenceAge},set:function(e){throw new Error("Transaction is immutable")}},{key:"minAccountSequenceLedgerGap",get:function(){return this._minAccountSequenceLedgerGap},set:function(e){throw new Error("Transaction is immutable")}},{key:"extraSigners",get:function(){return this._extraSigners},set:function(e){throw new Error("Transaction is immutable")}},{key:"sequence",get:function(){return this._sequence},set:function(e){throw new Error("Transaction is immutable")}},{key:"source",get:function(){return this._source},set:function(e){throw new Error("Transaction is immutable")}},{key:"operations",get:function(){return this._operations},set:function(e){throw new Error("Transaction is immutable")}},{key:"memo",get:function(){return Wn.fromXDRObject(this._memo)},set:function(e){throw new Error("Transaction is immutable")}},{key:"signatureBase",value:function(){var e=this.tx;this._envelopeType===i.EnvelopeType.envelopeTypeTxV0()&&(e=i.Transaction.fromXDR(Yn.concat([i.PublicKeyType.publicKeyTypeEd25519().toXDR(),e.toXDR()])));var t=new i.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(e);return new i.TransactionSignaturePayload({networkId:i.Hash.fromXDR(u(this.networkPassphrase)),taggedTransaction:t}).toXDR()}},{key:"toEnvelope",value:function(){var e,t=this.tx.toXDR(),r=this.signatures.slice();switch(this._envelopeType){case i.EnvelopeType.envelopeTypeTxV0():e=new i.TransactionEnvelope.envelopeTypeTxV0(new i.TransactionV0Envelope({tx:i.TransactionV0.fromXDR(t),signatures:r}));break;case i.EnvelopeType.envelopeTypeTx():e=new i.TransactionEnvelope.envelopeTypeTx(new i.TransactionV1Envelope({tx:i.Transaction.fromXDR(t),signatures:r}));break;default:throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name,"."))}return e}},{key:"getClaimableBalanceId",value:function(e){if(!Number.isInteger(e)||e<0||e>=this.operations.length)throw new RangeError("invalid operation index");var t=this.operations[e];try{t=jn.createClaimableBalance(t)}catch(e){throw new TypeError("expected createClaimableBalance, got ".concat(t.type,": ").concat(e))}var r=tr.decodeEd25519PublicKey(yn(this.source)),n=u(i.HashIdPreimage.envelopeTypeOpId(new i.HashIdPreimageOperationId({sourceAccount:i.AccountId.publicKeyTypeEd25519(r),seqNum:i.SequenceNumber.fromString(this.sequence),opNum:e})).toXDR("raw"));return i.ClaimableBalanceId.claimableBalanceIdTypeV0(n).toXDR("hex")}}])}(Ar),io=r(8287).Buffer;function ao(e){return ao="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ao(e)}function so(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,uo(n.key),n)}}function uo(e){var t=function(e,t){if("object"!=ao(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=ao(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==ao(t)?t:t+""}function co(e,t,r){return t=fo(t),function(e,t){if(t&&("object"==ao(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,lo()?Reflect.construct(t,r||[],fo(e).constructor):t.apply(e,r))}function lo(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(lo=function(){return!!e})()}function fo(e){return fo=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},fo(e)}function po(e,t){return po=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},po(e,t)}var ho=function(e){function t(e,r){var n;if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),"string"==typeof e){var o=io.from(e,"base64");e=i.TransactionEnvelope.fromXDR(o)}var a=e.switch();if(a!==i.EnvelopeType.envelopeTypeTxFeeBump())throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(a.name,"."));var s=e.value(),u=s.tx(),c=u.fee().toString();n=co(this,t,[u,(s.signatures()||[]).slice(),c,r]);var l=i.TransactionEnvelope.envelopeTypeTx(u.innerTx().v1());return n._feeSource=dn(n.tx.feeSource()),n._innerTransaction=new oo(l,r),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&po(e,t)}(t,e),function(e,t,r){return t&&so(e.prototype,t),r&&so(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(t,[{key:"innerTransaction",get:function(){return this._innerTransaction}},{key:"operations",get:function(){return this._innerTransaction.operations}},{key:"feeSource",get:function(){return this._feeSource}},{key:"signatureBase",value:function(){var e=new i.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);return new i.TransactionSignaturePayload({networkId:i.Hash.fromXDR(u(this.networkPassphrase)),taggedTransaction:e}).toXDR()}},{key:"toEnvelope",value:function(){var e=new i.FeeBumpTransactionEnvelope({tx:i.FeeBumpTransaction.fromXDR(this.tx.toXDR()),signatures:this.signatures.slice()});return new i.TransactionEnvelope.envelopeTypeTxFeeBump(e)}}])}(Ar);function yo(e){return yo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},yo(e)}function mo(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,go(n.key),n)}}function go(e){var t=function(e,t){if("object"!=yo(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=yo(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==yo(t)?t:t+""}var vo=function(){return function(e,t,r){return t&&mo(e.prototype,t),r&&mo(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t,r){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),tr.isValidMed25519PublicKey(t))throw new Error("accountId is an M-address; use MuxedAccount instead");if(!tr.isValidEd25519PublicKey(t))throw new Error("accountId is invalid");if("string"!=typeof r)throw new Error("sequence must be of type string");this._accountId=t,this.sequence=new zr(r)},[{key:"accountId",value:function(){return this._accountId}},{key:"sequenceNumber",value:function(){return this.sequence.toString()}},{key:"incrementSequenceNumber",value:function(){this.sequence=this.sequence.plus(1)}}])}();function bo(e){return bo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},bo(e)}function wo(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,So(n.key),n)}}function So(e){var t=function(e,t){if("object"!=bo(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=bo(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==bo(t)?t:t+""}var Eo=function(){function e(t,r){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e);var n=t.accountId();if(!tr.isValidEd25519PublicKey(n))throw new Error("accountId is invalid");this.account=t,this._muxedXdr=hn(n,r),this._mAddress=dn(this._muxedXdr),this._id=r}return function(e,t,r){return t&&wo(e.prototype,t),r&&wo(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(e,[{key:"baseAccount",value:function(){return this.account}},{key:"accountId",value:function(){return this._mAddress}},{key:"id",value:function(){return this._id}},{key:"setId",value:function(e){if("string"!=typeof e)throw new Error("id should be a string representing a number (uint64)");return this._muxedXdr.med25519().id(i.Uint64.fromString(e)),this._mAddress=dn(this._muxedXdr),this._id=e,this}},{key:"sequenceNumber",value:function(){return this.account.sequenceNumber()}},{key:"incrementSequenceNumber",value:function(){return this.account.incrementSequenceNumber()}},{key:"toXDRObject",value:function(){return this._muxedXdr}},{key:"equals",value:function(e){return this.accountId()===e.accountId()}}],[{key:"fromAddress",value:function(t,r){var n=pn(t),o=yn(t),i=n.med25519().id().toString();return new e(new vo(o,r),i)}}])}();function ko(e){return ko="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ko(e)}function Ao(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,To(n.key),n)}}function To(e){var t=function(e,t){if("object"!=ko(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=ko(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==ko(t)?t:t+""}var Oo=function(){return function(e,t,r){return t&&Ao(e.prototype,t),r&&Ao(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t){var r;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),function(e,t,r){(t=To(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r}(this,"_data",void 0),r=t?"string"==typeof t||ArrayBuffer.isView(t)?e.fromXDR(t):e.fromXDR(t.toXDR()):new i.SorobanTransactionData({resources:new i.SorobanResources({footprint:new i.LedgerFootprint({readOnly:[],readWrite:[]}),instructions:0,diskReadBytes:0,writeBytes:0}),ext:new i.SorobanTransactionDataExt(0),resourceFee:new i.Int64(0)}),this._data=r},[{key:"setResourceFee",value:function(e){return this._data.resourceFee(new i.Int64(e)),this}},{key:"setResources",value:function(e,t,r){return this._data.resources().instructions(e),this._data.resources().diskReadBytes(t),this._data.resources().writeBytes(r),this}},{key:"appendFootprint",value:function(e,t){return this.setFootprint(this.getReadOnly().concat(e),this.getReadWrite().concat(t))}},{key:"setFootprint",value:function(e,t){return null!==e&&this.setReadOnly(e),null!==t&&this.setReadWrite(t),this}},{key:"setReadOnly",value:function(e){return this._data.resources().footprint().readOnly(null!=e?e:[]),this}},{key:"setReadWrite",value:function(e){return this._data.resources().footprint().readWrite(null!=e?e:[]),this}},{key:"build",value:function(){return i.SorobanTransactionData.fromXDR(this._data.toXDR())}},{key:"getReadOnly",value:function(){return this.getFootprint().readOnly()}},{key:"getReadWrite",value:function(){return this.getFootprint().readWrite()}},{key:"getFootprint",value:function(){return this._data.resources().footprint()}}],[{key:"fromXDR",value:function(e){return i.SorobanTransactionData.fromXDR(e,"string"==typeof e?"base64":"raw")}}])}();function xo(e){return xo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},xo(e)}function Po(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Bo(n.key),n)}}function Bo(e){var t=function(e,t){if("object"!=xo(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=xo(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==xo(t)?t:t+""}var Io=function(){return function(e,t,r){return t&&Po(e.prototype,t),r&&Po(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)},null,[{key:"decodeAddress",value:function(e){var t={ed25519PublicKey:i.SignerKey.signerKeyTypeEd25519,preAuthTx:i.SignerKey.signerKeyTypePreAuthTx,sha256Hash:i.SignerKey.signerKeyTypeHashX,signedPayload:i.SignerKey.signerKeyTypeEd25519SignedPayload},r=tr.getVersionByteForPrefix(e),n=t[r];if(!n)throw new Error("invalid signer key type (".concat(r,")"));var o=nr(r,e);return n("signedPayload"===r?new i.SignerKeyEd25519SignedPayload({ed25519:o.slice(0,32),payload:o.slice(36)}):o)}},{key:"encodeSignerKey",value:function(e){var t,r;switch(e.switch()){case i.SignerKeyType.signerKeyTypeEd25519():t="ed25519PublicKey",r=e.value();break;case i.SignerKeyType.signerKeyTypePreAuthTx():t="preAuthTx",r=e.value();break;case i.SignerKeyType.signerKeyTypeHashX():t="sha256Hash",r=e.value();break;case i.SignerKeyType.signerKeyTypeEd25519SignedPayload():t="signedPayload",r=e.ed25519SignedPayload().toXDR("raw");break;default:throw new Error("invalid SignerKey (type: ".concat(e.switch(),")"))}return or(t,r)}}])}();function Co(e){return Co="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Co(e)}function Ro(e){return function(e){if(Array.isArray(e))return _o(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(e){if("string"==typeof e)return _o(e,t);var r={}.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_o(e,t):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _o(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n}function Uo(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function No(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Uo(Object(r),!0).forEach(function(t){Lo(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Uo(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function Lo(e,t,r){return(t=jo(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function Fo(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,jo(n.key),n)}}function jo(e){var t=function(e,t){if("object"!=Co(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Co(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Co(t)?t:t+""}var Mo="100",Do=0,Vo=function(){function e(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),!t)throw new Error("must specify source account for the transaction");if(void 0===r.fee)throw new Error("must specify fee for the transaction (in stroops)");this.source=t,this.operations=[],this.baseFee=r.fee,this.timebounds=r.timebounds?No({},r.timebounds):null,this.ledgerbounds=r.ledgerbounds?No({},r.ledgerbounds):null,this.minAccountSequence=r.minAccountSequence||null,this.minAccountSequenceAge=r.minAccountSequenceAge||null,this.minAccountSequenceLedgerGap=r.minAccountSequenceLedgerGap||null,this.extraSigners=r.extraSigners?Ro(r.extraSigners):null,this.memo=r.memo||Wn.none(),this.networkPassphrase=r.networkPassphrase||null,this.sorobanData=r.sorobanData?new Oo(r.sorobanData).build():null}return function(e,t,r){return t&&Fo(e.prototype,t),r&&Fo(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(e,[{key:"addOperation",value:function(e){return this.operations.push(e),this}},{key:"addOperationAt",value:function(e,t){return this.operations.splice(t,0,e),this}},{key:"clearOperations",value:function(){return this.operations=[],this}},{key:"clearOperationAt",value:function(e){return this.operations.splice(e,1),this}},{key:"addMemo",value:function(e){return this.memo=e,this}},{key:"setTimeout",value:function(e){if(null!==this.timebounds&&this.timebounds.maxTime>0)throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");if(e<0)throw new Error("timeout cannot be negative");if(e>0){var t=Math.floor(Date.now()/1e3)+e;null===this.timebounds?this.timebounds={minTime:0,maxTime:t}:this.timebounds={minTime:this.timebounds.minTime,maxTime:t}}else this.timebounds={minTime:0,maxTime:0};return this}},{key:"setTimebounds",value:function(e,t){if("number"==typeof e&&(e=new Date(1e3*e)),"number"==typeof t&&(t=new Date(1e3*t)),null!==this.timebounds)throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");var r=Math.floor(e.valueOf()/1e3),n=Math.floor(t.valueOf()/1e3);if(r<0)throw new Error("min_time cannot be negative");if(n<0)throw new Error("max_time cannot be negative");if(n>0&&r>n)throw new Error("min_time cannot be greater than max_time");return this.timebounds={minTime:r,maxTime:n},this}},{key:"setLedgerbounds",value:function(e,t){if(null!==this.ledgerbounds)throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");if(e<0)throw new Error("min_ledger cannot be negative");if(t<0)throw new Error("max_ledger cannot be negative");if(t>0&&e>t)throw new Error("min_ledger cannot be greater than max_ledger");return this.ledgerbounds={minLedger:e,maxLedger:t},this}},{key:"setMinAccountSequence",value:function(e){if(null!==this.minAccountSequence)throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");return this.minAccountSequence=e,this}},{key:"setMinAccountSequenceAge",value:function(e){if("number"!=typeof e)throw new Error("min_account_sequence_age must be a number");if(null!==this.minAccountSequenceAge)throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");if(e<0)throw new Error("min_account_sequence_age cannot be negative");return this.minAccountSequenceAge=e,this}},{key:"setMinAccountSequenceLedgerGap",value:function(e){if(null!==this.minAccountSequenceLedgerGap)throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");if(e<0)throw new Error("min_account_sequence_ledger_gap cannot be negative");return this.minAccountSequenceLedgerGap=e,this}},{key:"setExtraSigners",value:function(e){if(!Array.isArray(e))throw new Error("extra_signers must be an array of strings.");if(null!==this.extraSigners)throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");if(e.length>2)throw new Error("extra_signers cannot be longer than 2 elements.");return this.extraSigners=Ro(e),this}},{key:"setNetworkPassphrase",value:function(e){return this.networkPassphrase=e,this}},{key:"setSorobanData",value:function(e){return this.sorobanData=new Oo(e).build(),this}},{key:"build",value:function(){var e=new zr(this.source.sequenceNumber()).plus(1),t={fee:new zr(this.baseFee).times(this.operations.length).toNumber(),seqNum:i.SequenceNumber.fromString(e.toString()),memo:this.memo?this.memo.toXDRObject():null};if(null===this.timebounds||void 0===this.timebounds.minTime||void 0===this.timebounds.maxTime)throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");qo(this.timebounds.minTime)&&(this.timebounds.minTime=this.timebounds.minTime.getTime()/1e3),qo(this.timebounds.maxTime)&&(this.timebounds.maxTime=this.timebounds.maxTime.getTime()/1e3),this.timebounds.minTime=n.UnsignedHyper.fromString(this.timebounds.minTime.toString()),this.timebounds.maxTime=n.UnsignedHyper.fromString(this.timebounds.maxTime.toString());var r=new i.TimeBounds(this.timebounds);if(this.hasV2Preconditions()){var o=null;null!==this.ledgerbounds&&(o=new i.LedgerBounds(this.ledgerbounds));var a=this.minAccountSequence||"0";a=i.SequenceNumber.fromString(a);var s=n.UnsignedHyper.fromString(null!==this.minAccountSequenceAge?this.minAccountSequenceAge.toString():"0"),u=this.minAccountSequenceLedgerGap||0,c=null!==this.extraSigners?this.extraSigners.map(Io.decodeAddress):[];t.cond=i.Preconditions.precondV2(new i.PreconditionsV2({timeBounds:r,ledgerBounds:o,minSeqNum:a,minSeqAge:s,minSeqLedgerGap:u,extraSigners:c}))}else t.cond=i.Preconditions.precondTime(r);t.sourceAccount=pn(this.source.accountId()),this.sorobanData?t.ext=new i.TransactionExt(1,this.sorobanData):t.ext=new i.TransactionExt(0,i.Void);var l=new i.Transaction(t);l.operations(this.operations);var f=new i.TransactionEnvelope.envelopeTypeTx(new i.TransactionV1Envelope({tx:l})),p=new oo(f,this.networkPassphrase);return this.source.incrementSequenceNumber(),p}},{key:"hasV2Preconditions",value:function(){return null!==this.ledgerbounds||null!==this.minAccountSequence||null!==this.minAccountSequenceAge||null!==this.minAccountSequenceLedgerGap||null!==this.extraSigners&&this.extraSigners.length>0}}],[{key:"cloneFrom",value:function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!(t instanceof oo))throw new TypeError("expected a 'Transaction', got: ".concat(t));var n,o=(BigInt(t.sequence)-1n).toString();if(tr.isValidMed25519PublicKey(t.source))n=Eo.fromAddress(t.source,o);else{if(!tr.isValidEd25519PublicKey(t.source))throw new TypeError("unsupported tx source account: ".concat(t.source));n=new vo(t.source,o)}var i=new e(n,No({fee:(parseInt(t.fee,10)/t.operations.length||Mo).toString(),memo:t.memo,networkPassphrase:t.networkPassphrase,timebounds:t.timeBounds,ledgerbounds:t.ledgerBounds,minAccountSequence:t.minAccountSequence,minAccountSequenceAge:t.minAccountSequenceAge,minAccountSequenceLedgerGap:t.minAccountSequenceLedgerGap,extraSigners:t.extraSigners},r));return t._tx.operations().forEach(function(e){return i.addOperation(e)}),i}},{key:"buildFeeBumpTransaction",value:function(e,t,r,n){var o=r.operations.length,a=new zr(r.fee).div(o),s=new zr(t);if(s.lt(a))throw new Error("Invalid baseFee, it should be at least ".concat(a," stroops."));var u=new zr(Mo);if(s.lt(u))throw new Error("Invalid baseFee, it should be at least ".concat(u," stroops."));var c,l=r.toEnvelope();if(l.switch()===i.EnvelopeType.envelopeTypeTxV0()){var f=l.v0().tx(),p=new i.Transaction({sourceAccount:new i.MuxedAccount.keyTypeEd25519(f.sourceAccountEd25519()),fee:f.fee(),seqNum:f.seqNum(),cond:i.Preconditions.precondTime(f.timeBounds()),memo:f.memo(),operations:f.operations(),ext:new i.TransactionExt(0)});l=new i.TransactionEnvelope.envelopeTypeTx(new i.TransactionV1Envelope({tx:p,signatures:l.v0().signatures()}))}c="string"==typeof e?pn(e):e.xdrMuxedAccount();var d=new i.FeeBumpTransaction({feeSource:c,fee:i.Int64.fromString(s.times(o+1).toString()),innerTx:i.FeeBumpTransactionInnerTx.envelopeTypeTx(l.v1()),ext:new i.FeeBumpTransactionExt(0)}),h=new i.FeeBumpTransactionEnvelope({tx:d,signatures:[]}),y=new i.TransactionEnvelope.envelopeTypeTxFeeBump(h);return new ho(y,n)}},{key:"fromXDR",value:function(e,t){return"string"==typeof e&&(e=i.TransactionEnvelope.fromXDR(e,"base64")),e.switch()===i.EnvelopeType.envelopeTypeTxFeeBump()?new ho(e,t):new oo(e,t)}}])}();function qo(e){return e instanceof Date&&!isNaN(e)}var Ko={PUBLIC:"Public Global Stellar Network ; September 2015",TESTNET:"Test SDF Network ; September 2015",FUTURENET:"Test SDF Future Network ; October 2022",SANDBOX:"Local Sandbox Stellar Network ; September 2022",STANDALONE:"Standalone Network ; February 2017"};function Ho(e){return Ho="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Ho(e)}function zo(e){return function(e){if(Array.isArray(e))return e}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(e){if("string"==typeof e)return Xo(e,t);var r={}.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Xo(e,t):void 0}}(e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Xo(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n}function $o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Go(n.key),n)}}function Go(e){var t=function(e,t){if("object"!=Ho(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Ho(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Ho(t)?t:t+""}var Wo=function(){return function(e,t,r){return t&&$o(e.prototype,t),r&&$o(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)},null,[{key:"formatTokenAmount",value:function(e,t){if(e.includes("."))throw new TypeError("No decimals are allowed");var r=e;return t>0&&(r=t>r.length?["0",r.toString().padStart(t,"0")].join("."):[r.slice(0,-t),r.slice(-t)].join(".")),r.replace(/(\.\d*?)0+$/,"$1")}},{key:"parseTokenAmount",value:function(e,t){var r,n=zo(e.split(".").slice()),o=n[0],i=n[1];if(n.slice(2).length)throw new Error("Invalid decimal value: ".concat(e));return BigInt(o+(null!==(r=null==i?void 0:i.padEnd(t,"0"))&&void 0!==r?r:"0".repeat(t))).toString()}}])}();function Yo(e){return Yo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Yo(e)}function Zo(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Jo(n.key),n)}}function Jo(e){var t=function(e,t){if("object"!=Yo(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Yo(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Yo(t)?t:t+""}var Qo=function(){return function(e,t,r){return t&&Zo(e.prototype,t),r&&Zo(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e);try{this._id=tr.decodeContract(t)}catch(e){throw new Error("Invalid contract ID: ".concat(t))}},[{key:"contractId",value:function(){return tr.encodeContract(this._id)}},{key:"toString",value:function(){return this.contractId()}},{key:"address",value:function(){return On.contract(this._id)}},{key:"call",value:function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return jn.invokeContractFunction({contract:this.address().toString(),function:e,args:r})}},{key:"getFootprint",value:function(){return i.LedgerKey.contractData(new i.LedgerKeyContractData({contract:this.address().toScAddress(),key:i.ScVal.scvLedgerKeyContractInstance(),durability:i.ContractDataDurability.persistent()}))}}])}();function ei(e){return ei="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ei(e)}function ti(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,ri(n.key),n)}}function ri(e){var t=function(e,t){if("object"!=ei(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=ei(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==ei(t)?t:t+""}function ni(e,t,r){return t=ii(t),function(e,t){if(t&&("object"==ei(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,oi()?Reflect.construct(t,r||[],ii(e).constructor):t.apply(e,r))}function oi(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(oi=function(){return!!e})()}function ii(e){return ii=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},ii(e)}function ai(e,t){return ai=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},ai(e,t)}var si=function(e){function t(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return ni(this,t,[r])}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&ai(e,t)}(t,e),function(e,t,r){return t&&ti(e.prototype,t),r&&ti(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(t,[{key:"unsigned",get:function(){return!0}},{key:"size",get:function(){return 128}}])}(n.LargeInt);function ui(e){return ui="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ui(e)}function ci(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,li(n.key),n)}}function li(e){var t=function(e,t){if("object"!=ui(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=ui(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==ui(t)?t:t+""}function fi(e,t,r){return t=di(t),function(e,t){if(t&&("object"==ui(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,pi()?Reflect.construct(t,r||[],di(e).constructor):t.apply(e,r))}function pi(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(pi=function(){return!!e})()}function di(e){return di=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},di(e)}function hi(e,t){return hi=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},hi(e,t)}si.defineIntBoundaries();var yi=function(e){function t(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return fi(this,t,[r])}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&hi(e,t)}(t,e),function(e,t,r){return t&&ci(e.prototype,t),r&&ci(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(t,[{key:"unsigned",get:function(){return!0}},{key:"size",get:function(){return 256}}])}(n.LargeInt);function mi(e){return mi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},mi(e)}function gi(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,vi(n.key),n)}}function vi(e){var t=function(e,t){if("object"!=mi(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=mi(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==mi(t)?t:t+""}function bi(e,t,r){return t=Si(t),function(e,t){if(t&&("object"==mi(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,wi()?Reflect.construct(t,r||[],Si(e).constructor):t.apply(e,r))}function wi(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(wi=function(){return!!e})()}function Si(e){return Si=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},Si(e)}function Ei(e,t){return Ei=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},Ei(e,t)}yi.defineIntBoundaries();var ki=function(e){function t(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return bi(this,t,[r])}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&Ei(e,t)}(t,e),function(e,t,r){return t&&gi(e.prototype,t),r&&gi(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(t,[{key:"unsigned",get:function(){return!1}},{key:"size",get:function(){return 128}}])}(n.LargeInt);function Ai(e){return Ai="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Ai(e)}function Ti(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Oi(n.key),n)}}function Oi(e){var t=function(e,t){if("object"!=Ai(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Ai(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Ai(t)?t:t+""}function xi(e,t,r){return t=Bi(t),function(e,t){if(t&&("object"==Ai(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,Pi()?Reflect.construct(t,r||[],Bi(e).constructor):t.apply(e,r))}function Pi(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(Pi=function(){return!!e})()}function Bi(e){return Bi=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},Bi(e)}function Ii(e,t){return Ii=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},Ii(e,t)}ki.defineIntBoundaries();var Ci=function(e){function t(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return xi(this,t,[r])}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&Ii(e,t)}(t,e),function(e,t,r){return t&&Ti(e.prototype,t),r&&Ti(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(t,[{key:"unsigned",get:function(){return!1}},{key:"size",get:function(){return 256}}])}(n.LargeInt);function Ri(e){return Ri="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Ri(e)}function _i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Ni(n.key),n)}}function Ui(e,t,r){return(t=Ni(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function Ni(e){var t=function(e,t){if("object"!=Ri(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Ri(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Ri(t)?t:t+""}Ci.defineIntBoundaries();var Li=function(){return function(e,t,r){return t&&_i(e.prototype,t),r&&_i(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(function e(t,r){switch(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),Ui(this,"int",void 0),Ui(this,"type",void 0),r instanceof Array||(r=[r]),r=r.map(function(e){return"bigint"==typeof e?e:"function"==typeof e.toBigInt?e.toBigInt():BigInt(e)}),t){case"i64":this.int=new n.Hyper(r);break;case"i128":this.int=new ki(r);break;case"i256":this.int=new Ci(r);break;case"u64":this.int=new n.UnsignedHyper(r);break;case"u128":this.int=new si(r);break;case"u256":this.int=new yi(r);break;default:throw TypeError("invalid type: ".concat(t))}this.type=t},[{key:"toNumber",value:function(){var e=this.int.toBigInt();if(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)throw RangeError("value ".concat(e," not in range for Number ")+"[".concat(Number.MAX_SAFE_INTEGER,", ").concat(Number.MIN_SAFE_INTEGER,"]"));return Number(e)}},{key:"toBigInt",value:function(){return this.int.toBigInt()}},{key:"toI64",value:function(){this._sizeCheck(64);var e=this.toBigInt();if(BigInt.asIntN(64,e)!==e)throw RangeError("value too large for i64: ".concat(e));return i.ScVal.scvI64(new i.Int64(e))}},{key:"toU64",value:function(){return this._sizeCheck(64),i.ScVal.scvU64(new i.Uint64(BigInt.asUintN(64,this.toBigInt())))}},{key:"toI128",value:function(){this._sizeCheck(128);var e=this.int.toBigInt(),t=BigInt.asIntN(64,e>>64n),r=BigInt.asUintN(64,e);return i.ScVal.scvI128(new i.Int128Parts({hi:new i.Int64(t),lo:new i.Uint64(r)}))}},{key:"toU128",value:function(){this._sizeCheck(128);var e=this.int.toBigInt();return i.ScVal.scvU128(new i.UInt128Parts({hi:new i.Uint64(BigInt.asUintN(64,e>>64n)),lo:new i.Uint64(BigInt.asUintN(64,e))}))}},{key:"toI256",value:function(){var e=this.int.toBigInt(),t=BigInt.asIntN(64,e>>192n),r=BigInt.asUintN(64,e>>128n),n=BigInt.asUintN(64,e>>64n),o=BigInt.asUintN(64,e);return i.ScVal.scvI256(new i.Int256Parts({hiHi:new i.Int64(t),hiLo:new i.Uint64(r),loHi:new i.Uint64(n),loLo:new i.Uint64(o)}))}},{key:"toU256",value:function(){var e=this.int.toBigInt(),t=BigInt.asUintN(64,e>>192n),r=BigInt.asUintN(64,e>>128n),n=BigInt.asUintN(64,e>>64n),o=BigInt.asUintN(64,e);return i.ScVal.scvU256(new i.UInt256Parts({hiHi:new i.Uint64(t),hiLo:new i.Uint64(r),loHi:new i.Uint64(n),loLo:new i.Uint64(o)}))}},{key:"toScVal",value:function(){switch(this.type){case"i64":return this.toI64();case"i128":return this.toI128();case"i256":return this.toI256();case"u64":return this.toU64();case"u128":return this.toU128();case"u256":return this.toU256();default:throw TypeError("invalid type: ".concat(this.type))}}},{key:"valueOf",value:function(){return this.int.valueOf()}},{key:"toString",value:function(){return this.int.toString()}},{key:"toJSON",value:function(){return{value:this.toBigInt().toString(),type:this.type}}},{key:"_sizeCheck",value:function(e){if(this.int.size>e)throw RangeError("value too large for ".concat(e," bits (").concat(this.type,")"))}}],[{key:"isType",value:function(e){switch(e){case"i64":case"i128":case"i256":case"u64":case"u128":case"u256":return!0;default:return!1}}},{key:"getType",value:function(e){return e.slice(3).toLowerCase()}}])}();function Fi(e){return Fi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Fi(e)}function ji(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Mi(n.key),n)}}function Mi(e){var t=function(e,t){if("object"!=Fi(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Fi(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Fi(t)?t:t+""}function Di(e,t,r){return t=qi(t),function(e,t){if(t&&("object"==Fi(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(e,Vi()?Reflect.construct(t,r||[],qi(e).constructor):t.apply(e,r))}function Vi(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(e){}return(Vi=function(){return!!e})()}function qi(e){return qi=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},qi(e)}function Ki(e,t){return Ki=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},Ki(e,t)}var Hi=function(e){function t(e,r){var n;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);var o=e<0,i=null!==(n=null==r?void 0:r.type)&&void 0!==n?n:"";if(i.startsWith("u")&&o)throw TypeError("specified type ".concat(r.type," yet negative (").concat(e,")"));if(""===i){i=o?"i":"u";var a=function(e){var t,r=e.toString(2).length;return null!==(t=[64,128,256].find(function(e){return r<=e}))&&void 0!==t?t:r}(e);switch(a){case 64:case 128:case 256:i+=a.toString();break;default:throw RangeError("expected 64/128/256 bits for input (".concat(e,"), got ").concat(a))}}return Di(this,t,[i,e])}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&Ki(e,t)}(t,e),function(e,t,r){return t&&ji(e.prototype,t),r&&ji(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}(t)}(Li);function zi(e){var t=Li.getType(e.switch().name);switch(e.switch().name){case"scvU32":case"scvI32":return BigInt(e.value());case"scvU64":case"scvI64":return new Li(t,e.value()).toBigInt();case"scvU128":case"scvI128":return new Li(t,[e.value().lo(),e.value().hi()]).toBigInt();case"scvU256":case"scvI256":return new Li(t,[e.value().loLo(),e.value().loHi(),e.value().hiLo(),e.value().hiHi()]).toBigInt();default:throw TypeError("expected integer type, got ".concat(e.switch()))}}var Xi=r(8287).Buffer;function $i(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,o,i,a,s=[],u=!0,c=!1;try{if(i=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;u=!1}else for(;!(u=(n=i.call(r)).done)&&(s.push(n.value),s.length!==t);u=!0);}catch(e){c=!0,o=e}finally{try{if(!u&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw o}}return s}}(e,t)||function(e,t){if(e){if("string"==typeof e)return Gi(e,t);var r={}.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Gi(e,t):void 0}}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Gi(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n}function Wi(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function Yi(e,t,r){return(t=function(e){var t=function(e,t){if("object"!=Zi(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=Zi(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==Zi(t)?t:t+""}(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function Zi(e){return Zi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Zi(e)}function Ji(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};switch(Zi(e)){case"object":var r,n,o;if(null===e)return i.ScVal.scvVoid();if(e instanceof i.ScVal)return e;if(e instanceof On)return e.toScVal();if(e instanceof lr)return Ji(e.publicKey(),{type:"address"});if(e instanceof Qo)return e.address().toScVal();if(e instanceof Uint8Array||Xi.isBuffer(e)){var a,s=Uint8Array.from(e);switch(null!==(a=null==t?void 0:t.type)&&void 0!==a?a:"bytes"){case"bytes":return i.ScVal.scvBytes(s);case"symbol":return i.ScVal.scvSymbol(s);case"string":return i.ScVal.scvString(s);default:throw new TypeError("invalid type (".concat(t.type,") specified for bytes-like value"))}}if(Array.isArray(e))return i.ScVal.scvVec(e.map(function(e,r){return Array.isArray(t.type)?Ji(e,function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Wi(Object(r),!0).forEach(function(t){Yi(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Wi(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}({},t.type.length>r&&{type:t.type[r]})):Ji(e,t)}));if("Object"!==(null!==(r=null===(n=e.constructor)||void 0===n?void 0:n.name)&&void 0!==r?r:""))throw new TypeError("cannot interpret ".concat(null===(o=e.constructor)||void 0===o?void 0:o.name," value as ScVal (").concat(JSON.stringify(e),")"));return i.ScVal.scvMap(Object.entries(e).sort(function(e,t){var r=$i(e,1)[0],n=$i(t,1)[0];return r.localeCompare(n)}).map(function(e){var r,n,o=$i(e,2),a=o[0],s=o[1],u=$i(null!==(r=(null!==(n=null==t?void 0:t.type)&&void 0!==n?n:{})[a])&&void 0!==r?r:[null,null],2),c=u[0],l=u[1],f=c?{type:c}:{},p=l?{type:l}:{};return new i.ScMapEntry({key:Ji(a,f),val:Ji(s,p)})}));case"number":case"bigint":switch(null==t?void 0:t.type){case"u32":return i.ScVal.scvU32(e);case"i32":return i.ScVal.scvI32(e)}return new Hi(e,{type:null==t?void 0:t.type}).toScVal();case"string":var u,c=null!==(u=null==t?void 0:t.type)&&void 0!==u?u:"string";switch(c){case"string":return i.ScVal.scvString(e);case"symbol":return i.ScVal.scvSymbol(e);case"address":return new On(e).toScVal();case"u32":return i.ScVal.scvU32(parseInt(e,10));case"i32":return i.ScVal.scvI32(parseInt(e,10));default:if(Li.isType(c))return new Li(c,e).toScVal();throw new TypeError("invalid type (".concat(t.type,") specified for string value"))}case"boolean":return i.ScVal.scvBool(e);case"undefined":return i.ScVal.scvVoid();case"function":return Ji(e());default:throw new TypeError("failed to convert typeof ".concat(Zi(e)," (").concat(e,")"))}}function Qi(e){var t,r;switch(e.switch().value){case i.ScValType.scvVoid().value:return null;case i.ScValType.scvU64().value:case i.ScValType.scvI64().value:return e.value().toBigInt();case i.ScValType.scvU128().value:case i.ScValType.scvI128().value:case i.ScValType.scvU256().value:case i.ScValType.scvI256().value:return zi(e);case i.ScValType.scvVec().value:return(null!==(t=e.vec())&&void 0!==t?t:[]).map(Qi);case i.ScValType.scvAddress().value:return On.fromScVal(e).toString();case i.ScValType.scvMap().value:return Object.fromEntries((null!==(r=e.map())&&void 0!==r?r:[]).map(function(e){return[Qi(e.key()),Qi(e.val())]}));case i.ScValType.scvBool().value:case i.ScValType.scvU32().value:case i.ScValType.scvI32().value:case i.ScValType.scvBytes().value:return e.value();case i.ScValType.scvSymbol().value:case i.ScValType.scvString().value:var n=e.value();if(Xi.isBuffer(n)||ArrayBuffer.isView(n))try{return(new TextDecoder).decode(n)}catch(e){return new Uint8Array(n.buffer)}return n;case i.ScValType.scvTimepoint().value:case i.ScValType.scvDuration().value:return new i.Uint64(e.value()).toBigInt();case i.ScValType.scvError().value:if(e.error().switch().value===i.ScErrorType.sceContract().value)return{type:"contract",code:e.error().contractCode()};var o=e.error();return{type:"system",code:o.code().value,value:o.code().name};default:return e.value()}}function ea(e){return ea="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},ea(e)}function ta(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function ra(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?ta(Object(r),!0).forEach(function(t){na(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):ta(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function na(e,t,r){return(t=function(e){var t=function(e,t){if("object"!=ea(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=ea(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==ea(t)?t:t+""}(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function oa(e){return e.map(function(e){return e.inSuccessfulContractCall?ia(e.event()):ia(e)})}function ia(e){return ra(ra({},"function"==typeof e.contractId&&null!=e.contractId()&&{contractId:tr.encodeContract(e.contractId())}),{},{type:e.type().name,topics:e.body().value().topics().map(function(e){return Qi(e)}),data:Qi(e.body().value().data())})}i.scvSortedMap=function(e){var t=Array.from(e).sort(function(e,t){var r=Qi(e.key()),n=Qi(t.key());switch(Zi(r)){case"number":case"bigint":return r<n?-1:1;default:return r.toString().localeCompare(n.toString())}});return i.ScVal.scvMap(t)};var aa=r(8287).Buffer;function sa(){var e,t,r="function"==typeof Symbol?Symbol:{},n=r.iterator||"@@iterator",o=r.toStringTag||"@@toStringTag";function i(r,n,o,i){var u=n&&n.prototype instanceof s?n:s,c=Object.create(u.prototype);return ua(c,"_invoke",function(r,n,o){var i,s,u,c=0,l=o||[],f=!1,p={p:0,n:0,v:e,a:d,f:d.bind(e,4),d:function(t,r){return i=t,s=0,u=e,p.n=r,a}};function d(r,n){for(s=r,u=n,t=0;!f&&c&&!o&&t<l.length;t++){var o,i=l[t],d=p.p,h=i[2];r>3?(o=h===n)&&(u=i[(s=i[4])?5:(s=3,3)],i[4]=i[5]=e):i[0]<=d&&((o=r<2&&d<i[1])?(s=0,p.v=n,p.n=i[1]):d<h&&(o=r<3||i[0]>n||n>h)&&(i[4]=r,i[5]=n,p.n=h,s=0))}if(o||r>1)return a;throw f=!0,n}return function(o,l,h){if(c>1)throw TypeError("Generator is already running");for(f&&1===l&&d(l,h),s=l,u=h;(t=s<2?e:u)||!f;){i||(s?s<3?(s>1&&(p.n=-1),d(s,u)):p.n=u:p.v=u);try{if(c=2,i){if(s||(o="next"),t=i[o]){if(!(t=t.call(i,u)))throw TypeError("iterator result is not an object");if(!t.done)return t;u=t.value,s<2&&(s=0)}else 1===s&&(t=i.return)&&t.call(i),s<2&&(u=TypeError("The iterator does not provide a '"+o+"' method"),s=1);i=e}else if((t=(f=p.n<0)?u:r.call(n,p))!==a)break}catch(t){i=e,s=1,u=t}finally{c=1}}return{value:t,done:f}}}(r,o,i),!0),c}var a={};function s(){}function u(){}function c(){}t=Object.getPrototypeOf;var l=[][n]?t(t([][n]())):(ua(t={},n,function(){return this}),t),f=c.prototype=s.prototype=Object.create(l);function p(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,c):(e.__proto__=c,ua(e,o,"GeneratorFunction")),e.prototype=Object.create(f),e}return u.prototype=c,ua(f,"constructor",c),ua(c,"constructor",u),u.displayName="GeneratorFunction",ua(c,o,"GeneratorFunction"),ua(f),ua(f,o,"Generator"),ua(f,n,function(){return this}),ua(f,"toString",function(){return"[object Generator]"}),(sa=function(){return{w:i,m:p}})()}function ua(e,t,r,n){var o=Object.defineProperty;try{o({},"",{})}catch(e){o=0}ua=function(e,t,r,n){function i(t,r){ua(e,t,function(e){return this._invoke(t,r,e)})}t?o?o(e,t,{value:r,enumerable:!n,configurable:!n,writable:!n}):e[t]=r:(i("next",0),i("throw",1),i("return",2))},ua(e,t,r,n)}function ca(e,t,r,n,o,i,a){try{var s=e[i](a),u=s.value}catch(e){return void r(e)}s.done?t(u):Promise.resolve(u).then(n,o)}function la(e,t,r){return fa.apply(this,arguments)}function fa(){var e;return e=sa().m(function e(t,r,n){var o,a,s,c,l,f,p,d,h,y,m=arguments;return sa().w(function(e){for(;;)switch(e.n){case 0:if(o=m.length>3&&void 0!==m[3]?m[3]:Ko.FUTURENET,t.credentials().switch().value===i.SorobanCredentialsType.sorobanCredentialsAddress().value){e.n=1;break}return e.a(2,t);case 1:if(a=i.SorobanAuthorizationEntry.fromXDR(t.toXDR()),(s=a.credentials().address()).signatureExpirationLedger(n),c=u(aa.from(o)),l=i.HashIdPreimage.envelopeTypeSorobanAuthorization(new i.HashIdPreimageSorobanAuthorization({networkId:c,nonce:s.nonce(),invocation:a.rootInvocation(),signatureExpirationLedger:s.signatureExpirationLedger()})),f=u(l.toXDR()),"function"!=typeof r){e.n=3;break}return e.n=2,r(l);case 2:null!=(h=e.v)&&h.signature?(p=aa.from(h.signature),d=h.publicKey):(p=aa.from(h),d=On.fromScAddress(s.address()).toString()),e.n=4;break;case 3:p=aa.from(r.sign(f)),d=r.publicKey();case 4:if(lr.fromPublicKey(d).verify(f,p)){e.n=5;break}throw new Error("signature doesn't match payload");case 5:return y=Ji({public_key:tr.decodeEd25519PublicKey(d),signature:p},{type:{public_key:["symbol",null],signature:["symbol",null]}}),s.signature(i.ScVal.scvVec([y])),e.a(2,a)}},e)}),fa=function(){var t=this,r=arguments;return new Promise(function(n,o){var i=e.apply(t,r);function a(e){ca(i,n,o,a,s,"next",e)}function s(e){ca(i,n,o,a,s,"throw",e)}a(void 0)})},fa.apply(this,arguments)}function pa(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"",o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ko.FUTURENET,a=lr.random().rawPublicKey(),s=new i.Int64(a.subarray(0,8).reduce(function(e,t){return e<<8|t},0)),u=n||e.publicKey();if(!u)throw new Error("authorizeInvocation requires publicKey parameter");return la(new i.SorobanAuthorizationEntry({rootInvocation:r,credentials:i.SorobanCredentials.sorobanCredentialsAddress(new i.SorobanAddressCredentials({address:new On(u).toScAddress(),nonce:s,signatureExpirationLedger:0,signature:i.ScVal.scvVec([])}))}),e,t,o)}function da(e){return da="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},da(e)}function ha(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function ya(e,t,r){return(t=function(e){var t=function(e,t){if("object"!=da(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=da(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==da(t)?t:t+""}(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function ma(e){var t=e.function(),r={},n=t.value();switch(t.switch().value){case 0:r.type="execute",r.args={source:On.fromScAddress(n.contractAddress()).toString(),function:n.functionName(),args:n.args().map(function(e){return Qi(e)})};break;case 1:case 2:var o=2===t.switch().value;r.type="create",r.args={};var i=[n.executable(),n.contractIdPreimage()],a=i[0],s=i[1];if(!!a.switch().value!=!!s.switch().value)throw new Error("creation function appears invalid: ".concat(JSON.stringify(n)," (should be wasm+address or token+asset)"));switch(a.switch().value){case 0:var u=s.fromAddress();r.args.type="wasm",r.args.wasm=function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?ha(Object(r),!0).forEach(function(t){ya(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):ha(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}({salt:u.salt().toString("hex"),hash:a.wasmHash().toString("hex"),address:On.fromScAddress(u.address()).toString()},o&&{constructorArgs:n.constructorArgs().map(function(e){return Qi(e)})});break;case 1:r.args.type="sac",r.args.asset=yr.fromOperation(s.fromAsset()).toString();break;default:throw new Error("unknown creation type: ".concat(JSON.stringify(a)))}break;default:throw new Error("unknown invocation type (".concat(t.switch(),"): ").concat(JSON.stringify(t)))}return r.invocations=e.subInvocations().map(function(e){return ma(e)}),r}function ga(e,t){va(e,1,t)}function va(e,t,r,n){!1!==r(e,t,n)&&e.subInvocations().forEach(function(n){return va(n,t+1,r,e)})}const ba=(e=r.hmd(e)).exports},453:(e,t,r)=>{"use strict";var n,o=r(9612),i=r(9383),a=r(1237),s=r(9290),u=r(9538),c=r(8068),l=r(9675),f=r(5345),p=r(1514),d=r(8968),h=r(6188),y=r(8002),m=r(5880),g=r(414),v=r(3093),b=Function,w=function(e){try{return b('"use strict"; return ('+e+").constructor;")()}catch(e){}},S=r(5795),E=r(655),k=function(){throw new l},A=S?function(){try{return k}catch(e){try{return S(arguments,"callee").get}catch(e){return k}}}():k,T=r(4039)(),O=r(3628),x=r(1064),P=r(8648),B=r(1002),I=r(76),C={},R="undefined"!=typeof Uint8Array&&O?O(Uint8Array):n,_={__proto__:null,"%AggregateError%":"undefined"==typeof AggregateError?n:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?n:ArrayBuffer,"%ArrayIteratorPrototype%":T&&O?O([][Symbol.iterator]()):n,"%AsyncFromSyncIteratorPrototype%":n,"%AsyncFunction%":C,"%AsyncGenerator%":C,"%AsyncGeneratorFunction%":C,"%AsyncIteratorPrototype%":C,"%Atomics%":"undefined"==typeof Atomics?n:Atomics,"%BigInt%":"undefined"==typeof BigInt?n:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?n:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?n:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?n:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":i,"%eval%":eval,"%EvalError%":a,"%Float16Array%":"undefined"==typeof Float16Array?n:Float16Array,"%Float32Array%":"undefined"==typeof Float32Array?n:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?n:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?n:FinalizationRegistry,"%Function%":b,"%GeneratorFunction%":C,"%Int8Array%":"undefined"==typeof Int8Array?n:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?n:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?n:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":T&&O?O(O([][Symbol.iterator]())):n,"%JSON%":"object"==typeof JSON?JSON:n,"%Map%":"undefined"==typeof Map?n:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&T&&O?O((new Map)[Symbol.iterator]()):n,"%Math%":Math,"%Number%":Number,"%Object%":o,"%Object.getOwnPropertyDescriptor%":S,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?n:Promise,"%Proxy%":"undefined"==typeof Proxy?n:Proxy,"%RangeError%":s,"%ReferenceError%":u,"%Reflect%":"undefined"==typeof Reflect?n:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?n:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&T&&O?O((new Set)[Symbol.iterator]()):n,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?n:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":T&&O?O(""[Symbol.iterator]()):n,"%Symbol%":T?Symbol:n,"%SyntaxError%":c,"%ThrowTypeError%":A,"%TypedArray%":R,"%TypeError%":l,"%Uint8Array%":"undefined"==typeof Uint8Array?n:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?n:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?n:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?n:Uint32Array,"%URIError%":f,"%WeakMap%":"undefined"==typeof WeakMap?n:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?n:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?n:WeakSet,"%Function.prototype.call%":I,"%Function.prototype.apply%":B,"%Object.defineProperty%":E,"%Object.getPrototypeOf%":x,"%Math.abs%":p,"%Math.floor%":d,"%Math.max%":h,"%Math.min%":y,"%Math.pow%":m,"%Math.round%":g,"%Math.sign%":v,"%Reflect.getPrototypeOf%":P};if(O)try{null.error}catch(e){var U=O(O(e));_["%Error.prototype%"]=U}var N=function e(t){var r;if("%AsyncFunction%"===t)r=w("async function () {}");else if("%GeneratorFunction%"===t)r=w("function* () {}");else if("%AsyncGeneratorFunction%"===t)r=w("async function* () {}");else if("%AsyncGenerator%"===t){var n=e("%AsyncGeneratorFunction%");n&&(r=n.prototype)}else if("%AsyncIteratorPrototype%"===t){var o=e("%AsyncGenerator%");o&&O&&(r=O(o.prototype))}return _[t]=r,r},L={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},F=r(6743),j=r(9957),M=F.call(I,Array.prototype.concat),D=F.call(B,Array.prototype.splice),V=F.call(I,String.prototype.replace),q=F.call(I,String.prototype.slice),K=F.call(I,RegExp.prototype.exec),H=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,z=/\\(\\)?/g,X=function(e,t){var r,n=e;if(j(L,n)&&(n="%"+(r=L[n])[0]+"%"),j(_,n)){var o=_[n];if(o===C&&(o=N(n)),void 0===o&&!t)throw new l("intrinsic "+e+" exists, but is not available. Please file an issue!");return{alias:r,name:n,value:o}}throw new c("intrinsic "+e+" does not exist!")};e.exports=function(e,t){if("string"!=typeof e||0===e.length)throw new l("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof t)throw new l('"allowMissing" argument must be a boolean');if(null===K(/^%?[^%]*%?$/,e))throw new c("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var r=function(e){var t=q(e,0,1),r=q(e,-1);if("%"===t&&"%"!==r)throw new c("invalid intrinsic syntax, expected closing `%`");if("%"===r&&"%"!==t)throw new c("invalid intrinsic syntax, expected opening `%`");var n=[];return V(e,H,function(e,t,r,o){n[n.length]=r?V(o,z,"$1"):t||e}),n}(e),n=r.length>0?r[0]:"",o=X("%"+n+"%",t),i=o.name,a=o.value,s=!1,u=o.alias;u&&(n=u[0],D(r,M([0,1],u)));for(var f=1,p=!0;f<r.length;f+=1){var d=r[f],h=q(d,0,1),y=q(d,-1);if(('"'===h||"'"===h||"`"===h||'"'===y||"'"===y||"`"===y)&&h!==y)throw new c("property names with quotes must have matching quotes");if("constructor"!==d&&p||(s=!0),j(_,i="%"+(n+="."+d)+"%"))a=_[i];else if(null!=a){if(!(d in a)){if(!t)throw new l("base intrinsic for "+e+" exists, but the property is not available.");return}if(S&&f+1>=r.length){var m=S(a,d);a=(p=!!m)&&"get"in m&&!("originalValue"in m.get)?m.get:a[d]}else p=j(a,d),a=a[d];p&&!s&&(_[i]=a)}}return a}},487:(e,t,r)=>{"use strict";var n=r(6897),o=r(655),i=r(3126),a=r(2205);e.exports=function(e){var t=i(arguments),r=e.length-(arguments.length-1);return n(t,1+(r>0?r:0),!0)},o?o(e.exports,"apply",{value:a}):e.exports.apply=a},537:(e,t,r)=>{var n=r(5606),o=r(6763),i=Object.getOwnPropertyDescriptors||function(e){for(var t=Object.keys(e),r={},n=0;n<t.length;n++)r[t[n]]=Object.getOwnPropertyDescriptor(e,t[n]);return r},a=/%[sdj%]/g;t.format=function(e){if(!w(e)){for(var t=[],r=0;r<arguments.length;r++)t.push(l(arguments[r]));return t.join(" ")}r=1;for(var n=arguments,o=n.length,i=String(e).replace(a,function(e){if("%%"===e)return"%";if(r>=o)return e;switch(e){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return e}}),s=n[r];r<o;s=n[++r])v(s)||!k(s)?i+=" "+s:i+=" "+l(s);return i},t.deprecate=function(e,r){if(void 0!==n&&!0===n.noDeprecation)return e;if(void 0===n)return function(){return t.deprecate(e,r).apply(this,arguments)};var i=!1;return function(){if(!i){if(n.throwDeprecation)throw new Error(r);n.traceDeprecation?o.trace(r):o.error(r),i=!0}return e.apply(this,arguments)}};var s={},u=/^$/;if(n.env.NODE_DEBUG){var c=n.env.NODE_DEBUG;c=c.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),u=new RegExp("^"+c+"$","i")}function l(e,r){var n={seen:[],stylize:p};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),g(r)?n.showHidden=r:r&&t._extend(n,r),S(n.showHidden)&&(n.showHidden=!1),S(n.depth)&&(n.depth=2),S(n.colors)&&(n.colors=!1),S(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=f),d(n,e,n.depth)}function f(e,t){var r=l.styles[t];return r?"\x1b["+l.colors[r][0]+"m"+e+"\x1b["+l.colors[r][1]+"m":e}function p(e,t){return e}function d(e,r,n){if(e.customInspect&&r&&O(r.inspect)&&r.inspect!==t.inspect&&(!r.constructor||r.constructor.prototype!==r)){var o=r.inspect(n,e);return w(o)||(o=d(e,o,n)),o}var i=function(e,t){if(S(t))return e.stylize("undefined","undefined");if(w(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}if(b(t))return e.stylize(""+t,"number");if(g(t))return e.stylize(""+t,"boolean");if(v(t))return e.stylize("null","null")}(e,r);if(i)return i;var a=Object.keys(r),s=function(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(r)),T(r)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return h(r);if(0===a.length){if(O(r)){var u=r.name?": "+r.name:"";return e.stylize("[Function"+u+"]","special")}if(E(r))return e.stylize(RegExp.prototype.toString.call(r),"regexp");if(A(r))return e.stylize(Date.prototype.toString.call(r),"date");if(T(r))return h(r)}var c,l="",f=!1,p=["{","}"];(m(r)&&(f=!0,p=["[","]"]),O(r))&&(l=" [Function"+(r.name?": "+r.name:"")+"]");return E(r)&&(l=" "+RegExp.prototype.toString.call(r)),A(r)&&(l=" "+Date.prototype.toUTCString.call(r)),T(r)&&(l=" "+h(r)),0!==a.length||f&&0!=r.length?n<0?E(r)?e.stylize(RegExp.prototype.toString.call(r),"regexp"):e.stylize("[Object]","special"):(e.seen.push(r),c=f?function(e,t,r,n,o){for(var i=[],a=0,s=t.length;a<s;++a)I(t,String(a))?i.push(y(e,t,r,n,String(a),!0)):i.push("");return o.forEach(function(o){o.match(/^\d+$/)||i.push(y(e,t,r,n,o,!0))}),i}(e,r,n,s,a):a.map(function(t){return y(e,r,n,s,t,f)}),e.seen.pop(),function(e,t,r){var n=e.reduce(function(e,t){return t.indexOf("\n")>=0&&0,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0);if(n>60)return r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1];return r[0]+t+" "+e.join(", ")+" "+r[1]}(c,l,p)):p[0]+l+p[1]}function h(e){return"["+Error.prototype.toString.call(e)+"]"}function y(e,t,r,n,o,i){var a,s,u;if((u=Object.getOwnPropertyDescriptor(t,o)||{value:t[o]}).get?s=u.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):u.set&&(s=e.stylize("[Setter]","special")),I(n,o)||(a="["+o+"]"),s||(e.seen.indexOf(u.value)<0?(s=v(r)?d(e,u.value,null):d(e,u.value,r-1)).indexOf("\n")>-1&&(s=i?s.split("\n").map(function(e){return"  "+e}).join("\n").slice(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n")):s=e.stylize("[Circular]","special")),S(a)){if(i&&o.match(/^\d+$/))return s;(a=JSON.stringify(""+o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.slice(1,-1),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+s}function m(e){return Array.isArray(e)}function g(e){return"boolean"==typeof e}function v(e){return null===e}function b(e){return"number"==typeof e}function w(e){return"string"==typeof e}function S(e){return void 0===e}function E(e){return k(e)&&"[object RegExp]"===x(e)}function k(e){return"object"==typeof e&&null!==e}function A(e){return k(e)&&"[object Date]"===x(e)}function T(e){return k(e)&&("[object Error]"===x(e)||e instanceof Error)}function O(e){return"function"==typeof e}function x(e){return Object.prototype.toString.call(e)}function P(e){return e<10?"0"+e.toString(10):e.toString(10)}t.debuglog=function(e){if(e=e.toUpperCase(),!s[e])if(u.test(e)){var r=n.pid;s[e]=function(){var n=t.format.apply(t,arguments);o.error("%s %d: %s",e,r,n)}}else s[e]=function(){};return s[e]},t.inspect=l,l.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},l.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.types=r(9032),t.isArray=m,t.isBoolean=g,t.isNull=v,t.isNullOrUndefined=function(e){return null==e},t.isNumber=b,t.isString=w,t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=S,t.isRegExp=E,t.types.isRegExp=E,t.isObject=k,t.isDate=A,t.types.isDate=A,t.isError=T,t.types.isNativeError=T,t.isFunction=O,t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=r(1135);var B=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function I(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.log=function(){var e,r;o.log("%s - %s",(e=new Date,r=[P(e.getHours()),P(e.getMinutes()),P(e.getSeconds())].join(":"),[e.getDate(),B[e.getMonth()],r].join(" ")),t.format.apply(t,arguments))},t.inherits=r(6698),t._extend=function(e,t){if(!t||!k(t))return e;for(var r=Object.keys(t),n=r.length;n--;)e[r[n]]=t[r[n]];return e};var C="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function R(e,t){if(!e){var r=new Error("Promise was rejected with a falsy value");r.reason=e,e=r}return t(e)}t.promisify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');if(C&&e[C]){var t;if("function"!=typeof(t=e[C]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(t,C,{value:t,enumerable:!1,writable:!1,configurable:!0}),t}function t(){for(var t,r,n=new Promise(function(e,n){t=e,r=n}),o=[],i=0;i<arguments.length;i++)o.push(arguments[i]);o.push(function(e,n){e?r(e):t(n)});try{e.apply(this,o)}catch(e){r(e)}return n}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),C&&Object.defineProperty(t,C,{value:t,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(t,i(e))},t.promisify.custom=C,t.callbackify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');function t(){for(var t=[],r=0;r<arguments.length;r++)t.push(arguments[r]);var o=t.pop();if("function"!=typeof o)throw new TypeError("The last argument must be of type Function");var i=this,a=function(){return o.apply(i,arguments)};e.apply(this,t).then(function(e){n.nextTick(a.bind(null,null,e))},function(e){n.nextTick(R.bind(null,e,a))})}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),Object.defineProperties(t,i(e)),t}},592:(e,t,r)=>{"use strict";var n=r(655),o=function(){return!!n};o.hasArrayLengthDefineBug=function(){if(!n)return null;try{return 1!==n([],"length",{value:1}).length}catch(e){return!0}},e.exports=o},655:e=>{"use strict";var t=Object.defineProperty||!1;if(t)try{t({},"a",{value:1})}catch(e){t=!1}e.exports=t},1002:e=>{"use strict";e.exports=Function.prototype.apply},1064:(e,t,r)=>{"use strict";var n=r(9612);e.exports=n.getPrototypeOf||null},1093:e=>{"use strict";var t=Object.prototype.toString;e.exports=function(e){var r=t.call(e),n="[object Arguments]"===r;return n||(n="[object Array]"!==r&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),n}},1135:e=>{e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},1189:(e,t,r)=>{"use strict";var n=Array.prototype.slice,o=r(1093),i=Object.keys,a=i?function(e){return i(e)}:r(8875),s=Object.keys;a.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(n.call(e)):s(e)})}else Object.keys=a;return Object.keys||a},e.exports=a},1237:e=>{"use strict";e.exports=EvalError},1333:e=>{"use strict";e.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var e={},t=Symbol("test"),r=Object(t);if("string"==typeof t)return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;if("[object Symbol]"!==Object.prototype.toString.call(r))return!1;for(var n in e[t]=42,e)return!1;if("function"==typeof Object.keys&&0!==Object.keys(e).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(e).length)return!1;var o=Object.getOwnPropertySymbols(e);if(1!==o.length||o[0]!==t)return!1;if(!Object.prototype.propertyIsEnumerable.call(e,t))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var i=Object.getOwnPropertyDescriptor(e,t);if(42!==i.value||!0!==i.enumerable)return!1}return!0}},1514:e=>{"use strict";e.exports=Math.abs},2205:(e,t,r)=>{"use strict";var n=r(6743),o=r(1002),i=r(3144);e.exports=function(){return i(n,o,arguments)}},2299:(e,t,r)=>{"use strict";function n(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,o,i,a,s=[],u=!0,c=!1;try{if(i=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;u=!1}else for(;!(u=(n=i.call(r)).done)&&(s.push(n.value),s.length!==t);u=!0);}catch(e){c=!0,o=e}finally{try{if(!u&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw o}}return s}}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return o(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return o(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function i(e){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i(e)}var a=void 0!==/a/g.flags,s=function(e){var t=[];return e.forEach(function(e){return t.push(e)}),t},u=function(e){var t=[];return e.forEach(function(e,r){return t.push([r,e])}),t},c=Object.is?Object.is:r(7653),l=Object.getOwnPropertySymbols?Object.getOwnPropertySymbols:function(){return[]},f=Number.isNaN?Number.isNaN:r(4133);function p(e){return e.call.bind(e)}var d=p(Object.prototype.hasOwnProperty),h=p(Object.prototype.propertyIsEnumerable),y=p(Object.prototype.toString),m=r(537).types,g=m.isAnyArrayBuffer,v=m.isArrayBufferView,b=m.isDate,w=m.isMap,S=m.isRegExp,E=m.isSet,k=m.isNativeError,A=m.isBoxedPrimitive,T=m.isNumberObject,O=m.isStringObject,x=m.isBooleanObject,P=m.isBigIntObject,B=m.isSymbolObject,I=m.isFloat32Array,C=m.isFloat64Array;function R(e){if(0===e.length||e.length>10)return!0;for(var t=0;t<e.length;t++){var r=e.charCodeAt(t);if(r<48||r>57)return!0}return 10===e.length&&e>=Math.pow(2,32)}function _(e){return Object.keys(e).filter(R).concat(l(e).filter(Object.prototype.propertyIsEnumerable.bind(e)))}function U(e,t){if(e===t)return 0;for(var r=e.length,n=t.length,o=0,i=Math.min(r,n);o<i;++o)if(e[o]!==t[o]){r=e[o],n=t[o];break}return r<n?-1:n<r?1:0}function N(e,t,r,n){if(e===t)return 0!==e||(!r||c(e,t));if(r){if("object"!==i(e))return"number"==typeof e&&f(e)&&f(t);if("object"!==i(t)||null===e||null===t)return!1;if(Object.getPrototypeOf(e)!==Object.getPrototypeOf(t))return!1}else{if(null===e||"object"!==i(e))return(null===t||"object"!==i(t))&&e==t;if(null===t||"object"!==i(t))return!1}var o,s,u,l,p=y(e);if(p!==y(t))return!1;if(Array.isArray(e)){if(e.length!==t.length)return!1;var d=_(e),h=_(t);return d.length===h.length&&F(e,t,r,n,1,d)}if("[object Object]"===p&&(!w(e)&&w(t)||!E(e)&&E(t)))return!1;if(b(e)){if(!b(t)||Date.prototype.getTime.call(e)!==Date.prototype.getTime.call(t))return!1}else if(S(e)){if(!S(t)||(u=e,l=t,!(a?u.source===l.source&&u.flags===l.flags:RegExp.prototype.toString.call(u)===RegExp.prototype.toString.call(l))))return!1}else if(k(e)||e instanceof Error){if(e.message!==t.message||e.name!==t.name)return!1}else{if(v(e)){if(r||!I(e)&&!C(e)){if(!function(e,t){return e.byteLength===t.byteLength&&0===U(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),new Uint8Array(t.buffer,t.byteOffset,t.byteLength))}(e,t))return!1}else if(!function(e,t){if(e.byteLength!==t.byteLength)return!1;for(var r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}(e,t))return!1;var m=_(e),R=_(t);return m.length===R.length&&F(e,t,r,n,0,m)}if(E(e))return!(!E(t)||e.size!==t.size)&&F(e,t,r,n,2);if(w(e))return!(!w(t)||e.size!==t.size)&&F(e,t,r,n,3);if(g(e)){if(s=t,(o=e).byteLength!==s.byteLength||0!==U(new Uint8Array(o),new Uint8Array(s)))return!1}else if(A(e)&&!function(e,t){return T(e)?T(t)&&c(Number.prototype.valueOf.call(e),Number.prototype.valueOf.call(t)):O(e)?O(t)&&String.prototype.valueOf.call(e)===String.prototype.valueOf.call(t):x(e)?x(t)&&Boolean.prototype.valueOf.call(e)===Boolean.prototype.valueOf.call(t):P(e)?P(t)&&BigInt.prototype.valueOf.call(e)===BigInt.prototype.valueOf.call(t):B(t)&&Symbol.prototype.valueOf.call(e)===Symbol.prototype.valueOf.call(t)}(e,t))return!1}return F(e,t,r,n,0)}function L(e,t){return t.filter(function(t){return h(e,t)})}function F(e,t,r,o,a,c){if(5===arguments.length){c=Object.keys(e);var f=Object.keys(t);if(c.length!==f.length)return!1}for(var p=0;p<c.length;p++)if(!d(t,c[p]))return!1;if(r&&5===arguments.length){var y=l(e);if(0!==y.length){var m=0;for(p=0;p<y.length;p++){var g=y[p];if(h(e,g)){if(!h(t,g))return!1;c.push(g),m++}else if(h(t,g))return!1}var v=l(t);if(y.length!==v.length&&L(t,v).length!==m)return!1}else{var b=l(t);if(0!==b.length&&0!==L(t,b).length)return!1}}if(0===c.length&&(0===a||1===a&&0===e.length||0===e.size))return!0;if(void 0===o)o={val1:new Map,val2:new Map,position:0};else{var w=o.val1.get(e);if(void 0!==w){var S=o.val2.get(t);if(void 0!==S)return w===S}o.position++}o.val1.set(e,o.position),o.val2.set(t,o.position);var E=function(e,t,r,o,a,c){var l=0;if(2===c){if(!function(e,t,r,n){for(var o=null,a=s(e),u=0;u<a.length;u++){var c=a[u];if("object"===i(c)&&null!==c)null===o&&(o=new Set),o.add(c);else if(!t.has(c)){if(r)return!1;if(!D(e,t,c))return!1;null===o&&(o=new Set),o.add(c)}}if(null!==o){for(var l=s(t),f=0;f<l.length;f++){var p=l[f];if("object"===i(p)&&null!==p){if(!j(o,p,r,n))return!1}else if(!r&&!e.has(p)&&!j(o,p,r,n))return!1}return 0===o.size}return!0}(e,t,r,a))return!1}else if(3===c){if(!function(e,t,r,o){for(var a=null,s=u(e),c=0;c<s.length;c++){var l=n(s[c],2),f=l[0],p=l[1];if("object"===i(f)&&null!==f)null===a&&(a=new Set),a.add(f);else{var d=t.get(f);if(void 0===d&&!t.has(f)||!N(p,d,r,o)){if(r)return!1;if(!V(e,t,f,p,o))return!1;null===a&&(a=new Set),a.add(f)}}}if(null!==a){for(var h=u(t),y=0;y<h.length;y++){var m=n(h[y],2),g=m[0],v=m[1];if("object"===i(g)&&null!==g){if(!q(a,e,g,v,r,o))return!1}else if(!(r||e.has(g)&&N(e.get(g),v,!1,o)||q(a,e,g,v,!1,o)))return!1}return 0===a.size}return!0}(e,t,r,a))return!1}else if(1===c)for(;l<e.length;l++){if(!d(e,l)){if(d(t,l))return!1;for(var f=Object.keys(e);l<f.length;l++){var p=f[l];if(!d(t,p)||!N(e[p],t[p],r,a))return!1}return f.length===Object.keys(t).length}if(!d(t,l)||!N(e[l],t[l],r,a))return!1}for(l=0;l<o.length;l++){var h=o[l];if(!N(e[h],t[h],r,a))return!1}return!0}(e,t,r,c,o,a);return o.val1.delete(e),o.val2.delete(t),E}function j(e,t,r,n){for(var o=s(e),i=0;i<o.length;i++){var a=o[i];if(N(t,a,r,n))return e.delete(a),!0}return!1}function M(e){switch(i(e)){case"undefined":return null;case"object":return;case"symbol":return!1;case"string":e=+e;case"number":if(f(e))return!1}return!0}function D(e,t,r){var n=M(r);return null!=n?n:t.has(n)&&!e.has(n)}function V(e,t,r,n,o){var i=M(r);if(null!=i)return i;var a=t.get(i);return!(void 0===a&&!t.has(i)||!N(n,a,!1,o))&&(!e.has(i)&&N(n,a,!1,o))}function q(e,t,r,n,o,i){for(var a=s(e),u=0;u<a.length;u++){var c=a[u];if(N(r,c,o,i)&&N(n,t.get(c),o,i))return e.delete(c),!0}return!1}e.exports={isDeepEqual:function(e,t){return N(e,t,false)},isDeepStrictEqual:function(e,t){return N(e,t,true)}}},2464:(e,t,r)=>{"use strict";var n=r(8452),o=r(6642);e.exports=function(){var e=o();return n(Number,{isNaN:e},{isNaN:function(){return Number.isNaN!==e}}),e}},2682:(e,t,r)=>{"use strict";var n=r(9600),o=Object.prototype.toString,i=Object.prototype.hasOwnProperty;e.exports=function(e,t,r){if(!n(t))throw new TypeError("iterator must be a function");var a,s;arguments.length>=3&&(a=r),s=e,"[object Array]"===o.call(s)?function(e,t,r){for(var n=0,o=e.length;n<o;n++)i.call(e,n)&&(null==r?t(e[n],n,e):t.call(r,e[n],n,e))}(e,t,a):"string"==typeof e?function(e,t,r){for(var n=0,o=e.length;n<o;n++)null==r?t(e.charAt(n),n,e):t.call(r,e.charAt(n),n,e)}(e,t,a):function(e,t,r){for(var n in e)i.call(e,n)&&(null==r?t(e[n],n,e):t.call(r,e[n],n,e))}(e,t,a)}},2802:(e,t,r)=>{"use strict";e.exports=function(t){var r=t.toLowerCase(),n=e.exports[r];if(!n)throw new Error(r+" is not supported (we accept pull requests)");return new n},e.exports.sha=r(7816),e.exports.sha1=r(3737),e.exports.sha224=r(6710),e.exports.sha256=r(4107),e.exports.sha384=r(2827),e.exports.sha512=r(2890)},2827:(e,t,r)=>{"use strict";var n=r(6698),o=r(2890),i=r(392),a=r(2861).Buffer,s=new Array(160);function u(){this.init(),this._w=s,i.call(this,128,112)}n(u,o),u.prototype.init=function(){return this._ah=3418070365,this._bh=1654270250,this._ch=2438529370,this._dh=355462360,this._eh=1731405415,this._fh=2394180231,this._gh=3675008525,this._hh=1203062813,this._al=3238371032,this._bl=914150663,this._cl=812702999,this._dl=4144912697,this._el=4290775857,this._fl=1750603025,this._gl=1694076839,this._hl=3204075428,this},u.prototype._hash=function(){var e=a.allocUnsafe(48);function t(t,r,n){e.writeInt32BE(t,n),e.writeInt32BE(r,n+4)}return t(this._ah,this._al,0),t(this._bh,this._bl,8),t(this._ch,this._cl,16),t(this._dh,this._dl,24),t(this._eh,this._el,32),t(this._fh,this._fl,40),e},e.exports=u},2861:(e,t,r)=>{var n=r(8287),o=n.Buffer;function i(e,t){for(var r in e)t[r]=e[r]}function a(e,t,r){return o(e,t,r)}o.from&&o.alloc&&o.allocUnsafe&&o.allocUnsafeSlow?e.exports=n:(i(n,t),t.Buffer=a),a.prototype=Object.create(o.prototype),i(o,a),a.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return o(e,t,r)},a.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=o(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},a.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return o(e)},a.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)}},2890:(e,t,r)=>{"use strict";var n=r(6698),o=r(392),i=r(2861).Buffer,a=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591],s=new Array(160);function u(){this.init(),this._w=s,o.call(this,128,112)}function c(e,t,r){return r^e&(t^r)}function l(e,t,r){return e&t|r&(e|t)}function f(e,t){return(e>>>28|t<<4)^(t>>>2|e<<30)^(t>>>7|e<<25)}function p(e,t){return(e>>>14|t<<18)^(e>>>18|t<<14)^(t>>>9|e<<23)}function d(e,t){return(e>>>1|t<<31)^(e>>>8|t<<24)^e>>>7}function h(e,t){return(e>>>1|t<<31)^(e>>>8|t<<24)^(e>>>7|t<<25)}function y(e,t){return(e>>>19|t<<13)^(t>>>29|e<<3)^e>>>6}function m(e,t){return(e>>>19|t<<13)^(t>>>29|e<<3)^(e>>>6|t<<26)}function g(e,t){return e>>>0<t>>>0?1:0}n(u,o),u.prototype.init=function(){return this._ah=1779033703,this._bh=3144134277,this._ch=1013904242,this._dh=2773480762,this._eh=1359893119,this._fh=2600822924,this._gh=528734635,this._hh=1541459225,this._al=4089235720,this._bl=2227873595,this._cl=4271175723,this._dl=1595750129,this._el=2917565137,this._fl=725511199,this._gl=4215389547,this._hl=327033209,this},u.prototype._update=function(e){for(var t=this._w,r=0|this._ah,n=0|this._bh,o=0|this._ch,i=0|this._dh,s=0|this._eh,u=0|this._fh,v=0|this._gh,b=0|this._hh,w=0|this._al,S=0|this._bl,E=0|this._cl,k=0|this._dl,A=0|this._el,T=0|this._fl,O=0|this._gl,x=0|this._hl,P=0;P<32;P+=2)t[P]=e.readInt32BE(4*P),t[P+1]=e.readInt32BE(4*P+4);for(;P<160;P+=2){var B=t[P-30],I=t[P-30+1],C=d(B,I),R=h(I,B),_=y(B=t[P-4],I=t[P-4+1]),U=m(I,B),N=t[P-14],L=t[P-14+1],F=t[P-32],j=t[P-32+1],M=R+L|0,D=C+N+g(M,R)|0;D=(D=D+_+g(M=M+U|0,U)|0)+F+g(M=M+j|0,j)|0,t[P]=D,t[P+1]=M}for(var V=0;V<160;V+=2){D=t[V],M=t[V+1];var q=l(r,n,o),K=l(w,S,E),H=f(r,w),z=f(w,r),X=p(s,A),$=p(A,s),G=a[V],W=a[V+1],Y=c(s,u,v),Z=c(A,T,O),J=x+$|0,Q=b+X+g(J,x)|0;Q=(Q=(Q=Q+Y+g(J=J+Z|0,Z)|0)+G+g(J=J+W|0,W)|0)+D+g(J=J+M|0,M)|0;var ee=z+K|0,te=H+q+g(ee,z)|0;b=v,x=O,v=u,O=T,u=s,T=A,s=i+Q+g(A=k+J|0,k)|0,i=o,k=E,o=n,E=S,n=r,S=w,r=Q+te+g(w=J+ee|0,J)|0}this._al=this._al+w|0,this._bl=this._bl+S|0,this._cl=this._cl+E|0,this._dl=this._dl+k|0,this._el=this._el+A|0,this._fl=this._fl+T|0,this._gl=this._gl+O|0,this._hl=this._hl+x|0,this._ah=this._ah+r+g(this._al,w)|0,this._bh=this._bh+n+g(this._bl,S)|0,this._ch=this._ch+o+g(this._cl,E)|0,this._dh=this._dh+i+g(this._dl,k)|0,this._eh=this._eh+s+g(this._el,A)|0,this._fh=this._fh+u+g(this._fl,T)|0,this._gh=this._gh+v+g(this._gl,O)|0,this._hh=this._hh+b+g(this._hl,x)|0},u.prototype._hash=function(){var e=i.allocUnsafe(64);function t(t,r,n){e.writeInt32BE(t,n),e.writeInt32BE(r,n+4)}return t(this._ah,this._al,0),t(this._bh,this._bl,8),t(this._ch,this._cl,16),t(this._dh,this._dl,24),t(this._eh,this._el,32),t(this._fh,this._fl,40),t(this._gh,this._gl,48),t(this._hh,this._hl,56),e},e.exports=u},3003:e=>{"use strict";e.exports=function(e){return e!=e}},3093:(e,t,r)=>{"use strict";var n=r(4459);e.exports=function(e){return n(e)||0===e?e:e<0?-1:1}},3126:(e,t,r)=>{"use strict";var n=r(6743),o=r(9675),i=r(76),a=r(3144);e.exports=function(e){if(e.length<1||"function"!=typeof e[0])throw new o("a function is required");return a(n,i,e)}},3144:(e,t,r)=>{"use strict";var n=r(6743),o=r(1002),i=r(76),a=r(7119);e.exports=a||n.call(i,o)},3628:(e,t,r)=>{"use strict";var n=r(8648),o=r(1064),i=r(7176);e.exports=n?function(e){return n(e)}:o?function(e){if(!e||"object"!=typeof e&&"function"!=typeof e)throw new TypeError("getProto: not an object");return o(e)}:i?function(e){return i(e)}:null},3737:(e,t,r)=>{"use strict";var n=r(6698),o=r(392),i=r(2861).Buffer,a=[1518500249,1859775393,-1894007588,-899497514],s=new Array(80);function u(){this.init(),this._w=s,o.call(this,64,56)}function c(e){return e<<1|e>>>31}function l(e){return e<<5|e>>>27}function f(e){return e<<30|e>>>2}function p(e,t,r,n){return 0===e?t&r|~t&n:2===e?t&r|t&n|r&n:t^r^n}n(u,o),u.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},u.prototype._update=function(e){for(var t=this._w,r=0|this._a,n=0|this._b,o=0|this._c,i=0|this._d,s=0|this._e,u=0;u<16;++u)t[u]=e.readInt32BE(4*u);for(;u<80;++u)t[u]=c(t[u-3]^t[u-8]^t[u-14]^t[u-16]);for(var d=0;d<80;++d){var h=~~(d/20),y=l(r)+p(h,n,o,i)+s+t[d]+a[h]|0;s=i,i=o,o=f(n),n=r,r=y}this._a=r+this._a|0,this._b=n+this._b|0,this._c=o+this._c|0,this._d=i+this._d|0,this._e=s+this._e|0},u.prototype._hash=function(){var e=i.allocUnsafe(20);return e.writeInt32BE(0|this._a,0),e.writeInt32BE(0|this._b,4),e.writeInt32BE(0|this._c,8),e.writeInt32BE(0|this._d,12),e.writeInt32BE(0|this._e,16),e},e.exports=u},3740:function(e,t,r){var n,o=r(6763);n=()=>(()=>{var e={616:(e,t,r)=>{"use strict";r.d(t,{A:()=>o});var n=r(287);n.hp.alloc(1).subarray(0,1)instanceof n.hp||(n.hp.prototype.subarray=function(e,t){const r=Uint8Array.prototype.subarray.call(this,e,t);return Object.setPrototypeOf(r,n.hp.prototype),r});const o=n.hp},281:(e,t,r)=>{const n=r(164);e.exports=n},164:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Array:()=>D,Bool:()=>_,Double:()=>C,Enum:()=>H,Float:()=>I,Hyper:()=>O,Int:()=>E,LargeInt:()=>T,Opaque:()=>F,Option:()=>q,Quadruple:()=>R,Reference:()=>z,String:()=>N,Struct:()=>X,Union:()=>G,UnsignedHyper:()=>B,UnsignedInt:()=>P,VarArray:()=>V,VarOpaque:()=>M,Void:()=>K,XdrReader:()=>u,XdrWriter:()=>f,config:()=>ne});class n extends TypeError{constructor(e){super(`XDR Write Error: ${e}`)}}class o extends TypeError{constructor(e){super(`XDR Read Error: ${e}`)}}class i extends TypeError{constructor(e){super(`XDR Type Definition Error: ${e}`)}}class a extends i{constructor(){super("method not implemented, it should be overloaded in the descendant class.")}}var s=r(616).A;class u{constructor(e){if(!s.isBuffer(e)){if(!(e instanceof Array||Array.isArray(e)||ArrayBuffer.isView(e)))throw new o(`source invalid: ${e}`);e=s.from(e)}this._buffer=e,this._length=e.length,this._index=0}_buffer;_length;_index;get eof(){return this._index===this._length}advance(e){const t=this._index;if(this._index+=e,this._length<this._index)throw new o("attempt to read outside the boundary of the buffer");const r=4-(e%4||4);if(r>0){for(let e=0;e<r;e++)if(0!==this._buffer[this._index+e])throw new o("invalid padding");this._index+=r}return t}rewind(){this._index=0}read(e){const t=this.advance(e);return this._buffer.subarray(t,t+e)}readInt32BE(){return this._buffer.readInt32BE(this.advance(4))}readUInt32BE(){return this._buffer.readUInt32BE(this.advance(4))}readBigInt64BE(){return this._buffer.readBigInt64BE(this.advance(8))}readBigUInt64BE(){return this._buffer.readBigUInt64BE(this.advance(8))}readFloatBE(){return this._buffer.readFloatBE(this.advance(4))}readDoubleBE(){return this._buffer.readDoubleBE(this.advance(8))}ensureInputConsumed(){if(this._index!==this._length)throw new o("invalid XDR contract typecast - source buffer not entirely consumed")}}var c=r(616).A;const l=8192;class f{constructor(e){"number"==typeof e?e=c.allocUnsafe(e):e instanceof c||(e=c.allocUnsafe(l)),this._buffer=e,this._length=e.length}_buffer;_length;_index=0;alloc(e){const t=this._index;return this._index+=e,this._length<this._index&&this.resize(this._index),t}resize(e){const t=Math.ceil(e/l)*l,r=c.allocUnsafe(t);this._buffer.copy(r,0,0,this._length),this._buffer=r,this._length=t}finalize(){return this._buffer.subarray(0,this._index)}toArray(){return[...this.finalize()]}write(e,t){if("string"==typeof e){const r=this.alloc(t);this._buffer.write(e,r,"utf8")}else{e instanceof c||(e=c.from(e));const r=this.alloc(t);e.copy(this._buffer,r,0,t)}const r=4-(t%4||4);if(r>0){const e=this.alloc(r);this._buffer.fill(0,e,this._index)}}writeInt32BE(e){const t=this.alloc(4);this._buffer.writeInt32BE(e,t)}writeUInt32BE(e){const t=this.alloc(4);this._buffer.writeUInt32BE(e,t)}writeBigInt64BE(e){const t=this.alloc(8);this._buffer.writeBigInt64BE(e,t)}writeBigUInt64BE(e){const t=this.alloc(8);this._buffer.writeBigUInt64BE(e,t)}writeFloatBE(e){const t=this.alloc(4);this._buffer.writeFloatBE(e,t)}writeDoubleBE(e){const t=this.alloc(8);this._buffer.writeDoubleBE(e,t)}static bufferChunkSize=l}var p=r(616).A;class d{toXDR(e="raw"){if(!this.write)return this.constructor.toXDR(this,e);const t=new f;return this.write(this,t),g(t.finalize(),e)}fromXDR(e,t="raw"){if(!this.read)return this.constructor.fromXDR(e,t);const r=new u(v(e,t)),n=this.read(r);return r.ensureInputConsumed(),n}validateXDR(e,t="raw"){try{return this.fromXDR(e,t),!0}catch(e){return!1}}static toXDR(e,t="raw"){const r=new f;return this.write(e,r),g(r.finalize(),t)}static fromXDR(e,t="raw"){const r=new u(v(e,t)),n=this.read(r);return r.ensureInputConsumed(),n}static validateXDR(e,t="raw"){try{return this.fromXDR(e,t),!0}catch(e){return!1}}}class h extends d{static read(e){throw new a}static write(e,t){throw new a}static isValid(e){return!1}}class y extends d{isValid(e){return!1}}class m extends TypeError{constructor(e){super(`Invalid format ${e}, must be one of "raw", "hex", "base64"`)}}function g(e,t){switch(t){case"raw":return e;case"hex":return e.toString("hex");case"base64":return e.toString("base64");default:throw new m(t)}}function v(e,t){switch(t){case"raw":return e;case"hex":return p.from(e,"hex");case"base64":return p.from(e,"base64");default:throw new m(t)}}function b(e,t){return null!=e&&(e instanceof t||w(e,t)&&"function"==typeof e.constructor.read&&"function"==typeof e.constructor.write&&w(e,"XdrType"))}function w(e,t){do{if(e.constructor.name===t)return!0}while(e=Object.getPrototypeOf(e));return!1}const S=2147483647;class E extends h{static read(e){return e.readInt32BE()}static write(e,t){if("number"!=typeof e)throw new n("not a number");if((0|e)!==e)throw new n("invalid i32 value");t.writeInt32BE(e)}static isValid(e){return"number"==typeof e&&(0|e)===e&&e>=-2147483648&&e<=S}}function k(e,t,r){if("bigint"!=typeof e)throw new TypeError("Expected bigint 'value', got "+typeof e);const n=t/r;if(1===n)return[e];if(r<32||r>128||2!==n&&4!==n&&8!==n)throw new TypeError(`invalid bigint (${e}) and slice size (${t} -> ${r}) combination`);const o=BigInt(r),i=new Array(n);for(let t=0;t<n;t++)i[t]=BigInt.asIntN(r,e),e>>=o;return i}function A(e,t){if(t)return[0n,(1n<<BigInt(e))-1n];const r=1n<<BigInt(e-1);return[0n-r,r-1n]}E.MAX_VALUE=S,E.MIN_VALUE=2147483648;class T extends h{constructor(e){super(),this._value=function(e,t,r){e instanceof Array?e.length&&e[0]instanceof Array&&(e=e[0]):e=[e];const n=t/e.length;switch(n){case 32:case 64:case 128:case 256:break;default:throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${e}`)}try{for(let t=0;t<e.length;t++)"bigint"!=typeof e[t]&&(e[t]=BigInt(e[t].valueOf()))}catch(t){throw new TypeError(`expected bigint-like values, got: ${e} (${t})`)}if(r&&1===e.length&&e[0]<0n)throw new RangeError(`expected a positive value, got: ${e}`);let o=BigInt.asUintN(n,e[0]);for(let t=1;t<e.length;t++)o|=BigInt.asUintN(n,e[t])<<BigInt(t*n);r||(o=BigInt.asIntN(t,o));const[i,a]=A(t,r);if(o>=i&&o<=a)return o;throw new TypeError(`bigint values [${e}] for ${function(e,t){return`${t?"u":"i"}${e}`}(t,r)} out of range [${i}, ${a}]: ${o}`)}(e,this.size,this.unsigned)}get unsigned(){throw new a}get size(){throw new a}slice(e){return k(this._value,this.size,e)}toString(){return this._value.toString()}toJSON(){return{_value:this._value.toString()}}toBigInt(){return BigInt(this._value)}static read(e){const{size:t}=this.prototype;return 64===t?new this(e.readBigUInt64BE()):new this(...Array.from({length:t/64},()=>e.readBigUInt64BE()).reverse())}static write(e,t){if(e instanceof this)e=e._value;else if("bigint"!=typeof e||e>this.MAX_VALUE||e<this.MIN_VALUE)throw new n(`${e} is not a ${this.name}`);const{unsigned:r,size:o}=this.prototype;if(64===o)r?t.writeBigUInt64BE(e):t.writeBigInt64BE(e);else for(const n of k(e,o,64).reverse())r?t.writeBigUInt64BE(n):t.writeBigInt64BE(n)}static isValid(e){return"bigint"==typeof e||e instanceof this}static fromString(e){return new this(e)}static MAX_VALUE=0n;static MIN_VALUE=0n;static defineIntBoundaries(){const[e,t]=A(this.prototype.size,this.prototype.unsigned);this.MIN_VALUE=e,this.MAX_VALUE=t}}class O extends T{constructor(...e){super(e)}get low(){return 0|Number(0xffffffffn&this._value)}get high(){return 0|Number(this._value>>32n)}get size(){return 64}get unsigned(){return!1}static fromBits(e,t){return new this(e,t)}}O.defineIntBoundaries();const x=4294967295;class P extends h{static read(e){return e.readUInt32BE()}static write(e,t){if("number"!=typeof e||!(e>=0&&e<=x)||e%1!=0)throw new n("invalid u32 value");t.writeUInt32BE(e)}static isValid(e){return"number"==typeof e&&e%1==0&&e>=0&&e<=x}}P.MAX_VALUE=x,P.MIN_VALUE=0;class B extends T{constructor(...e){super(e)}get low(){return 0|Number(0xffffffffn&this._value)}get high(){return 0|Number(this._value>>32n)}get size(){return 64}get unsigned(){return!0}static fromBits(e,t){return new this(e,t)}}B.defineIntBoundaries();class I extends h{static read(e){return e.readFloatBE()}static write(e,t){if("number"!=typeof e)throw new n("not a number");t.writeFloatBE(e)}static isValid(e){return"number"==typeof e}}class C extends h{static read(e){return e.readDoubleBE()}static write(e,t){if("number"!=typeof e)throw new n("not a number");t.writeDoubleBE(e)}static isValid(e){return"number"==typeof e}}class R extends h{static read(){throw new i("quadruple not supported")}static write(){throw new i("quadruple not supported")}static isValid(){return!1}}class _ extends h{static read(e){const t=E.read(e);switch(t){case 0:return!1;case 1:return!0;default:throw new o(`got ${t} when trying to read a bool`)}}static write(e,t){const r=e?1:0;E.write(r,t)}static isValid(e){return"boolean"==typeof e}}var U=r(616).A;class N extends y{constructor(e=P.MAX_VALUE){super(),this._maxLength=e}read(e){const t=P.read(e);if(t>this._maxLength)throw new o(`saw ${t} length String, max allowed is ${this._maxLength}`);return e.read(t)}readString(e){return this.read(e).toString("utf8")}write(e,t){const r="string"==typeof e?U.byteLength(e,"utf8"):e.length;if(r>this._maxLength)throw new n(`got ${e.length} bytes, max allowed is ${this._maxLength}`);P.write(r,t),t.write(e,r)}isValid(e){return"string"==typeof e?U.byteLength(e,"utf8")<=this._maxLength:!!(e instanceof Array||U.isBuffer(e))&&e.length<=this._maxLength}}var L=r(616).A;class F extends y{constructor(e){super(),this._length=e}read(e){return e.read(this._length)}write(e,t){const{length:r}=e;if(r!==this._length)throw new n(`got ${e.length} bytes, expected ${this._length}`);t.write(e,r)}isValid(e){return L.isBuffer(e)&&e.length===this._length}}var j=r(616).A;class M extends y{constructor(e=P.MAX_VALUE){super(),this._maxLength=e}read(e){const t=P.read(e);if(t>this._maxLength)throw new o(`saw ${t} length VarOpaque, max allowed is ${this._maxLength}`);return e.read(t)}write(e,t){const{length:r}=e;if(e.length>this._maxLength)throw new n(`got ${e.length} bytes, max allowed is ${this._maxLength}`);P.write(r,t),t.write(e,r)}isValid(e){return j.isBuffer(e)&&e.length<=this._maxLength}}class D extends y{constructor(e,t){super(),this._childType=e,this._length=t}read(e){const t=new r.g.Array(this._length);for(let r=0;r<this._length;r++)t[r]=this._childType.read(e);return t}write(e,t){if(!r.g.Array.isArray(e))throw new n("value is not array");if(e.length!==this._length)throw new n(`got array of size ${e.length}, expected ${this._length}`);for(const r of e)this._childType.write(r,t)}isValid(e){if(!(e instanceof r.g.Array)||e.length!==this._length)return!1;for(const t of e)if(!this._childType.isValid(t))return!1;return!0}}class V extends y{constructor(e,t=P.MAX_VALUE){super(),this._childType=e,this._maxLength=t}read(e){const t=P.read(e);if(t>this._maxLength)throw new o(`saw ${t} length VarArray, max allowed is ${this._maxLength}`);const r=new Array(t);for(let n=0;n<t;n++)r[n]=this._childType.read(e);return r}write(e,t){if(!(e instanceof Array))throw new n("value is not array");if(e.length>this._maxLength)throw new n(`got array of size ${e.length}, max allowed is ${this._maxLength}`);P.write(e.length,t);for(const r of e)this._childType.write(r,t)}isValid(e){if(!(e instanceof Array)||e.length>this._maxLength)return!1;for(const t of e)if(!this._childType.isValid(t))return!1;return!0}}class q extends h{constructor(e){super(),this._childType=e}read(e){if(_.read(e))return this._childType.read(e)}write(e,t){const r=null!=e;_.write(r,t),r&&this._childType.write(e,t)}isValid(e){return null==e||this._childType.isValid(e)}}class K extends h{static read(){}static write(e){if(void 0!==e)throw new n("trying to write value to a void slot")}static isValid(e){return void 0===e}}class H extends h{constructor(e,t){super(),this.name=e,this.value=t}static read(e){const t=E.read(e),r=this._byValue[t];if(void 0===r)throw new o(`unknown ${this.enumName} member for value ${t}`);return r}static write(e,t){if(!this.isValid(e))throw new n(`${e} has enum name ${e?.enumName}, not ${this.enumName}: ${JSON.stringify(e)}`);E.write(e.value,t)}static isValid(e){return e?.constructor?.enumName===this.enumName||b(e,this)}static members(){return this._members}static values(){return Object.values(this._members)}static fromName(e){const t=this._members[e];if(!t)throw new TypeError(`${e} is not a member of ${this.enumName}`);return t}static fromValue(e){const t=this._byValue[e];if(void 0===t)throw new TypeError(`${e} is not a value of any member of ${this.enumName}`);return t}static create(e,t,r){const n=class extends H{};n.enumName=t,e.results[t]=n,n._members={},n._byValue={};for(const[e,t]of Object.entries(r)){const r=new n(e,t);n._members[e]=r,n._byValue[t]=r,n[e]=()=>r}return n}}class z extends h{resolve(){throw new i('"resolve" method should be implemented in the descendant class')}}class X extends y{constructor(e){super(),this._attributes=e||{}}static read(e){const t={};for(const[r,n]of this._fields)t[r]=n.read(e);return new this(t)}static write(e,t){if(!this.isValid(e))throw new n(`${e} has struct name ${e?.constructor?.structName}, not ${this.structName}: ${JSON.stringify(e)}`);for(const[r,n]of this._fields){const o=e._attributes[r];n.write(o,t)}}static isValid(e){return e?.constructor?.structName===this.structName||b(e,this)}static create(e,t,r){const n=class extends X{};n.structName=t,e.results[t]=n;const o=new Array(r.length);for(let t=0;t<r.length;t++){const i=r[t],a=i[0];let s=i[1];s instanceof z&&(s=s.resolve(e)),o[t]=[a,s],n.prototype[a]=$(a)}return n._fields=o,n}}function $(e){return function(t){return void 0!==t&&(this._attributes[e]=t),this._attributes[e]}}class G extends y{constructor(e,t){super(),this.set(e,t)}set(e,t){"string"==typeof e&&(e=this.constructor._switchOn.fromName(e)),this._switch=e;const r=this.constructor.armForSwitch(this._switch);this._arm=r,this._armType=r===K?K:this.constructor._arms[r],this._value=t}get(e=this._arm){if(this._arm!==K&&this._arm!==e)throw new TypeError(`${e} not set`);return this._value}switch(){return this._switch}arm(){return this._arm}armType(){return this._armType}value(){return this._value}static armForSwitch(e){const t=this._switches.get(e);if(void 0!==t)return t;if(this._defaultArm)return this._defaultArm;throw new TypeError(`Bad union switch: ${e}`)}static armTypeForArm(e){return e===K?K:this._arms[e]}static read(e){const t=this._switchOn.read(e),r=this.armForSwitch(t),n=r===K?K:this._arms[r];let o;return o=void 0!==n?n.read(e):r.read(e),new this(t,o)}static write(e,t){if(!this.isValid(e))throw new n(`${e} has union name ${e?.unionName}, not ${this.unionName}: ${JSON.stringify(e)}`);this._switchOn.write(e.switch(),t),e.armType().write(e.value(),t)}static isValid(e){return e?.constructor?.unionName===this.unionName||b(e,this)}static create(e,t,r){const n=class extends G{};n.unionName=t,e.results[t]=n,r.switchOn instanceof z?n._switchOn=r.switchOn.resolve(e):n._switchOn=r.switchOn,n._switches=new Map,n._arms={};let o=r.defaultArm;o instanceof z&&(o=o.resolve(e)),n._defaultArm=o;for(const[e,t]of r.switches){const r="string"==typeof e?n._switchOn.fromName(e):e;n._switches.set(r,t)}if(void 0!==n._switchOn.values)for(const e of n._switchOn.values())n[e.name]=function(t){return new n(e,t)},n.prototype[e.name]=function(t){return this.set(e,t)};if(r.arms)for(const[t,o]of Object.entries(r.arms))n._arms[t]=o instanceof z?o.resolve(e):o,o!==K&&(n.prototype[t]=function(){return this.get(t)});return n}}class W extends z{constructor(e){super(),this.name=e}resolve(e){return e.definitions[this.name].resolve(e)}}class Y extends z{constructor(e,t,r=!1){super(),this.childReference=e,this.length=t,this.variable=r}resolve(e){let t=this.childReference,r=this.length;return t instanceof z&&(t=t.resolve(e)),r instanceof z&&(r=r.resolve(e)),this.variable?new V(t,r):new D(t,r)}}class Z extends z{constructor(e){super(),this.childReference=e,this.name=e.name}resolve(e){let t=this.childReference;return t instanceof z&&(t=t.resolve(e)),new q(t)}}class J extends z{constructor(e,t){super(),this.sizedType=e,this.length=t}resolve(e){let t=this.length;return t instanceof z&&(t=t.resolve(e)),new this.sizedType(t)}}class Q{constructor(e,t,r){this.constructor=e,this.name=t,this.config=r}resolve(e){return this.name in e.results?e.results[this.name]:this.constructor(e,this.name,this.config)}}function ee(e,t,r){return r instanceof z&&(r=r.resolve(e)),e.results[t]=r,r}function te(e,t,r){return e.results[t]=r,r}class re{constructor(e){this._destination=e,this._definitions={}}enum(e,t){const r=new Q(H.create,e,t);this.define(e,r)}struct(e,t){const r=new Q(X.create,e,t);this.define(e,r)}union(e,t){const r=new Q(G.create,e,t);this.define(e,r)}typedef(e,t){const r=new Q(ee,e,t);this.define(e,r)}const(e,t){const r=new Q(te,e,t);this.define(e,r)}void(){return K}bool(){return _}int(){return E}hyper(){return O}uint(){return P}uhyper(){return B}float(){return I}double(){return C}quadruple(){return R}string(e){return new J(N,e)}opaque(e){return new J(F,e)}varOpaque(e){return new J(M,e)}array(e,t){return new Y(e,t)}varArray(e,t){return new Y(e,t,!0)}option(e){return new Z(e)}define(e,t){if(void 0!==this._destination[e])throw new i(`${e} is already defined`);this._definitions[e]=t}lookup(e){return new W(e)}resolve(){for(const e of Object.values(this._definitions))e.resolve({definitions:this._definitions,results:this._destination})}}function ne(e,t={}){if(e){const r=new re(t);e(r),r.resolve()}return t}},526:(e,t)=>{"use strict";t.byteLength=function(e){var t=s(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,i=s(e),a=i[0],u=i[1],c=new o(function(e,t,r){return 3*(t+r)/4-r}(0,a,u)),l=0,f=u>0?a-4:a;for(r=0;r<f;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],c[l++]=t>>16&255,c[l++]=t>>8&255,c[l++]=255&t;return 2===u&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,c[l++]=255&t),1===u&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,c[l++]=t>>8&255,c[l++]=255&t),c},t.fromByteArray=function(e){for(var t,n=e.length,o=n%3,i=[],a=16383,s=0,c=n-o;s<c;s+=a)i.push(u(e,s,s+a>c?c:s+a));return 1===o?(t=e[n-1],i.push(r[t>>2]+r[t<<4&63]+"==")):2===o&&(t=(e[n-2]<<8)+e[n-1],i.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"=")),i.join("")};for(var r=[],n=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0;a<64;++a)r[a]=i[a],n[i.charCodeAt(a)]=a;function s(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function u(e,t,n){for(var o,i,a=[],s=t;s<n;s+=3)o=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(255&e[s+2]),a.push(r[(i=o)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return a.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},287:(e,t,r)=>{"use strict";const n=r(526),i=r(251),a="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.hp=c,t.IS=50;const s=2147483647;function u(e){if(e>s)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,c.prototype),t}function c(e,t,r){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return p(e)}return l(e,t,r)}function l(e,t,r){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!c.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const r=0|m(e,t);let n=u(r);const o=n.write(e,t);return o!==r&&(n=n.slice(0,o)),n}(e,t);if(ArrayBuffer.isView(e))return function(e){if(Y(e,Uint8Array)){const t=new Uint8Array(e);return h(t.buffer,t.byteOffset,t.byteLength)}return d(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(Y(e,ArrayBuffer)||e&&Y(e.buffer,ArrayBuffer))return h(e,t,r);if("undefined"!=typeof SharedArrayBuffer&&(Y(e,SharedArrayBuffer)||e&&Y(e.buffer,SharedArrayBuffer)))return h(e,t,r);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const n=e.valueOf&&e.valueOf();if(null!=n&&n!==e)return c.from(n,t,r);const o=function(e){if(c.isBuffer(e)){const t=0|y(e.length),r=u(t);return 0===r.length||e.copy(r,0,0,t),r}return void 0!==e.length?"number"!=typeof e.length||Z(e.length)?u(0):d(e):"Buffer"===e.type&&Array.isArray(e.data)?d(e.data):void 0}(e);if(o)return o;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return c.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function f(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function p(e){return f(e),u(e<0?0:0|y(e))}function d(e){const t=e.length<0?0:0|y(e.length),r=u(t);for(let n=0;n<t;n+=1)r[n]=255&e[n];return r}function h(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),Object.setPrototypeOf(n,c.prototype),n}function y(e){if(e>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return 0|e}function m(e,t){if(c.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||Y(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const r=e.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let o=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return $(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return G(e).length;default:if(o)return n?-1:$(e).length;t=(""+t).toLowerCase(),o=!0}}function g(e,t,r){let n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return C(this,t,r);case"utf8":case"utf-8":return x(this,t,r);case"ascii":return B(this,t,r);case"latin1":case"binary":return I(this,t,r);case"base64":return O(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return R(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function v(e,t,r){const n=e[t];e[t]=e[r],e[r]=n}function b(e,t,r,n,o){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),Z(r=+r)&&(r=o?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(o)return-1;r=e.length-1}else if(r<0){if(!o)return-1;r=0}if("string"==typeof t&&(t=c.from(t,n)),c.isBuffer(t))return 0===t.length?-1:w(e,t,r,n,o);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):w(e,[t],r,n,o);throw new TypeError("val must be string, number or Buffer")}function w(e,t,r,n,o){let i,a=1,s=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,s/=2,u/=2,r/=2}function c(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(o){let n=-1;for(i=r;i<s;i++)if(c(e,i)===c(t,-1===n?0:i-n)){if(-1===n&&(n=i),i-n+1===u)return n*a}else-1!==n&&(i-=i-n),n=-1}else for(r+u>s&&(r=s-u),i=r;i>=0;i--){let r=!0;for(let n=0;n<u;n++)if(c(e,i+n)!==c(t,n)){r=!1;break}if(r)return i}return-1}function S(e,t,r,n){r=Number(r)||0;const o=e.length-r;n?(n=Number(n))>o&&(n=o):n=o;const i=t.length;let a;for(n>i/2&&(n=i/2),a=0;a<n;++a){const n=parseInt(t.substr(2*a,2),16);if(Z(n))return a;e[r+a]=n}return a}function E(e,t,r,n){return W($(t,e.length-r),e,r,n)}function k(e,t,r,n){return W(function(e){const t=[];for(let r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function A(e,t,r,n){return W(G(t),e,r,n)}function T(e,t,r,n){return W(function(e,t){let r,n,o;const i=[];for(let a=0;a<e.length&&!((t-=2)<0);++a)r=e.charCodeAt(a),n=r>>8,o=r%256,i.push(o),i.push(n);return i}(t,e.length-r),e,r,n)}function O(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function x(e,t,r){r=Math.min(e.length,r);const n=[];let o=t;for(;o<r;){const t=e[o];let i=null,a=t>239?4:t>223?3:t>191?2:1;if(o+a<=r){let r,n,s,u;switch(a){case 1:t<128&&(i=t);break;case 2:r=e[o+1],128==(192&r)&&(u=(31&t)<<6|63&r,u>127&&(i=u));break;case 3:r=e[o+1],n=e[o+2],128==(192&r)&&128==(192&n)&&(u=(15&t)<<12|(63&r)<<6|63&n,u>2047&&(u<55296||u>57343)&&(i=u));break;case 4:r=e[o+1],n=e[o+2],s=e[o+3],128==(192&r)&&128==(192&n)&&128==(192&s)&&(u=(15&t)<<18|(63&r)<<12|(63&n)<<6|63&s,u>65535&&u<1114112&&(i=u))}}null===i?(i=65533,a=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),o+=a}return function(e){const t=e.length;if(t<=P)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=P));return r}(n)}c.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),c.TYPED_ARRAY_SUPPORT||void 0===o||"function"!=typeof o.error||o.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(c.prototype,"parent",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.buffer}}),Object.defineProperty(c.prototype,"offset",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.byteOffset}}),c.poolSize=8192,c.from=function(e,t,r){return l(e,t,r)},Object.setPrototypeOf(c.prototype,Uint8Array.prototype),Object.setPrototypeOf(c,Uint8Array),c.alloc=function(e,t,r){return function(e,t,r){return f(e),e<=0?u(e):void 0!==t?"string"==typeof r?u(e).fill(t,r):u(e).fill(t):u(e)}(e,t,r)},c.allocUnsafe=function(e){return p(e)},c.allocUnsafeSlow=function(e){return p(e)},c.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==c.prototype},c.compare=function(e,t){if(Y(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),Y(t,Uint8Array)&&(t=c.from(t,t.offset,t.byteLength)),!c.isBuffer(e)||!c.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let o=0,i=Math.min(r,n);o<i;++o)if(e[o]!==t[o]){r=e[o],n=t[o];break}return r<n?-1:n<r?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return c.alloc(0);let r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;const n=c.allocUnsafe(t);let o=0;for(r=0;r<e.length;++r){let t=e[r];if(Y(t,Uint8Array))o+t.length>n.length?(c.isBuffer(t)||(t=c.from(t)),t.copy(n,o)):Uint8Array.prototype.set.call(n,t,o);else{if(!c.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(n,o)}o+=t.length}return n},c.byteLength=m,c.prototype._isBuffer=!0,c.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)v(this,t,t+1);return this},c.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)v(this,t,t+3),v(this,t+1,t+2);return this},c.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)v(this,t,t+7),v(this,t+1,t+6),v(this,t+2,t+5),v(this,t+3,t+4);return this},c.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?x(this,0,e):g.apply(this,arguments)},c.prototype.toLocaleString=c.prototype.toString,c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===c.compare(this,e)},c.prototype.inspect=function(){let e="";const r=t.IS;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},a&&(c.prototype[a]=c.prototype.inspect),c.prototype.compare=function(e,t,r,n,o){if(Y(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),!c.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===o&&(o=this.length),t<0||r>e.length||n<0||o>this.length)throw new RangeError("out of range index");if(n>=o&&t>=r)return 0;if(n>=o)return-1;if(t>=r)return 1;if(this===e)return 0;let i=(o>>>=0)-(n>>>=0),a=(r>>>=0)-(t>>>=0);const s=Math.min(i,a),u=this.slice(n,o),l=e.slice(t,r);for(let e=0;e<s;++e)if(u[e]!==l[e]){i=u[e],a=l[e];break}return i<a?-1:a<i?1:0},c.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},c.prototype.indexOf=function(e,t,r){return b(this,e,t,r,!0)},c.prototype.lastIndexOf=function(e,t,r){return b(this,e,t,r,!1)},c.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}const o=this.length-t;if((void 0===r||r>o)&&(r=o),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let i=!1;for(;;)switch(n){case"hex":return S(this,e,t,r);case"utf8":case"utf-8":return E(this,e,t,r);case"ascii":case"latin1":case"binary":return k(this,e,t,r);case"base64":return A(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,t,r);default:if(i)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),i=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const P=4096;function B(e,t,r){let n="";r=Math.min(e.length,r);for(let o=t;o<r;++o)n+=String.fromCharCode(127&e[o]);return n}function I(e,t,r){let n="";r=Math.min(e.length,r);for(let o=t;o<r;++o)n+=String.fromCharCode(e[o]);return n}function C(e,t,r){const n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let o="";for(let n=t;n<r;++n)o+=J[e[n]];return o}function R(e,t,r){const n=e.slice(t,r);let o="";for(let e=0;e<n.length-1;e+=2)o+=String.fromCharCode(n[e]+256*n[e+1]);return o}function _(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function U(e,t,r,n,o,i){if(!c.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>o||t<i)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function N(e,t,r,n,o){K(t,n,o,e,r,7);let i=Number(t&BigInt(4294967295));e[r++]=i,i>>=8,e[r++]=i,i>>=8,e[r++]=i,i>>=8,e[r++]=i;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=a,a>>=8,e[r++]=a,a>>=8,e[r++]=a,a>>=8,e[r++]=a,r}function L(e,t,r,n,o){K(t,n,o,e,r,7);let i=Number(t&BigInt(4294967295));e[r+7]=i,i>>=8,e[r+6]=i,i>>=8,e[r+5]=i,i>>=8,e[r+4]=i;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=a,a>>=8,e[r+2]=a,a>>=8,e[r+1]=a,a>>=8,e[r]=a,r+8}function F(e,t,r,n,o,i){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function j(e,t,r,n,o){return t=+t,r>>>=0,o||F(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function M(e,t,r,n,o){return t=+t,r>>>=0,o||F(e,0,r,8),i.write(e,t,r,n,52,8),r+8}c.prototype.slice=function(e,t){const r=this.length;(e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);const n=this.subarray(e,t);return Object.setPrototypeOf(n,c.prototype),n},c.prototype.readUintLE=c.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=this[e],o=1,i=0;for(;++i<t&&(o*=256);)n+=this[e+i]*o;return n},c.prototype.readUintBE=c.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=this[e+--t],o=1;for(;t>0&&(o*=256);)n+=this[e+--t]*o;return n},c.prototype.readUint8=c.prototype.readUInt8=function(e,t){return e>>>=0,t||_(e,1,this.length),this[e]},c.prototype.readUint16LE=c.prototype.readUInt16LE=function(e,t){return e>>>=0,t||_(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUint16BE=c.prototype.readUInt16BE=function(e,t){return e>>>=0,t||_(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUint32LE=c.prototype.readUInt32LE=function(e,t){return e>>>=0,t||_(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},c.prototype.readUint32BE=c.prototype.readUInt32BE=function(e,t){return e>>>=0,t||_(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readBigUInt64LE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,o=this[++e]+256*this[++e]+65536*this[++e]+r*2**24;return BigInt(n)+(BigInt(o)<<BigInt(32))}),c.prototype.readBigUInt64BE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=t*2**24+65536*this[++e]+256*this[++e]+this[++e],o=this[++e]*2**24+65536*this[++e]+256*this[++e]+r;return(BigInt(n)<<BigInt(32))+BigInt(o)}),c.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=this[e],o=1,i=0;for(;++i<t&&(o*=256);)n+=this[e+i]*o;return o*=128,n>=o&&(n-=Math.pow(2,8*t)),n},c.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=t,o=1,i=this[e+--n];for(;n>0&&(o*=256);)i+=this[e+--n]*o;return o*=128,i>=o&&(i-=Math.pow(2,8*t)),i},c.prototype.readInt8=function(e,t){return e>>>=0,t||_(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},c.prototype.readInt16LE=function(e,t){e>>>=0,t||_(e,2,this.length);const r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt16BE=function(e,t){e>>>=0,t||_(e,2,this.length);const r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt32LE=function(e,t){return e>>>=0,t||_(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,t){return e>>>=0,t||_(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readBigInt64LE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=this[e+4]+256*this[e+5]+65536*this[e+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)}),c.prototype.readBigInt64BE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(n)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+r)}),c.prototype.readFloatLE=function(e,t){return e>>>=0,t||_(e,4,this.length),i.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,t){return e>>>=0,t||_(e,4,this.length),i.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,t){return e>>>=0,t||_(e,8,this.length),i.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,t){return e>>>=0,t||_(e,8,this.length),i.read(this,e,!1,52,8)},c.prototype.writeUintLE=c.prototype.writeUIntLE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||U(this,e,t,r,Math.pow(2,8*r)-1,0);let o=1,i=0;for(this[t]=255&e;++i<r&&(o*=256);)this[t+i]=e/o&255;return t+r},c.prototype.writeUintBE=c.prototype.writeUIntBE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||U(this,e,t,r,Math.pow(2,8*r)-1,0);let o=r-1,i=1;for(this[t+o]=255&e;--o>=0&&(i*=256);)this[t+o]=e/i&255;return t+r},c.prototype.writeUint8=c.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,1,255,0),this[t]=255&e,t+1},c.prototype.writeUint16LE=c.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},c.prototype.writeUint16BE=c.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},c.prototype.writeUint32LE=c.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},c.prototype.writeUint32BE=c.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},c.prototype.writeBigUInt64LE=Q(function(e,t=0){return N(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeBigUInt64BE=Q(function(e,t=0){return L(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);U(this,e,t,r,n-1,-n)}let o=0,i=1,a=0;for(this[t]=255&e;++o<r&&(i*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/i|0)-a&255;return t+r},c.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);U(this,e,t,r,n-1,-n)}let o=r-1,i=1,a=0;for(this[t+o]=255&e;--o>=0&&(i*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/i|0)-a&255;return t+r},c.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},c.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},c.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},c.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},c.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},c.prototype.writeBigInt64LE=Q(function(e,t=0){return N(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),c.prototype.writeBigInt64BE=Q(function(e,t=0){return L(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),c.prototype.writeFloatLE=function(e,t,r){return j(this,e,t,!0,r)},c.prototype.writeFloatBE=function(e,t,r){return j(this,e,t,!1,r)},c.prototype.writeDoubleLE=function(e,t,r){return M(this,e,t,!0,r)},c.prototype.writeDoubleBE=function(e,t,r){return M(this,e,t,!1,r)},c.prototype.copy=function(e,t,r,n){if(!c.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);const o=n-r;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),o},c.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!c.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===e.length){const t=e.charCodeAt(0);("utf8"===n&&t<128||"latin1"===n)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;let o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(o=t;o<r;++o)this[o]=e;else{const i=c.isBuffer(e)?e:c.from(e,n),a=i.length;if(0===a)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(o=0;o<r-t;++o)this[o+t]=i[o%a]}return this};const D={};function V(e,t,r){D[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function q(e){let t="",r=e.length;const n="-"===e[0]?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function K(e,t,r,n,o,i){if(e>r||e<t){const n="bigint"==typeof t?"n":"";let o;throw o=i>3?0===t||t===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(i+1)}${n}`:`>= -(2${n} ** ${8*(i+1)-1}${n}) and < 2 ** ${8*(i+1)-1}${n}`:`>= ${t}${n} and <= ${r}${n}`,new D.ERR_OUT_OF_RANGE("value",o,e)}!function(e,t,r){H(t,"offset"),void 0!==e[t]&&void 0!==e[t+r]||z(t,e.length-(r+1))}(n,o,i)}function H(e,t){if("number"!=typeof e)throw new D.ERR_INVALID_ARG_TYPE(t,"number",e)}function z(e,t,r){if(Math.floor(e)!==e)throw H(e,r),new D.ERR_OUT_OF_RANGE(r||"offset","an integer",e);if(t<0)throw new D.ERR_BUFFER_OUT_OF_BOUNDS;throw new D.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}V("ERR_BUFFER_OUT_OF_BOUNDS",function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),V("ERR_INVALID_ARG_TYPE",function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`},TypeError),V("ERR_OUT_OF_RANGE",function(e,t,r){let n=`The value of "${e}" is out of range.`,o=r;return Number.isInteger(r)&&Math.abs(r)>2**32?o=q(String(r)):"bigint"==typeof r&&(o=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(o=q(o)),o+="n"),n+=` It must be ${t}. Received ${o}`,n},RangeError);const X=/[^+/0-9A-Za-z-_]/g;function $(e,t){let r;t=t||1/0;const n=e.length;let o=null;const i=[];for(let a=0;a<n;++a){if(r=e.charCodeAt(a),r>55295&&r<57344){if(!o){if(r>56319){(t-=3)>-1&&i.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&i.push(239,191,189);continue}o=r;continue}if(r<56320){(t-=3)>-1&&i.push(239,191,189),o=r;continue}r=65536+(o-55296<<10|r-56320)}else o&&(t-=3)>-1&&i.push(239,191,189);if(o=null,r<128){if((t-=1)<0)break;i.push(r)}else if(r<2048){if((t-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return i}function G(e){return n.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(X,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function W(e,t,r,n){let o;for(o=0;o<n&&!(o+r>=t.length||o>=e.length);++o)t[o+r]=e[o];return o}function Y(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function Z(e){return e!=e}const J=function(){const e="0123456789abcdef",t=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let o=0;o<16;++o)t[n+o]=e[r]+e[o]}return t}();function Q(e){return"undefined"==typeof BigInt?ee:e}function ee(){throw new Error("BigInt not supported")}},251:(e,t)=>{t.read=function(e,t,r,n,o){var i,a,s=8*o-n-1,u=(1<<s)-1,c=u>>1,l=-7,f=r?o-1:0,p=r?-1:1,d=e[t+f];for(f+=p,i=d&(1<<-l)-1,d>>=-l,l+=s;l>0;i=256*i+e[t+f],f+=p,l-=8);for(a=i&(1<<-l)-1,i>>=-l,l+=n;l>0;a=256*a+e[t+f],f+=p,l-=8);if(0===i)i=1-c;else{if(i===u)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,n),i-=c}return(d?-1:1)*a*Math.pow(2,i-n)},t.write=function(e,t,r,n,o,i){var a,s,u,c=8*i-o-1,l=(1<<c)-1,f=l>>1,p=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:i-1,h=n?1:-1,y=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=l):(a=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-a))<1&&(a--,u*=2),(t+=a+f>=1?p/u:p*Math.pow(2,1-f))*u>=2&&(a++,u/=2),a+f>=l?(s=0,a=l):a+f>=1?(s=(t*u-1)*Math.pow(2,o),a+=f):(s=t*Math.pow(2,f-1)*Math.pow(2,o),a=0));o>=8;e[r+d]=255&s,d+=h,s/=256,o-=8);for(a=a<<o|s,c+=o;c>0;e[r+d]=255&a,d+=h,a/=256,c-=8);e[r+d-h]|=128*y}}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}return r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(281)})(),e.exports=n()},3918:(e,t,r)=>{"use strict";var n=r(5606);function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach(function(t){a(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function a(e,t,r){return(t=u(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,u(n.key),n)}}function u(e){var t=function(e,t){if("object"!==m(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!==m(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"===m(t)?t:String(t)}function c(e,t){if(t&&("object"===m(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return l(e)}function l(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function f(e){var t="function"==typeof Map?new Map:void 0;return f=function(e){if(null===e||(r=e,-1===Function.toString.call(r).indexOf("[native code]")))return e;var r;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return p(e,arguments,y(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),h(n,e)},f(e)}function p(e,t,r){return p=d()?Reflect.construct.bind():function(e,t,r){var n=[null];n.push.apply(n,t);var o=new(Function.bind.apply(e,n));return r&&h(o,r.prototype),o},p.apply(null,arguments)}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}function h(e,t){return h=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},h(e,t)}function y(e){return y=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},y(e)}function m(e){return m="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},m(e)}var g=r(537).inspect,v=r(9597).codes.ERR_INVALID_ARG_TYPE;function b(e,t,r){return(void 0===r||r>e.length)&&(r=e.length),e.substring(r-t.length,r)===t}var w="",S="",E="",k="",A={deepStrictEqual:"Expected values to be strictly deep-equal:",strictEqual:"Expected values to be strictly equal:",strictEqualObject:'Expected "actual" to be reference-equal to "expected":',deepEqual:"Expected values to be loosely deep-equal:",equal:"Expected values to be loosely equal:",notDeepStrictEqual:'Expected "actual" not to be strictly deep-equal to:',notStrictEqual:'Expected "actual" to be strictly unequal to:',notStrictEqualObject:'Expected "actual" not to be reference-equal to "expected":',notDeepEqual:'Expected "actual" not to be loosely deep-equal to:',notEqual:'Expected "actual" to be loosely unequal to:',notIdentical:"Values identical but not reference-equal:"};function T(e){var t=Object.keys(e),r=Object.create(Object.getPrototypeOf(e));return t.forEach(function(t){r[t]=e[t]}),Object.defineProperty(r,"message",{value:e.message}),r}function O(e){return g(e,{compact:!1,customInspect:!1,depth:1e3,maxArrayLength:1/0,showHidden:!1,breakLength:1/0,showProxy:!1,sorted:!0,getters:!0})}function x(e,t,r){var o="",i="",a=0,s="",u=!1,c=O(e),l=c.split("\n"),f=O(t).split("\n"),p=0,d="";if("strictEqual"===r&&"object"===m(e)&&"object"===m(t)&&null!==e&&null!==t&&(r="strictEqualObject"),1===l.length&&1===f.length&&l[0]!==f[0]){var h=l[0].length+f[0].length;if(h<=10){if(!("object"===m(e)&&null!==e||"object"===m(t)&&null!==t||0===e&&0===t))return"".concat(A[r],"\n\n")+"".concat(l[0]," !== ").concat(f[0],"\n")}else if("strictEqualObject"!==r){if(h<(n.stderr&&n.stderr.isTTY?n.stderr.columns:80)){for(;l[0][p]===f[0][p];)p++;p>2&&(d="\n  ".concat(function(e,t){if(t=Math.floor(t),0==e.length||0==t)return"";var r=e.length*t;for(t=Math.floor(Math.log(t)/Math.log(2));t;)e+=e,t--;return e+e.substring(0,r-e.length)}(" ",p),"^"),p=0)}}}for(var y=l[l.length-1],g=f[f.length-1];y===g&&(p++<2?s="\n  ".concat(y).concat(s):o=y,l.pop(),f.pop(),0!==l.length&&0!==f.length);)y=l[l.length-1],g=f[f.length-1];var v=Math.max(l.length,f.length);if(0===v){var T=c.split("\n");if(T.length>30)for(T[26]="".concat(w,"...").concat(k);T.length>27;)T.pop();return"".concat(A.notIdentical,"\n\n").concat(T.join("\n"),"\n")}p>3&&(s="\n".concat(w,"...").concat(k).concat(s),u=!0),""!==o&&(s="\n  ".concat(o).concat(s),o="");var x=0,P=A[r]+"\n".concat(S,"+ actual").concat(k," ").concat(E,"- expected").concat(k),B=" ".concat(w,"...").concat(k," Lines skipped");for(p=0;p<v;p++){var I=p-a;if(l.length<p+1)I>1&&p>2&&(I>4?(i+="\n".concat(w,"...").concat(k),u=!0):I>3&&(i+="\n  ".concat(f[p-2]),x++),i+="\n  ".concat(f[p-1]),x++),a=p,o+="\n".concat(E,"-").concat(k," ").concat(f[p]),x++;else if(f.length<p+1)I>1&&p>2&&(I>4?(i+="\n".concat(w,"...").concat(k),u=!0):I>3&&(i+="\n  ".concat(l[p-2]),x++),i+="\n  ".concat(l[p-1]),x++),a=p,i+="\n".concat(S,"+").concat(k," ").concat(l[p]),x++;else{var C=f[p],R=l[p],_=R!==C&&(!b(R,",")||R.slice(0,-1)!==C);_&&b(C,",")&&C.slice(0,-1)===R&&(_=!1,R+=","),_?(I>1&&p>2&&(I>4?(i+="\n".concat(w,"...").concat(k),u=!0):I>3&&(i+="\n  ".concat(l[p-2]),x++),i+="\n  ".concat(l[p-1]),x++),a=p,i+="\n".concat(S,"+").concat(k," ").concat(R),o+="\n".concat(E,"-").concat(k," ").concat(C),x+=2):(i+=o,o="",1!==I&&0!==p||(i+="\n  ".concat(R),x++))}if(x>20&&p<v-2)return"".concat(P).concat(B,"\n").concat(i,"\n").concat(w,"...").concat(k).concat(o,"\n")+"".concat(w,"...").concat(k)}return"".concat(P).concat(u?B:"","\n").concat(i).concat(o).concat(s).concat(d)}var P=function(e,t){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&h(e,t)}(b,e);var r,o,a,u,f,p=(r=b,o=d(),function(){var e,t=y(r);if(o){var n=y(this).constructor;e=Reflect.construct(t,arguments,n)}else e=t.apply(this,arguments);return c(this,e)});function b(e){var t;if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,b),"object"!==m(e)||null===e)throw new v("options","Object",e);var r=e.message,o=e.operator,i=e.stackStartFn,a=e.actual,s=e.expected,u=Error.stackTraceLimit;if(Error.stackTraceLimit=0,null!=r)t=p.call(this,String(r));else if(n.stderr&&n.stderr.isTTY&&(n.stderr&&n.stderr.getColorDepth&&1!==n.stderr.getColorDepth()?(w="\x1b[34m",S="\x1b[32m",k="\x1b[39m",E="\x1b[31m"):(w="",S="",k="",E="")),"object"===m(a)&&null!==a&&"object"===m(s)&&null!==s&&"stack"in a&&a instanceof Error&&"stack"in s&&s instanceof Error&&(a=T(a),s=T(s)),"deepStrictEqual"===o||"strictEqual"===o)t=p.call(this,x(a,s,o));else if("notDeepStrictEqual"===o||"notStrictEqual"===o){var f=A[o],d=O(a).split("\n");if("notStrictEqual"===o&&"object"===m(a)&&null!==a&&(f=A.notStrictEqualObject),d.length>30)for(d[26]="".concat(w,"...").concat(k);d.length>27;)d.pop();t=1===d.length?p.call(this,"".concat(f," ").concat(d[0])):p.call(this,"".concat(f,"\n\n").concat(d.join("\n"),"\n"))}else{var h=O(a),y="",g=A[o];"notDeepEqual"===o||"notEqual"===o?(h="".concat(A[o],"\n\n").concat(h)).length>1024&&(h="".concat(h.slice(0,1021),"...")):(y="".concat(O(s)),h.length>512&&(h="".concat(h.slice(0,509),"...")),y.length>512&&(y="".concat(y.slice(0,509),"...")),"deepEqual"===o||"equal"===o?h="".concat(g,"\n\n").concat(h,"\n\nshould equal\n\n"):y=" ".concat(o," ").concat(y)),t=p.call(this,"".concat(h).concat(y))}return Error.stackTraceLimit=u,t.generatedMessage=!r,Object.defineProperty(l(t),"name",{value:"AssertionError [ERR_ASSERTION]",enumerable:!1,writable:!0,configurable:!0}),t.code="ERR_ASSERTION",t.actual=a,t.expected=s,t.operator=o,Error.captureStackTrace&&Error.captureStackTrace(l(t),i),t.stack,t.name="AssertionError",c(t)}return a=b,(u=[{key:"toString",value:function(){return"".concat(this.name," [").concat(this.code,"]: ").concat(this.message)}},{key:t,value:function(e,t){return g(this,i(i({},t),{},{customInspect:!1,depth:0}))}}])&&s(a.prototype,u),f&&s(a,f),Object.defineProperty(a,"prototype",{writable:!1}),b}(f(Error),g.custom);e.exports=P},4035:(e,t,r)=>{"use strict";var n,o=r(6556),i=r(9092)(),a=r(9957),s=r(5795);if(i){var u=o("RegExp.prototype.exec"),c={},l=function(){throw c},f={toString:l,valueOf:l};"symbol"==typeof Symbol.toPrimitive&&(f[Symbol.toPrimitive]=l),n=function(e){if(!e||"object"!=typeof e)return!1;var t=s(e,"lastIndex");if(!(t&&a(t,"value")))return!1;try{u(e,f)}catch(e){return e===c}}}else{var p=o("Object.prototype.toString");n=function(e){return!(!e||"object"!=typeof e&&"function"!=typeof e)&&"[object RegExp]"===p(e)}}e.exports=n},4039:(e,t,r)=>{"use strict";var n="undefined"!=typeof Symbol&&Symbol,o=r(1333);e.exports=function(){return"function"==typeof n&&("function"==typeof Symbol&&("symbol"==typeof n("foo")&&("symbol"==typeof Symbol("bar")&&o())))}},4107:(e,t,r)=>{"use strict";var n=r(6698),o=r(392),i=r(2861).Buffer,a=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],s=new Array(64);function u(){this.init(),this._w=s,o.call(this,64,56)}function c(e,t,r){return r^e&(t^r)}function l(e,t,r){return e&t|r&(e|t)}function f(e){return(e>>>2|e<<30)^(e>>>13|e<<19)^(e>>>22|e<<10)}function p(e){return(e>>>6|e<<26)^(e>>>11|e<<21)^(e>>>25|e<<7)}function d(e){return(e>>>7|e<<25)^(e>>>18|e<<14)^e>>>3}function h(e){return(e>>>17|e<<15)^(e>>>19|e<<13)^e>>>10}n(u,o),u.prototype.init=function(){return this._a=1779033703,this._b=3144134277,this._c=1013904242,this._d=2773480762,this._e=1359893119,this._f=2600822924,this._g=528734635,this._h=1541459225,this},u.prototype._update=function(e){for(var t=this._w,r=0|this._a,n=0|this._b,o=0|this._c,i=0|this._d,s=0|this._e,u=0|this._f,y=0|this._g,m=0|this._h,g=0;g<16;++g)t[g]=e.readInt32BE(4*g);for(;g<64;++g)t[g]=h(t[g-2])+t[g-7]+d(t[g-15])+t[g-16]|0;for(var v=0;v<64;++v){var b=m+p(s)+c(s,u,y)+a[v]+t[v]|0,w=f(r)+l(r,n,o)|0;m=y,y=u,u=s,s=i+b|0,i=o,o=n,n=r,r=b+w|0}this._a=r+this._a|0,this._b=n+this._b|0,this._c=o+this._c|0,this._d=i+this._d|0,this._e=s+this._e|0,this._f=u+this._f|0,this._g=y+this._g|0,this._h=m+this._h|0},u.prototype._hash=function(){var e=i.allocUnsafe(32);return e.writeInt32BE(this._a,0),e.writeInt32BE(this._b,4),e.writeInt32BE(this._c,8),e.writeInt32BE(this._d,12),e.writeInt32BE(this._e,16),e.writeInt32BE(this._f,20),e.writeInt32BE(this._g,24),e.writeInt32BE(this._h,28),e},e.exports=u},4133:(e,t,r)=>{"use strict";var n=r(487),o=r(8452),i=r(3003),a=r(6642),s=r(2464),u=n(a(),Number);o(u,{getPolyfill:a,implementation:i,shim:s}),e.exports=u},4148:(e,t,r)=>{"use strict";var n=r(5606),o=r(6763);function i(e){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i(e)}function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,u(n.key),n)}}function s(e,t,r){return t&&a(e.prototype,t),r&&a(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}function u(e){var t=function(e,t){if("object"!==i(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!==i(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"===i(t)?t:String(t)}var c,l,f=r(9597).codes,p=f.ERR_AMBIGUOUS_ARGUMENT,d=f.ERR_INVALID_ARG_TYPE,h=f.ERR_INVALID_ARG_VALUE,y=f.ERR_INVALID_RETURN_VALUE,m=f.ERR_MISSING_ARGS,g=r(3918),v=r(537).inspect,b=r(537).types,w=b.isPromise,S=b.isRegExp,E=r(9133)(),k=r(9394)(),A=r(8075)("RegExp.prototype.test");new Map;function T(){var e=r(2299);c=e.isDeepEqual,l=e.isDeepStrictEqual}var O=!1,x=e.exports=C,P={};function B(e){if(e.message instanceof Error)throw e.message;throw new g(e)}function I(e,t,r,n){if(!r){var o=!1;if(0===t)o=!0,n="No value argument passed to `assert.ok()`";else if(n instanceof Error)throw n;var i=new g({actual:r,expected:!0,message:n,operator:"==",stackStartFn:e});throw i.generatedMessage=o,i}}function C(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];I.apply(void 0,[C,t.length].concat(t))}x.fail=function e(t,r,i,a,s){var u,c=arguments.length;if(0===c)u="Failed";else if(1===c)i=t,t=void 0;else{if(!1===O)O=!0,(n.emitWarning?n.emitWarning:o.warn.bind(o))("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.","DeprecationWarning","DEP0094");2===c&&(a="!=")}if(i instanceof Error)throw i;var l={actual:t,expected:r,operator:void 0===a?"fail":a,stackStartFn:s||e};void 0!==i&&(l.message=i);var f=new g(l);throw u&&(f.message=u,f.generatedMessage=!0),f},x.AssertionError=g,x.ok=C,x.equal=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");t!=r&&B({actual:t,expected:r,message:n,operator:"==",stackStartFn:e})},x.notEqual=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");t==r&&B({actual:t,expected:r,message:n,operator:"!=",stackStartFn:e})},x.deepEqual=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");void 0===c&&T(),c(t,r)||B({actual:t,expected:r,message:n,operator:"deepEqual",stackStartFn:e})},x.notDeepEqual=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");void 0===c&&T(),c(t,r)&&B({actual:t,expected:r,message:n,operator:"notDeepEqual",stackStartFn:e})},x.deepStrictEqual=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");void 0===c&&T(),l(t,r)||B({actual:t,expected:r,message:n,operator:"deepStrictEqual",stackStartFn:e})},x.notDeepStrictEqual=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");void 0===c&&T();l(t,r)&&B({actual:t,expected:r,message:n,operator:"notDeepStrictEqual",stackStartFn:e})},x.strictEqual=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");k(t,r)||B({actual:t,expected:r,message:n,operator:"strictEqual",stackStartFn:e})},x.notStrictEqual=function e(t,r,n){if(arguments.length<2)throw new m("actual","expected");k(t,r)&&B({actual:t,expected:r,message:n,operator:"notStrictEqual",stackStartFn:e})};var R=s(function e(t,r,n){var o=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),r.forEach(function(e){e in t&&(void 0!==n&&"string"==typeof n[e]&&S(t[e])&&A(t[e],n[e])?o[e]=n[e]:o[e]=t[e])})});function _(e,t,r,n){if("function"!=typeof t){if(S(t))return A(t,e);if(2===arguments.length)throw new d("expected",["Function","RegExp"],t);if("object"!==i(e)||null===e){var o=new g({actual:e,expected:t,message:r,operator:"deepStrictEqual",stackStartFn:n});throw o.operator=n.name,o}var a=Object.keys(t);if(t instanceof Error)a.push("name","message");else if(0===a.length)throw new h("error",t,"may not be an empty object");return void 0===c&&T(),a.forEach(function(o){"string"==typeof e[o]&&S(t[o])&&A(t[o],e[o])||function(e,t,r,n,o,i){if(!(r in e)||!l(e[r],t[r])){if(!n){var a=new R(e,o),s=new R(t,o,e),u=new g({actual:a,expected:s,operator:"deepStrictEqual",stackStartFn:i});throw u.actual=e,u.expected=t,u.operator=i.name,u}B({actual:e,expected:t,message:n,operator:i.name,stackStartFn:i})}}(e,t,o,r,a,n)}),!0}return void 0!==t.prototype&&e instanceof t||!Error.isPrototypeOf(t)&&!0===t.call({},e)}function U(e){if("function"!=typeof e)throw new d("fn","Function",e);try{e()}catch(e){return e}return P}function N(e){return w(e)||null!==e&&"object"===i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function L(e){return Promise.resolve().then(function(){var t;if("function"==typeof e){if(!N(t=e()))throw new y("instance of Promise","promiseFn",t)}else{if(!N(e))throw new d("promiseFn",["Function","Promise"],e);t=e}return Promise.resolve().then(function(){return t}).then(function(){return P}).catch(function(e){return e})})}function F(e,t,r,n){if("string"==typeof r){if(4===arguments.length)throw new d("error",["Object","Error","Function","RegExp"],r);if("object"===i(t)&&null!==t){if(t.message===r)throw new p("error/message",'The error message "'.concat(t.message,'" is identical to the message.'))}else if(t===r)throw new p("error/message",'The error "'.concat(t,'" is identical to the message.'));n=r,r=void 0}else if(null!=r&&"object"!==i(r)&&"function"!=typeof r)throw new d("error",["Object","Error","Function","RegExp"],r);if(t===P){var o="";r&&r.name&&(o+=" (".concat(r.name,")")),o+=n?": ".concat(n):".";var a="rejects"===e.name?"rejection":"exception";B({actual:void 0,expected:r,operator:e.name,message:"Missing expected ".concat(a).concat(o),stackStartFn:e})}if(r&&!_(t,r,n,e))throw t}function j(e,t,r,n){if(t!==P){if("string"==typeof r&&(n=r,r=void 0),!r||_(t,r)){var o=n?": ".concat(n):".",i="doesNotReject"===e.name?"rejection":"exception";B({actual:t,expected:r,operator:e.name,message:"Got unwanted ".concat(i).concat(o,"\n")+'Actual message: "'.concat(t&&t.message,'"'),stackStartFn:e})}throw t}}function M(e,t,r,n,o){if(!S(t))throw new d("regexp","RegExp",t);var a="match"===o;if("string"!=typeof e||A(t,e)!==a){if(r instanceof Error)throw r;var s=!r;r=r||("string"!=typeof e?'The "string" argument must be of type string. Received type '+"".concat(i(e)," (").concat(v(e),")"):(a?"The input did not match the regular expression ":"The input was expected to not match the regular expression ")+"".concat(v(t),". Input:\n\n").concat(v(e),"\n"));var u=new g({actual:e,expected:t,message:r,operator:o,stackStartFn:n});throw u.generatedMessage=s,u}}function D(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];I.apply(void 0,[D,t.length].concat(t))}x.throws=function e(t){for(var r=arguments.length,n=new Array(r>1?r-1:0),o=1;o<r;o++)n[o-1]=arguments[o];F.apply(void 0,[e,U(t)].concat(n))},x.rejects=function e(t){for(var r=arguments.length,n=new Array(r>1?r-1:0),o=1;o<r;o++)n[o-1]=arguments[o];return L(t).then(function(t){return F.apply(void 0,[e,t].concat(n))})},x.doesNotThrow=function e(t){for(var r=arguments.length,n=new Array(r>1?r-1:0),o=1;o<r;o++)n[o-1]=arguments[o];j.apply(void 0,[e,U(t)].concat(n))},x.doesNotReject=function e(t){for(var r=arguments.length,n=new Array(r>1?r-1:0),o=1;o<r;o++)n[o-1]=arguments[o];return L(t).then(function(t){return j.apply(void 0,[e,t].concat(n))})},x.ifError=function e(t){if(null!=t){var r="ifError got unwanted exception: ";"object"===i(t)&&"string"==typeof t.message?0===t.message.length&&t.constructor?r+=t.constructor.name:r+=t.message:r+=v(t);var n=new g({actual:t,expected:null,operator:"ifError",message:r,stackStartFn:e}),o=t.stack;if("string"==typeof o){var a=o.split("\n");a.shift();for(var s=n.stack.split("\n"),u=0;u<a.length;u++){var c=s.indexOf(a[u]);if(-1!==c){s=s.slice(0,c);break}}n.stack="".concat(s.join("\n"),"\n").concat(a.join("\n"))}throw n}},x.match=function e(t,r,n){M(t,r,n,e,"match")},x.doesNotMatch=function e(t,r,n){M(t,r,n,e,"doesNotMatch")},x.strict=E(D,x,{equal:x.strictEqual,deepEqual:x.deepStrictEqual,notEqual:x.notStrictEqual,notDeepEqual:x.notDeepStrictEqual}),x.strict.strict=x.strict},4372:(e,t,r)=>{"use strict";var n=r(9675),o=r(6556)("TypedArray.prototype.buffer",!0),i=r(5680);e.exports=o||function(e){if(!i(e))throw new n("Not a Typed Array");return e.buffer}},4459:e=>{"use strict";e.exports=Number.isNaN||function(e){return e!=e}},4634:e=>{var t={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==t.call(e)}},5345:e=>{"use strict";e.exports=URIError},5360:(e,t)=>{"use strict";var r=function(e,t){return t||(t={}),e.split("").forEach(function(e,r){e in t||(t[e]=r)}),t},n={alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",charmap:{0:14,1:8}};n.charmap=r(n.alphabet,n.charmap);var o={alphabet:"0123456789ABCDEFGHJKMNPQRSTVWXYZ",charmap:{O:0,I:1,L:1}};o.charmap=r(o.alphabet,o.charmap);var i={alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",charmap:{}};function a(e){if(this.buf=[],this.shift=8,this.carry=0,e){switch(e.type){case"rfc4648":this.charmap=t.rfc4648.charmap;break;case"crockford":this.charmap=t.crockford.charmap;break;case"base32hex":this.charmap=t.base32hex.charmap;break;default:throw new Error("invalid type")}e.charmap&&(this.charmap=e.charmap)}}function s(e){if(this.buf="",this.shift=3,this.carry=0,e){switch(e.type){case"rfc4648":this.alphabet=t.rfc4648.alphabet;break;case"crockford":this.alphabet=t.crockford.alphabet;break;case"base32hex":this.alphabet=t.base32hex.alphabet;break;default:throw new Error("invalid type")}e.alphabet?this.alphabet=e.alphabet:e.lc&&(this.alphabet=this.alphabet.toLowerCase())}}i.charmap=r(i.alphabet,i.charmap),a.prototype.charmap=n.charmap,a.prototype.write=function(e){var t=this.charmap,r=this.buf,n=this.shift,o=this.carry;return e.toUpperCase().split("").forEach(function(e){if("="!=e){var i=255&t[e];(n-=5)>0?o|=i<<n:n<0?(r.push(o|i>>-n),o=i<<(n+=8)&255):(r.push(o|i),n=8,o=0)}}),this.shift=n,this.carry=o,this},a.prototype.finalize=function(e){return e&&this.write(e),8!==this.shift&&0!==this.carry&&(this.buf.push(this.carry),this.shift=8,this.carry=0),this.buf},s.prototype.alphabet=n.alphabet,s.prototype.write=function(e){var t,r,n,o=this.shift,i=this.carry;for(n=0;n<e.length;n++)t=i|(r=e[n])>>o,this.buf+=this.alphabet[31&t],o>5&&(t=r>>(o-=5),this.buf+=this.alphabet[31&t]),i=r<<(o=5-o),o=8-o;return this.shift=o,this.carry=i,this},s.prototype.finalize=function(e){return e&&this.write(e),3!==this.shift&&(this.buf+=this.alphabet[31&this.carry],this.shift=3,this.carry=0),this.buf},t.encode=function(e,t){return new s(t).finalize(e)},t.decode=function(e,t){return new a(t).finalize(e)},t.Decoder=a,t.Encoder=s,t.charmap=r,t.crockford=o,t.rfc4648=n,t.base32hex=i},5377:(e,t,r)=>{"use strict";var n=r(2861).Buffer,o=r(4634),i=r(4372),a=ArrayBuffer.isView||function(e){try{return i(e),!0}catch(e){return!1}},s="undefined"!=typeof Uint8Array,u="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c=u&&(n.prototype instanceof Uint8Array||n.TYPED_ARRAY_SUPPORT);e.exports=function(e,t){if(e instanceof n)return e;if("string"==typeof e)return n.from(e,t);if(u&&a(e)){if(0===e.byteLength)return n.alloc(0);if(c){var r=n.from(e.buffer,e.byteOffset,e.byteLength);if(r.byteLength===e.byteLength)return r}var i=e instanceof Uint8Array?e:new Uint8Array(e.buffer,e.byteOffset,e.byteLength),l=n.from(i);if(l.length===e.byteLength)return l}if(s&&e instanceof Uint8Array)return n.from(e);var f=o(e);if(f)for(var p=0;p<e.length;p+=1){var d=e[p];if("number"!=typeof d||d<0||d>255||~~d!==d)throw new RangeError("Array items must be numbers in the range 0-255.")}if(f||n.isBuffer(e)&&e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e))return n.from(e);throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.')}},5606:e=>{var t,r,n=e.exports={};function o(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function a(e){if(t===setTimeout)return setTimeout(e,0);if((t===o||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:o}catch(e){t=o}try{r="function"==typeof clearTimeout?clearTimeout:i}catch(e){r=i}}();var s,u=[],c=!1,l=-1;function f(){c&&s&&(c=!1,s.length?u=s.concat(u):l=-1,u.length&&p())}function p(){if(!c){var e=a(f);c=!0;for(var t=u.length;t;){for(s=u,u=[];++l<t;)s&&s[l].run();l=-1,t=u.length}s=null,c=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===i||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{return r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function d(e,t){this.fun=e,this.array=t}function h(){}n.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];u.push(new d(e,t)),1!==u.length||c||a(p)},d.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.browser=!0,n.env={},n.argv=[],n.version="",n.versions={},n.on=h,n.addListener=h,n.once=h,n.off=h,n.removeListener=h,n.removeAllListeners=h,n.emit=h,n.prependListener=h,n.prependOnceListener=h,n.listeners=function(e){return[]},n.binding=function(e){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(e){throw new Error("process.chdir is not supported")},n.umask=function(){return 0}},5680:(e,t,r)=>{"use strict";var n=r(5767);e.exports=function(e){return!!n(e)}},5767:(e,t,r)=>{"use strict";var n=r(2682),o=r(9209),i=r(487),a=r(6556),s=r(5795),u=r(3628),c=a("Object.prototype.toString"),l=r(9092)(),f="undefined"==typeof globalThis?r.g:globalThis,p=o(),d=a("String.prototype.slice"),h=a("Array.prototype.indexOf",!0)||function(e,t){for(var r=0;r<e.length;r+=1)if(e[r]===t)return r;return-1},y={__proto__:null};n(p,l&&s&&u?function(e){var t=new f[e];if(Symbol.toStringTag in t&&u){var r=u(t),n=s(r,Symbol.toStringTag);if(!n&&r){var o=u(r);n=s(o,Symbol.toStringTag)}y["$"+e]=i(n.get)}}:function(e){var t=new f[e],r=t.slice||t.set;r&&(y["$"+e]=i(r))});e.exports=function(e){if(!e||"object"!=typeof e)return!1;if(!l){var t=d(c(e),8,-1);return h(p,t)>-1?t:"Object"===t&&function(e){var t=!1;return n(y,function(r,n){if(!t)try{r(e),t=d(n,1)}catch(e){}}),t}(e)}return s?function(e){var t=!1;return n(y,function(r,n){if(!t)try{"$"+r(e)===n&&(t=d(n,1))}catch(e){}}),t}(e):null}},5795:(e,t,r)=>{"use strict";var n=r(6549);if(n)try{n([],"length")}catch(e){n=null}e.exports=n},5880:e=>{"use strict";e.exports=Math.pow},6188:e=>{"use strict";e.exports=Math.max},6549:e=>{"use strict";e.exports=Object.getOwnPropertyDescriptor},6556:(e,t,r)=>{"use strict";var n=r(453),o=r(3126),i=o([n("%String.prototype.indexOf%")]);e.exports=function(e,t){var r=n(e,!!t);return"function"==typeof r&&i(e,".prototype.")>-1?o([r]):r}},6576:(e,t,r)=>{"use strict";var n=r(9394),o=r(8452);e.exports=function(){var e=n();return o(Object,{is:e},{is:function(){return Object.is!==e}}),e}},6578:e=>{"use strict";e.exports=["Float16Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},6642:(e,t,r)=>{"use strict";var n=r(3003);e.exports=function(){return Number.isNaN&&Number.isNaN(NaN)&&!Number.isNaN("a")?Number.isNaN:n}},6698:e=>{"function"==typeof Object.create?e.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:e.exports=function(e,t){if(t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}}},6710:(e,t,r)=>{"use strict";var n=r(6698),o=r(4107),i=r(392),a=r(2861).Buffer,s=new Array(64);function u(){this.init(),this._w=s,i.call(this,64,56)}n(u,o),u.prototype.init=function(){return this._a=3238371032,this._b=914150663,this._c=812702999,this._d=4144912697,this._e=4290775857,this._f=1750603025,this._g=1694076839,this._h=3204075428,this},u.prototype._hash=function(){var e=a.allocUnsafe(28);return e.writeInt32BE(this._a,0),e.writeInt32BE(this._b,4),e.writeInt32BE(this._c,8),e.writeInt32BE(this._d,12),e.writeInt32BE(this._e,16),e.writeInt32BE(this._f,20),e.writeInt32BE(this._g,24),e},e.exports=u},6743:(e,t,r)=>{"use strict";var n=r(9353);e.exports=Function.prototype.bind||n},6763:(e,t,r)=>{var n=r(537),o=r(4148);function i(){return(new Date).getTime()}var a,s=Array.prototype.slice,u={};a=void 0!==r.g&&r.g.console?r.g.console:"undefined"!=typeof window&&window.console?window.console:{};for(var c=[[function(){},"log"],[function(){a.log.apply(a,arguments)},"info"],[function(){a.log.apply(a,arguments)},"warn"],[function(){a.warn.apply(a,arguments)},"error"],[function(e){u[e]=i()},"time"],[function(e){var t=u[e];if(!t)throw new Error("No such label: "+e);delete u[e];var r=i()-t;a.log(e+": "+r+"ms")},"timeEnd"],[function(){var e=new Error;e.name="Trace",e.message=n.format.apply(null,arguments),a.error(e.stack)},"trace"],[function(e){a.log(n.inspect(e)+"\n")},"dir"],[function(e){if(!e){var t=s.call(arguments,1);o.ok(!1,n.format.apply(null,t))}},"assert"]],l=0;l<c.length;l++){var f=c[l],p=f[0],d=f[1];a[d]||(a[d]=p)}e.exports=a},6897:(e,t,r)=>{"use strict";var n=r(453),o=r(41),i=r(592)(),a=r(5795),s=r(9675),u=n("%Math.floor%");e.exports=function(e,t){if("function"!=typeof e)throw new s("`fn` is not a function");if("number"!=typeof t||t<0||t>4294967295||u(t)!==t)throw new s("`length` must be a positive 32-bit integer");var r=arguments.length>2&&!!arguments[2],n=!0,c=!0;if("length"in e&&a){var l=a(e,"length");l&&!l.configurable&&(n=!1),l&&!l.writable&&(c=!1)}return(n||c||!r)&&(i?o(e,"length",t,!0,!0):o(e,"length",t)),e}},7119:e=>{"use strict";e.exports="undefined"!=typeof Reflect&&Reflect&&Reflect.apply},7176:(e,t,r)=>{"use strict";var n,o=r(3126),i=r(5795);try{n=[].__proto__===Array.prototype}catch(e){if(!e||"object"!=typeof e||!("code"in e)||"ERR_PROTO_ACCESS"!==e.code)throw e}var a=!!n&&i&&i(Object.prototype,"__proto__"),s=Object,u=s.getPrototypeOf;e.exports=a&&"function"==typeof a.get?o([a.get]):"function"==typeof u&&function(e){return u(null==e?e:s(e))}},7244:(e,t,r)=>{"use strict";var n=r(9092)(),o=r(6556)("Object.prototype.toString"),i=function(e){return!(n&&e&&"object"==typeof e&&Symbol.toStringTag in e)&&"[object Arguments]"===o(e)},a=function(e){return!!i(e)||null!==e&&"object"==typeof e&&"length"in e&&"number"==typeof e.length&&e.length>=0&&"[object Array]"!==o(e)&&"callee"in e&&"[object Function]"===o(e.callee)},s=function(){return i(arguments)}();i.isLegacyArguments=a,e.exports=s?i:a},7526:(e,t)=>{"use strict";t.byteLength=function(e){var t=s(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,i=s(e),a=i[0],u=i[1],c=new o(function(e,t,r){return 3*(t+r)/4-r}(0,a,u)),l=0,f=u>0?a-4:a;for(r=0;r<f;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],c[l++]=t>>16&255,c[l++]=t>>8&255,c[l++]=255&t;2===u&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,c[l++]=255&t);1===u&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,c[l++]=t>>8&255,c[l++]=255&t);return c},t.fromByteArray=function(e){for(var t,n=e.length,o=n%3,i=[],a=16383,s=0,u=n-o;s<u;s+=a)i.push(c(e,s,s+a>u?u:s+a));1===o?(t=e[n-1],i.push(r[t>>2]+r[t<<4&63]+"==")):2===o&&(t=(e[n-2]<<8)+e[n-1],i.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"="));return i.join("")};for(var r=[],n=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0;a<64;++a)r[a]=i[a],n[i.charCodeAt(a)]=a;function s(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function u(e){return r[e>>18&63]+r[e>>12&63]+r[e>>6&63]+r[63&e]}function c(e,t,r){for(var n,o=[],i=t;i<r;i+=3)n=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(255&e[i+2]),o.push(u(n));return o.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},7653:(e,t,r)=>{"use strict";var n=r(8452),o=r(487),i=r(9211),a=r(9394),s=r(6576),u=o(a(),Object);n(u,{getPolyfill:a,implementation:i,shim:s}),e.exports=u},7816:(e,t,r)=>{"use strict";var n=r(6698),o=r(392),i=r(2861).Buffer,a=[1518500249,1859775393,-1894007588,-899497514],s=new Array(80);function u(){this.init(),this._w=s,o.call(this,64,56)}function c(e){return e<<5|e>>>27}function l(e){return e<<30|e>>>2}function f(e,t,r,n){return 0===e?t&r|~t&n:2===e?t&r|t&n|r&n:t^r^n}n(u,o),u.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},u.prototype._update=function(e){for(var t=this._w,r=0|this._a,n=0|this._b,o=0|this._c,i=0|this._d,s=0|this._e,u=0;u<16;++u)t[u]=e.readInt32BE(4*u);for(;u<80;++u)t[u]=t[u-3]^t[u-8]^t[u-14]^t[u-16];for(var p=0;p<80;++p){var d=~~(p/20),h=c(r)+f(d,n,o,i)+s+t[p]+a[d]|0;s=i,i=o,o=l(n),n=r,r=h}this._a=r+this._a|0,this._b=n+this._b|0,this._c=o+this._c|0,this._d=i+this._d|0,this._e=s+this._e|0},u.prototype._hash=function(){var e=i.allocUnsafe(20);return e.writeInt32BE(0|this._a,0),e.writeInt32BE(0|this._b,4),e.writeInt32BE(0|this._c,8),e.writeInt32BE(0|this._d,12),e.writeInt32BE(0|this._e,16),e},e.exports=u},8002:e=>{"use strict";e.exports=Math.min},8068:e=>{"use strict";e.exports=SyntaxError},8075:(e,t,r)=>{"use strict";var n=r(453),o=r(487),i=o(n("String.prototype.indexOf"));e.exports=function(e,t){var r=n(e,!!t);return"function"==typeof r&&i(e,".prototype.")>-1?o(r):r}},8184:(e,t,r)=>{"use strict";var n,o=r(6556),i=r(9721)(/^\s*(?:function)?\*/),a=r(9092)(),s=r(3628),u=o("Object.prototype.toString"),c=o("Function.prototype.toString");e.exports=function(e){if("function"!=typeof e)return!1;if(i(c(e)))return!0;if(!a)return"[object GeneratorFunction]"===u(e);if(!s)return!1;if(void 0===n){var t=function(){if(!a)return!1;try{return Function("return function*() {}")()}catch(e){}}();n=!!t&&s(t)}return s(e)===n}},8287:(e,t,r)=>{"use strict";var n=r(6763);const o=r(7526),i=r(251),a="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=c,t.SlowBuffer=function(e){+e!=e&&(e=0);return c.alloc(+e)},t.INSPECT_MAX_BYTES=50;const s=2147483647;function u(e){if(e>s)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,c.prototype),t}function c(e,t,r){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return p(e)}return l(e,t,r)}function l(e,t,r){if("string"==typeof e)return function(e,t){"string"==typeof t&&""!==t||(t="utf8");if(!c.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const r=0|m(e,t);let n=u(r);const o=n.write(e,t);o!==r&&(n=n.slice(0,o));return n}(e,t);if(ArrayBuffer.isView(e))return function(e){if(Y(e,Uint8Array)){const t=new Uint8Array(e);return h(t.buffer,t.byteOffset,t.byteLength)}return d(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(Y(e,ArrayBuffer)||e&&Y(e.buffer,ArrayBuffer))return h(e,t,r);if("undefined"!=typeof SharedArrayBuffer&&(Y(e,SharedArrayBuffer)||e&&Y(e.buffer,SharedArrayBuffer)))return h(e,t,r);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const n=e.valueOf&&e.valueOf();if(null!=n&&n!==e)return c.from(n,t,r);const o=function(e){if(c.isBuffer(e)){const t=0|y(e.length),r=u(t);return 0===r.length||e.copy(r,0,0,t),r}if(void 0!==e.length)return"number"!=typeof e.length||Z(e.length)?u(0):d(e);if("Buffer"===e.type&&Array.isArray(e.data))return d(e.data)}(e);if(o)return o;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return c.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function f(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function p(e){return f(e),u(e<0?0:0|y(e))}function d(e){const t=e.length<0?0:0|y(e.length),r=u(t);for(let n=0;n<t;n+=1)r[n]=255&e[n];return r}function h(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),Object.setPrototypeOf(n,c.prototype),n}function y(e){if(e>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return 0|e}function m(e,t){if(c.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||Y(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const r=e.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let o=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return $(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return G(e).length;default:if(o)return n?-1:$(e).length;t=(""+t).toLowerCase(),o=!0}}function g(e,t,r){let n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return C(this,t,r);case"utf8":case"utf-8":return x(this,t,r);case"ascii":return B(this,t,r);case"latin1":case"binary":return I(this,t,r);case"base64":return O(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return R(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function v(e,t,r){const n=e[t];e[t]=e[r],e[r]=n}function b(e,t,r,n,o){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),Z(r=+r)&&(r=o?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(o)return-1;r=e.length-1}else if(r<0){if(!o)return-1;r=0}if("string"==typeof t&&(t=c.from(t,n)),c.isBuffer(t))return 0===t.length?-1:w(e,t,r,n,o);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):w(e,[t],r,n,o);throw new TypeError("val must be string, number or Buffer")}function w(e,t,r,n,o){let i,a=1,s=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,s/=2,u/=2,r/=2}function c(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(o){let n=-1;for(i=r;i<s;i++)if(c(e,i)===c(t,-1===n?0:i-n)){if(-1===n&&(n=i),i-n+1===u)return n*a}else-1!==n&&(i-=i-n),n=-1}else for(r+u>s&&(r=s-u),i=r;i>=0;i--){let r=!0;for(let n=0;n<u;n++)if(c(e,i+n)!==c(t,n)){r=!1;break}if(r)return i}return-1}function S(e,t,r,n){r=Number(r)||0;const o=e.length-r;n?(n=Number(n))>o&&(n=o):n=o;const i=t.length;let a;for(n>i/2&&(n=i/2),a=0;a<n;++a){const n=parseInt(t.substr(2*a,2),16);if(Z(n))return a;e[r+a]=n}return a}function E(e,t,r,n){return W($(t,e.length-r),e,r,n)}function k(e,t,r,n){return W(function(e){const t=[];for(let r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function A(e,t,r,n){return W(G(t),e,r,n)}function T(e,t,r,n){return W(function(e,t){let r,n,o;const i=[];for(let a=0;a<e.length&&!((t-=2)<0);++a)r=e.charCodeAt(a),n=r>>8,o=r%256,i.push(o),i.push(n);return i}(t,e.length-r),e,r,n)}function O(e,t,r){return 0===t&&r===e.length?o.fromByteArray(e):o.fromByteArray(e.slice(t,r))}function x(e,t,r){r=Math.min(e.length,r);const n=[];let o=t;for(;o<r;){const t=e[o];let i=null,a=t>239?4:t>223?3:t>191?2:1;if(o+a<=r){let r,n,s,u;switch(a){case 1:t<128&&(i=t);break;case 2:r=e[o+1],128==(192&r)&&(u=(31&t)<<6|63&r,u>127&&(i=u));break;case 3:r=e[o+1],n=e[o+2],128==(192&r)&&128==(192&n)&&(u=(15&t)<<12|(63&r)<<6|63&n,u>2047&&(u<55296||u>57343)&&(i=u));break;case 4:r=e[o+1],n=e[o+2],s=e[o+3],128==(192&r)&&128==(192&n)&&128==(192&s)&&(u=(15&t)<<18|(63&r)<<12|(63&n)<<6|63&s,u>65535&&u<1114112&&(i=u))}}null===i?(i=65533,a=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),o+=a}return function(e){const t=e.length;if(t<=P)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=P));return r}(n)}t.kMaxLength=s,c.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),c.TYPED_ARRAY_SUPPORT||void 0===n||"function"!=typeof n.error||n.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(c.prototype,"parent",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.buffer}}),Object.defineProperty(c.prototype,"offset",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.byteOffset}}),c.poolSize=8192,c.from=function(e,t,r){return l(e,t,r)},Object.setPrototypeOf(c.prototype,Uint8Array.prototype),Object.setPrototypeOf(c,Uint8Array),c.alloc=function(e,t,r){return function(e,t,r){return f(e),e<=0?u(e):void 0!==t?"string"==typeof r?u(e).fill(t,r):u(e).fill(t):u(e)}(e,t,r)},c.allocUnsafe=function(e){return p(e)},c.allocUnsafeSlow=function(e){return p(e)},c.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==c.prototype},c.compare=function(e,t){if(Y(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),Y(t,Uint8Array)&&(t=c.from(t,t.offset,t.byteLength)),!c.isBuffer(e)||!c.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let o=0,i=Math.min(r,n);o<i;++o)if(e[o]!==t[o]){r=e[o],n=t[o];break}return r<n?-1:n<r?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return c.alloc(0);let r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;const n=c.allocUnsafe(t);let o=0;for(r=0;r<e.length;++r){let t=e[r];if(Y(t,Uint8Array))o+t.length>n.length?(c.isBuffer(t)||(t=c.from(t)),t.copy(n,o)):Uint8Array.prototype.set.call(n,t,o);else{if(!c.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(n,o)}o+=t.length}return n},c.byteLength=m,c.prototype._isBuffer=!0,c.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)v(this,t,t+1);return this},c.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)v(this,t,t+3),v(this,t+1,t+2);return this},c.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)v(this,t,t+7),v(this,t+1,t+6),v(this,t+2,t+5),v(this,t+3,t+4);return this},c.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?x(this,0,e):g.apply(this,arguments)},c.prototype.toLocaleString=c.prototype.toString,c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===c.compare(this,e)},c.prototype.inspect=function(){let e="";const r=t.INSPECT_MAX_BYTES;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},a&&(c.prototype[a]=c.prototype.inspect),c.prototype.compare=function(e,t,r,n,o){if(Y(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),!c.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===o&&(o=this.length),t<0||r>e.length||n<0||o>this.length)throw new RangeError("out of range index");if(n>=o&&t>=r)return 0;if(n>=o)return-1;if(t>=r)return 1;if(this===e)return 0;let i=(o>>>=0)-(n>>>=0),a=(r>>>=0)-(t>>>=0);const s=Math.min(i,a),u=this.slice(n,o),l=e.slice(t,r);for(let e=0;e<s;++e)if(u[e]!==l[e]){i=u[e],a=l[e];break}return i<a?-1:a<i?1:0},c.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},c.prototype.indexOf=function(e,t,r){return b(this,e,t,r,!0)},c.prototype.lastIndexOf=function(e,t,r){return b(this,e,t,r,!1)},c.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}const o=this.length-t;if((void 0===r||r>o)&&(r=o),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let i=!1;for(;;)switch(n){case"hex":return S(this,e,t,r);case"utf8":case"utf-8":return E(this,e,t,r);case"ascii":case"latin1":case"binary":return k(this,e,t,r);case"base64":return A(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,t,r);default:if(i)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),i=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const P=4096;function B(e,t,r){let n="";r=Math.min(e.length,r);for(let o=t;o<r;++o)n+=String.fromCharCode(127&e[o]);return n}function I(e,t,r){let n="";r=Math.min(e.length,r);for(let o=t;o<r;++o)n+=String.fromCharCode(e[o]);return n}function C(e,t,r){const n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let o="";for(let n=t;n<r;++n)o+=J[e[n]];return o}function R(e,t,r){const n=e.slice(t,r);let o="";for(let e=0;e<n.length-1;e+=2)o+=String.fromCharCode(n[e]+256*n[e+1]);return o}function _(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function U(e,t,r,n,o,i){if(!c.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>o||t<i)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function N(e,t,r,n,o){K(t,n,o,e,r,7);let i=Number(t&BigInt(4294967295));e[r++]=i,i>>=8,e[r++]=i,i>>=8,e[r++]=i,i>>=8,e[r++]=i;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=a,a>>=8,e[r++]=a,a>>=8,e[r++]=a,a>>=8,e[r++]=a,r}function L(e,t,r,n,o){K(t,n,o,e,r,7);let i=Number(t&BigInt(4294967295));e[r+7]=i,i>>=8,e[r+6]=i,i>>=8,e[r+5]=i,i>>=8,e[r+4]=i;let a=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=a,a>>=8,e[r+2]=a,a>>=8,e[r+1]=a,a>>=8,e[r]=a,r+8}function F(e,t,r,n,o,i){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function j(e,t,r,n,o){return t=+t,r>>>=0,o||F(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function M(e,t,r,n,o){return t=+t,r>>>=0,o||F(e,0,r,8),i.write(e,t,r,n,52,8),r+8}c.prototype.slice=function(e,t){const r=this.length;(e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);const n=this.subarray(e,t);return Object.setPrototypeOf(n,c.prototype),n},c.prototype.readUintLE=c.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=this[e],o=1,i=0;for(;++i<t&&(o*=256);)n+=this[e+i]*o;return n},c.prototype.readUintBE=c.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=this[e+--t],o=1;for(;t>0&&(o*=256);)n+=this[e+--t]*o;return n},c.prototype.readUint8=c.prototype.readUInt8=function(e,t){return e>>>=0,t||_(e,1,this.length),this[e]},c.prototype.readUint16LE=c.prototype.readUInt16LE=function(e,t){return e>>>=0,t||_(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUint16BE=c.prototype.readUInt16BE=function(e,t){return e>>>=0,t||_(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUint32LE=c.prototype.readUInt32LE=function(e,t){return e>>>=0,t||_(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},c.prototype.readUint32BE=c.prototype.readUInt32BE=function(e,t){return e>>>=0,t||_(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readBigUInt64LE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,o=this[++e]+256*this[++e]+65536*this[++e]+r*2**24;return BigInt(n)+(BigInt(o)<<BigInt(32))}),c.prototype.readBigUInt64BE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=t*2**24+65536*this[++e]+256*this[++e]+this[++e],o=this[++e]*2**24+65536*this[++e]+256*this[++e]+r;return(BigInt(n)<<BigInt(32))+BigInt(o)}),c.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=this[e],o=1,i=0;for(;++i<t&&(o*=256);)n+=this[e+i]*o;return o*=128,n>=o&&(n-=Math.pow(2,8*t)),n},c.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||_(e,t,this.length);let n=t,o=1,i=this[e+--n];for(;n>0&&(o*=256);)i+=this[e+--n]*o;return o*=128,i>=o&&(i-=Math.pow(2,8*t)),i},c.prototype.readInt8=function(e,t){return e>>>=0,t||_(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},c.prototype.readInt16LE=function(e,t){e>>>=0,t||_(e,2,this.length);const r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt16BE=function(e,t){e>>>=0,t||_(e,2,this.length);const r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt32LE=function(e,t){return e>>>=0,t||_(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,t){return e>>>=0,t||_(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readBigInt64LE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=this[e+4]+256*this[e+5]+65536*this[e+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)}),c.prototype.readBigInt64BE=Q(function(e){H(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||z(e,this.length-8);const n=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(n)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+r)}),c.prototype.readFloatLE=function(e,t){return e>>>=0,t||_(e,4,this.length),i.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,t){return e>>>=0,t||_(e,4,this.length),i.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,t){return e>>>=0,t||_(e,8,this.length),i.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,t){return e>>>=0,t||_(e,8,this.length),i.read(this,e,!1,52,8)},c.prototype.writeUintLE=c.prototype.writeUIntLE=function(e,t,r,n){if(e=+e,t>>>=0,r>>>=0,!n){U(this,e,t,r,Math.pow(2,8*r)-1,0)}let o=1,i=0;for(this[t]=255&e;++i<r&&(o*=256);)this[t+i]=e/o&255;return t+r},c.prototype.writeUintBE=c.prototype.writeUIntBE=function(e,t,r,n){if(e=+e,t>>>=0,r>>>=0,!n){U(this,e,t,r,Math.pow(2,8*r)-1,0)}let o=r-1,i=1;for(this[t+o]=255&e;--o>=0&&(i*=256);)this[t+o]=e/i&255;return t+r},c.prototype.writeUint8=c.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,1,255,0),this[t]=255&e,t+1},c.prototype.writeUint16LE=c.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},c.prototype.writeUint16BE=c.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},c.prototype.writeUint32LE=c.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},c.prototype.writeUint32BE=c.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},c.prototype.writeBigUInt64LE=Q(function(e,t=0){return N(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeBigUInt64BE=Q(function(e,t=0){return L(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),c.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);U(this,e,t,r,n-1,-n)}let o=0,i=1,a=0;for(this[t]=255&e;++o<r&&(i*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/i|0)-a&255;return t+r},c.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);U(this,e,t,r,n-1,-n)}let o=r-1,i=1,a=0;for(this[t+o]=255&e;--o>=0&&(i*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/i|0)-a&255;return t+r},c.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},c.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},c.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},c.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},c.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||U(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},c.prototype.writeBigInt64LE=Q(function(e,t=0){return N(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),c.prototype.writeBigInt64BE=Q(function(e,t=0){return L(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),c.prototype.writeFloatLE=function(e,t,r){return j(this,e,t,!0,r)},c.prototype.writeFloatBE=function(e,t,r){return j(this,e,t,!1,r)},c.prototype.writeDoubleLE=function(e,t,r){return M(this,e,t,!0,r)},c.prototype.writeDoubleBE=function(e,t,r){return M(this,e,t,!1,r)},c.prototype.copy=function(e,t,r,n){if(!c.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);const o=n-r;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),o},c.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!c.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===e.length){const t=e.charCodeAt(0);("utf8"===n&&t<128||"latin1"===n)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;let o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(o=t;o<r;++o)this[o]=e;else{const i=c.isBuffer(e)?e:c.from(e,n),a=i.length;if(0===a)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(o=0;o<r-t;++o)this[o+t]=i[o%a]}return this};const D={};function V(e,t,r){D[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function q(e){let t="",r=e.length;const n="-"===e[0]?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function K(e,t,r,n,o,i){if(e>r||e<t){const n="bigint"==typeof t?"n":"";let o;throw o=i>3?0===t||t===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(i+1)}${n}`:`>= -(2${n} ** ${8*(i+1)-1}${n}) and < 2 ** ${8*(i+1)-1}${n}`:`>= ${t}${n} and <= ${r}${n}`,new D.ERR_OUT_OF_RANGE("value",o,e)}!function(e,t,r){H(t,"offset"),void 0!==e[t]&&void 0!==e[t+r]||z(t,e.length-(r+1))}(n,o,i)}function H(e,t){if("number"!=typeof e)throw new D.ERR_INVALID_ARG_TYPE(t,"number",e)}function z(e,t,r){if(Math.floor(e)!==e)throw H(e,r),new D.ERR_OUT_OF_RANGE(r||"offset","an integer",e);if(t<0)throw new D.ERR_BUFFER_OUT_OF_BOUNDS;throw new D.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}V("ERR_BUFFER_OUT_OF_BOUNDS",function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),V("ERR_INVALID_ARG_TYPE",function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`},TypeError),V("ERR_OUT_OF_RANGE",function(e,t,r){let n=`The value of "${e}" is out of range.`,o=r;return Number.isInteger(r)&&Math.abs(r)>2**32?o=q(String(r)):"bigint"==typeof r&&(o=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(o=q(o)),o+="n"),n+=` It must be ${t}. Received ${o}`,n},RangeError);const X=/[^+/0-9A-Za-z-_]/g;function $(e,t){let r;t=t||1/0;const n=e.length;let o=null;const i=[];for(let a=0;a<n;++a){if(r=e.charCodeAt(a),r>55295&&r<57344){if(!o){if(r>56319){(t-=3)>-1&&i.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&i.push(239,191,189);continue}o=r;continue}if(r<56320){(t-=3)>-1&&i.push(239,191,189),o=r;continue}r=65536+(o-55296<<10|r-56320)}else o&&(t-=3)>-1&&i.push(239,191,189);if(o=null,r<128){if((t-=1)<0)break;i.push(r)}else if(r<2048){if((t-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return i}function G(e){return o.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(X,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function W(e,t,r,n){let o;for(o=0;o<n&&!(o+r>=t.length||o>=e.length);++o)t[o+r]=e[o];return o}function Y(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function Z(e){return e!=e}const J=function(){const e="0123456789abcdef",t=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let o=0;o<16;++o)t[n+o]=e[r]+e[o]}return t}();function Q(e){return"undefined"==typeof BigInt?ee:e}function ee(){throw new Error("BigInt not supported")}},8403:(e,t,r)=>{"use strict";var n=r(1189),o=r(1333)(),i=r(6556),a=r(9612),s=i("Array.prototype.push"),u=i("Object.prototype.propertyIsEnumerable"),c=o?a.getOwnPropertySymbols:null;e.exports=function(e,t){if(null==e)throw new TypeError("target must be an object");var r=a(e);if(1===arguments.length)return r;for(var i=1;i<arguments.length;++i){var l=a(arguments[i]),f=n(l),p=o&&(a.getOwnPropertySymbols||c);if(p)for(var d=p(l),h=0;h<d.length;++h){var y=d[h];u(l,y)&&s(f,y)}for(var m=0;m<f.length;++m){var g=f[m];if(u(l,g)){var v=l[g];r[g]=v}}}return r}},8452:(e,t,r)=>{"use strict";var n=r(1189),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),i=Object.prototype.toString,a=Array.prototype.concat,s=r(41),u=r(592)(),c=function(e,t,r,n){if(t in e)if(!0===n){if(e[t]===r)return}else if("function"!=typeof(o=n)||"[object Function]"!==i.call(o)||!n())return;var o;u?s(e,t,r,!0):s(e,t,r)},l=function(e,t){var r=arguments.length>2?arguments[2]:{},i=n(t);o&&(i=a.call(i,Object.getOwnPropertySymbols(t)));for(var s=0;s<i.length;s+=1)c(e,i[s],t[i[s]],r[i[s]])};l.supportsDescriptors=!!u,e.exports=l},8648:e=>{"use strict";e.exports="undefined"!=typeof Reflect&&Reflect.getPrototypeOf||null},8875:(e,t,r)=>{"use strict";var n;if(!Object.keys){var o=Object.prototype.hasOwnProperty,i=Object.prototype.toString,a=r(1093),s=Object.prototype.propertyIsEnumerable,u=!s.call({toString:null},"toString"),c=s.call(function(){},"prototype"),l=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],f=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},d=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{f(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();n=function(e){var t=null!==e&&"object"==typeof e,r="[object Function]"===i.call(e),n=a(e),s=t&&"[object String]"===i.call(e),p=[];if(!t&&!r&&!n)throw new TypeError("Object.keys called on a non-object");var h=c&&r;if(s&&e.length>0&&!o.call(e,0))for(var y=0;y<e.length;++y)p.push(String(y));if(n&&e.length>0)for(var m=0;m<e.length;++m)p.push(String(m));else for(var g in e)h&&"prototype"===g||!o.call(e,g)||p.push(String(g));if(u)for(var v=function(e){if("undefined"==typeof window||!d)return f(e);try{return f(e)}catch(e){return!1}}(e),b=0;b<l.length;++b)v&&"constructor"===l[b]||!o.call(e,l[b])||p.push(l[b]);return p}}e.exports=n},8968:e=>{"use strict";e.exports=Math.floor},9032:(e,t,r)=>{"use strict";var n=r(7244),o=r(8184),i=r(5767),a=r(5680);function s(e){return e.call.bind(e)}var u="undefined"!=typeof BigInt,c="undefined"!=typeof Symbol,l=s(Object.prototype.toString),f=s(Number.prototype.valueOf),p=s(String.prototype.valueOf),d=s(Boolean.prototype.valueOf);if(u)var h=s(BigInt.prototype.valueOf);if(c)var y=s(Symbol.prototype.valueOf);function m(e,t){if("object"!=typeof e)return!1;try{return t(e),!0}catch(e){return!1}}function g(e){return"[object Map]"===l(e)}function v(e){return"[object Set]"===l(e)}function b(e){return"[object WeakMap]"===l(e)}function w(e){return"[object WeakSet]"===l(e)}function S(e){return"[object ArrayBuffer]"===l(e)}function E(e){return"undefined"!=typeof ArrayBuffer&&(S.working?S(e):e instanceof ArrayBuffer)}function k(e){return"[object DataView]"===l(e)}function A(e){return"undefined"!=typeof DataView&&(k.working?k(e):e instanceof DataView)}t.isArgumentsObject=n,t.isGeneratorFunction=o,t.isTypedArray=a,t.isPromise=function(e){return"undefined"!=typeof Promise&&e instanceof Promise||null!==e&&"object"==typeof e&&"function"==typeof e.then&&"function"==typeof e.catch},t.isArrayBufferView=function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):a(e)||A(e)},t.isUint8Array=function(e){return"Uint8Array"===i(e)},t.isUint8ClampedArray=function(e){return"Uint8ClampedArray"===i(e)},t.isUint16Array=function(e){return"Uint16Array"===i(e)},t.isUint32Array=function(e){return"Uint32Array"===i(e)},t.isInt8Array=function(e){return"Int8Array"===i(e)},t.isInt16Array=function(e){return"Int16Array"===i(e)},t.isInt32Array=function(e){return"Int32Array"===i(e)},t.isFloat32Array=function(e){return"Float32Array"===i(e)},t.isFloat64Array=function(e){return"Float64Array"===i(e)},t.isBigInt64Array=function(e){return"BigInt64Array"===i(e)},t.isBigUint64Array=function(e){return"BigUint64Array"===i(e)},g.working="undefined"!=typeof Map&&g(new Map),t.isMap=function(e){return"undefined"!=typeof Map&&(g.working?g(e):e instanceof Map)},v.working="undefined"!=typeof Set&&v(new Set),t.isSet=function(e){return"undefined"!=typeof Set&&(v.working?v(e):e instanceof Set)},b.working="undefined"!=typeof WeakMap&&b(new WeakMap),t.isWeakMap=function(e){return"undefined"!=typeof WeakMap&&(b.working?b(e):e instanceof WeakMap)},w.working="undefined"!=typeof WeakSet&&w(new WeakSet),t.isWeakSet=function(e){return w(e)},S.working="undefined"!=typeof ArrayBuffer&&S(new ArrayBuffer),t.isArrayBuffer=E,k.working="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView&&k(new DataView(new ArrayBuffer(1),0,1)),t.isDataView=A;var T="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function O(e){return"[object SharedArrayBuffer]"===l(e)}function x(e){return void 0!==T&&(void 0===O.working&&(O.working=O(new T)),O.working?O(e):e instanceof T)}function P(e){return m(e,f)}function B(e){return m(e,p)}function I(e){return m(e,d)}function C(e){return u&&m(e,h)}function R(e){return c&&m(e,y)}t.isSharedArrayBuffer=x,t.isAsyncFunction=function(e){return"[object AsyncFunction]"===l(e)},t.isMapIterator=function(e){return"[object Map Iterator]"===l(e)},t.isSetIterator=function(e){return"[object Set Iterator]"===l(e)},t.isGeneratorObject=function(e){return"[object Generator]"===l(e)},t.isWebAssemblyCompiledModule=function(e){return"[object WebAssembly.Module]"===l(e)},t.isNumberObject=P,t.isStringObject=B,t.isBooleanObject=I,t.isBigIntObject=C,t.isSymbolObject=R,t.isBoxedPrimitive=function(e){return P(e)||B(e)||I(e)||C(e)||R(e)},t.isAnyArrayBuffer=function(e){return"undefined"!=typeof Uint8Array&&(E(e)||x(e))},["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(e){Object.defineProperty(t,e,{enumerable:!1,value:function(){throw new Error(e+" is not supported in userland")}})})},9092:(e,t,r)=>{"use strict";var n=r(1333);e.exports=function(){return n()&&!!Symbol.toStringTag}},9133:(e,t,r)=>{"use strict";var n=r(8403);e.exports=function(){return Object.assign?function(){if(!Object.assign)return!1;for(var e="abcdefghijklmnopqrst",t=e.split(""),r={},n=0;n<t.length;++n)r[t[n]]=t[n];var o=Object.assign({},r),i="";for(var a in o)i+=a;return e!==i}()||function(){if(!Object.assign||!Object.preventExtensions)return!1;var e=Object.preventExtensions({1:2});try{Object.assign(e,"xy")}catch(t){return"y"===e[1]}return!1}()?n:Object.assign:n}},9209:(e,t,r)=>{"use strict";var n=r(6578),o="undefined"==typeof globalThis?r.g:globalThis;e.exports=function(){for(var e=[],t=0;t<n.length;t++)"function"==typeof o[n[t]]&&(e[e.length]=n[t]);return e}},9211:e=>{"use strict";var t=function(e){return e!=e};e.exports=function(e,r){return 0===e&&0===r?1/e==1/r:e===r||!(!t(e)||!t(r))}},9290:e=>{"use strict";e.exports=RangeError},9353:e=>{"use strict";var t=Object.prototype.toString,r=Math.max,n=function(e,t){for(var r=[],n=0;n<e.length;n+=1)r[n]=e[n];for(var o=0;o<t.length;o+=1)r[o+e.length]=t[o];return r};e.exports=function(e){var o=this;if("function"!=typeof o||"[object Function]"!==t.apply(o))throw new TypeError("Function.prototype.bind called on incompatible "+o);for(var i,a=function(e,t){for(var r=[],n=t||0,o=0;n<e.length;n+=1,o+=1)r[o]=e[n];return r}(arguments,1),s=r(0,o.length-a.length),u=[],c=0;c<s;c++)u[c]="$"+c;if(i=Function("binder","return function ("+function(e,t){for(var r="",n=0;n<e.length;n+=1)r+=e[n],n+1<e.length&&(r+=t);return r}(u,",")+"){ return binder.apply(this,arguments); }")(function(){if(this instanceof i){var t=o.apply(this,n(a,arguments));return Object(t)===t?t:this}return o.apply(e,n(a,arguments))}),o.prototype){var l=function(){};l.prototype=o.prototype,i.prototype=new l,l.prototype=null}return i}},9383:e=>{"use strict";e.exports=Error},9394:(e,t,r)=>{"use strict";var n=r(9211);e.exports=function(){return"function"==typeof Object.is?Object.is:n}},9538:e=>{"use strict";e.exports=ReferenceError},9597:(e,t,r)=>{"use strict";function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i(n.key),n)}}function i(e){var t=function(e,t){if("object"!==n(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var o=r.call(e,t||"default");if("object"!==n(o))return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"===n(t)?t:String(t)}function a(e,t){return a=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},a(e,t)}function s(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}();return function(){var r,o=u(e);if(t){var i=u(this).constructor;r=Reflect.construct(o,arguments,i)}else r=o.apply(this,arguments);return function(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}(this,r)}}function u(e){return u=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},u(e)}var c,l,f={};function p(e,t,r){r||(r=Error);var n=function(r){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&a(e,t)}(l,r);var n,i,u,c=s(l);function l(r,n,o){var i;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),i=c.call(this,function(e,r,n){return"string"==typeof t?t:t(e,r,n)}(r,n,o)),i.code=e,i}return n=l,i&&o(n.prototype,i),u&&o(n,u),Object.defineProperty(n,"prototype",{writable:!1}),n}(r);f[e]=n}function d(e,t){if(Array.isArray(e)){var r=e.length;return e=e.map(function(e){return String(e)}),r>2?"one of ".concat(t," ").concat(e.slice(0,r-1).join(", "),", or ")+e[r-1]:2===r?"one of ".concat(t," ").concat(e[0]," or ").concat(e[1]):"of ".concat(t," ").concat(e[0])}return"of ".concat(t," ").concat(String(e))}p("ERR_AMBIGUOUS_ARGUMENT",'The "%s" argument is ambiguous. %s',TypeError),p("ERR_INVALID_ARG_TYPE",function(e,t,o){var i,a,s,u;if(void 0===c&&(c=r(4148)),c("string"==typeof e,"'name' must be a string"),"string"==typeof t&&(a="not ",t.substr(!s||s<0?0:+s,a.length)===a)?(i="must not be",t=t.replace(/^not /,"")):i="must be",function(e,t,r){return(void 0===r||r>e.length)&&(r=e.length),e.substring(r-t.length,r)===t}(e," argument"))u="The ".concat(e," ").concat(i," ").concat(d(t,"type"));else{var l=function(e,t,r){return"number"!=typeof r&&(r=0),!(r+t.length>e.length)&&-1!==e.indexOf(t,r)}(e,".")?"property":"argument";u='The "'.concat(e,'" ').concat(l," ").concat(i," ").concat(d(t,"type"))}return u+=". Received type ".concat(n(o))},TypeError),p("ERR_INVALID_ARG_VALUE",function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"is invalid";void 0===l&&(l=r(537));var o=l.inspect(t);return o.length>128&&(o="".concat(o.slice(0,128),"...")),"The argument '".concat(e,"' ").concat(n,". Received ").concat(o)},TypeError,RangeError),p("ERR_INVALID_RETURN_VALUE",function(e,t,r){var o;return o=r&&r.constructor&&r.constructor.name?"instance of ".concat(r.constructor.name):"type ".concat(n(r)),"Expected ".concat(e,' to be returned from the "').concat(t,'"')+" function but got ".concat(o,".")},TypeError),p("ERR_MISSING_ARGS",function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];void 0===c&&(c=r(4148)),c(t.length>0,"At least one arg needs to be specified");var o="The ",i=t.length;switch(t=t.map(function(e){return'"'.concat(e,'"')}),i){case 1:o+="".concat(t[0]," argument");break;case 2:o+="".concat(t[0]," and ").concat(t[1]," arguments");break;default:o+=t.slice(0,i-1).join(", "),o+=", and ".concat(t[i-1]," arguments")}return"".concat(o," must be specified")},TypeError),e.exports.codes=f},9600:e=>{"use strict";var t,r,n=Function.prototype.toString,o="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof o&&"function"==typeof Object.defineProperty)try{t=Object.defineProperty({},"length",{get:function(){throw r}}),r={},o(function(){throw 42},null,t)}catch(e){e!==r&&(o=null)}else o=null;var i=/^\s*class\b/,a=function(e){try{var t=n.call(e);return i.test(t)}catch(e){return!1}},s=function(e){try{return!a(e)&&(n.call(e),!0)}catch(e){return!1}},u=Object.prototype.toString,c="function"==typeof Symbol&&!!Symbol.toStringTag,l=!(0 in[,]),f=function(){return!1};if("object"==typeof document){var p=document.all;u.call(p)===u.call(document.all)&&(f=function(e){if((l||!e)&&(void 0===e||"object"==typeof e))try{var t=u.call(e);return("[object HTMLAllCollection]"===t||"[object HTML document.all class]"===t||"[object HTMLCollection]"===t||"[object Object]"===t)&&null==e("")}catch(e){}return!1})}e.exports=o?function(e){if(f(e))return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;try{o(e,null,t)}catch(e){if(e!==r)return!1}return!a(e)&&s(e)}:function(e){if(f(e))return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;if(c)return s(e);if(a(e))return!1;var t=u.call(e);return!("[object Function]"!==t&&"[object GeneratorFunction]"!==t&&!/^\[object HTML/.test(t))&&s(e)}},9612:e=>{"use strict";e.exports=Object},9675:e=>{"use strict";e.exports=TypeError},9721:(e,t,r)=>{"use strict";var n=r(6556),o=r(4035),i=n("RegExp.prototype.exec"),a=r(9675);e.exports=function(e){if(!o(e))throw new a("`regex` must be a RegExp");return function(t){return null!==i(e,t)}}},9957:(e,t,r)=>{"use strict";var n=Function.prototype.call,o=Object.prototype.hasOwnProperty,i=r(6743);e.exports=i.call(n,o)}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={id:n,loaded:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.loaded=!0,i.exports}return r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.hmd=e=>((e=Object.create(e)).children||(e.children=[]),Object.defineProperty(e,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+e.id)}}),e),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(448)})());

/***/ }),

/***/ 976:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Cu: () => (/* reexport */ AccountRequiresMemoError),
  v7: () => (/* reexport */ BadRequestError),
  nS: () => (/* reexport */ BadResponseError),
  Dr: () => (/* reexport */ NetworkError),
  m_: () => (/* reexport */ NotFoundError)
});

;// ./src/errors/network.ts
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var NetworkError = function (_Error) {
  function NetworkError(message, response) {
    var _this;
    _classCallCheck(this, NetworkError);
    var trueProto = (this instanceof NetworkError ? this.constructor : void 0).prototype;
    _this = _callSuper(this, NetworkError, [message]);
    _this.__proto__ = trueProto;
    _this.constructor = NetworkError;
    _this.response = response;
    return _this;
  }
  _inherits(NetworkError, _Error);
  return _createClass(NetworkError, [{
    key: "getResponse",
    value: function getResponse() {
      return this.response;
    }
  }]);
}(_wrapNativeSuper(Error));
;// ./src/errors/not_found.ts
function not_found_typeof(o) { "@babel/helpers - typeof"; return not_found_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, not_found_typeof(o); }
function not_found_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, not_found_toPropertyKey(o.key), o); } }
function not_found_createClass(e, r, t) { return r && not_found_defineProperties(e.prototype, r), t && not_found_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function not_found_toPropertyKey(t) { var i = not_found_toPrimitive(t, "string"); return "symbol" == not_found_typeof(i) ? i : i + ""; }
function not_found_toPrimitive(t, r) { if ("object" != not_found_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != not_found_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function not_found_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function not_found_callSuper(t, o, e) { return o = not_found_getPrototypeOf(o), not_found_possibleConstructorReturn(t, not_found_isNativeReflectConstruct() ? Reflect.construct(o, e || [], not_found_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function not_found_possibleConstructorReturn(t, e) { if (e && ("object" == not_found_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return not_found_assertThisInitialized(t); }
function not_found_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function not_found_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (not_found_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function not_found_getPrototypeOf(t) { return not_found_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, not_found_getPrototypeOf(t); }
function not_found_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && not_found_setPrototypeOf(t, e); }
function not_found_setPrototypeOf(t, e) { return not_found_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, not_found_setPrototypeOf(t, e); }

var NotFoundError = function (_NetworkError) {
  function NotFoundError(message, response) {
    var _this;
    not_found_classCallCheck(this, NotFoundError);
    var trueProto = (this instanceof NotFoundError ? this.constructor : void 0).prototype;
    _this = not_found_callSuper(this, NotFoundError, [message, response]);
    _this.__proto__ = trueProto;
    _this.constructor = NotFoundError;
    _this.name = "NotFoundError";
    return _this;
  }
  not_found_inherits(NotFoundError, _NetworkError);
  return not_found_createClass(NotFoundError);
}(NetworkError);
;// ./src/errors/bad_request.ts
function bad_request_typeof(o) { "@babel/helpers - typeof"; return bad_request_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, bad_request_typeof(o); }
function bad_request_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, bad_request_toPropertyKey(o.key), o); } }
function bad_request_createClass(e, r, t) { return r && bad_request_defineProperties(e.prototype, r), t && bad_request_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function bad_request_toPropertyKey(t) { var i = bad_request_toPrimitive(t, "string"); return "symbol" == bad_request_typeof(i) ? i : i + ""; }
function bad_request_toPrimitive(t, r) { if ("object" != bad_request_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != bad_request_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function bad_request_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function bad_request_callSuper(t, o, e) { return o = bad_request_getPrototypeOf(o), bad_request_possibleConstructorReturn(t, bad_request_isNativeReflectConstruct() ? Reflect.construct(o, e || [], bad_request_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function bad_request_possibleConstructorReturn(t, e) { if (e && ("object" == bad_request_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return bad_request_assertThisInitialized(t); }
function bad_request_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function bad_request_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (bad_request_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function bad_request_getPrototypeOf(t) { return bad_request_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, bad_request_getPrototypeOf(t); }
function bad_request_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && bad_request_setPrototypeOf(t, e); }
function bad_request_setPrototypeOf(t, e) { return bad_request_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, bad_request_setPrototypeOf(t, e); }

var BadRequestError = function (_NetworkError) {
  function BadRequestError(message, response) {
    var _this;
    bad_request_classCallCheck(this, BadRequestError);
    var trueProto = (this instanceof BadRequestError ? this.constructor : void 0).prototype;
    _this = bad_request_callSuper(this, BadRequestError, [message, response]);
    _this.__proto__ = trueProto;
    _this.constructor = BadRequestError;
    _this.name = "BadRequestError";
    return _this;
  }
  bad_request_inherits(BadRequestError, _NetworkError);
  return bad_request_createClass(BadRequestError);
}(NetworkError);
;// ./src/errors/bad_response.ts
function bad_response_typeof(o) { "@babel/helpers - typeof"; return bad_response_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, bad_response_typeof(o); }
function bad_response_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, bad_response_toPropertyKey(o.key), o); } }
function bad_response_createClass(e, r, t) { return r && bad_response_defineProperties(e.prototype, r), t && bad_response_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function bad_response_toPropertyKey(t) { var i = bad_response_toPrimitive(t, "string"); return "symbol" == bad_response_typeof(i) ? i : i + ""; }
function bad_response_toPrimitive(t, r) { if ("object" != bad_response_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != bad_response_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function bad_response_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function bad_response_callSuper(t, o, e) { return o = bad_response_getPrototypeOf(o), bad_response_possibleConstructorReturn(t, bad_response_isNativeReflectConstruct() ? Reflect.construct(o, e || [], bad_response_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function bad_response_possibleConstructorReturn(t, e) { if (e && ("object" == bad_response_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return bad_response_assertThisInitialized(t); }
function bad_response_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function bad_response_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (bad_response_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function bad_response_getPrototypeOf(t) { return bad_response_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, bad_response_getPrototypeOf(t); }
function bad_response_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && bad_response_setPrototypeOf(t, e); }
function bad_response_setPrototypeOf(t, e) { return bad_response_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, bad_response_setPrototypeOf(t, e); }

var BadResponseError = function (_NetworkError) {
  function BadResponseError(message, response) {
    var _this;
    bad_response_classCallCheck(this, BadResponseError);
    var trueProto = (this instanceof BadResponseError ? this.constructor : void 0).prototype;
    _this = bad_response_callSuper(this, BadResponseError, [message, response]);
    _this.__proto__ = trueProto;
    _this.constructor = BadResponseError;
    _this.name = "BadResponseError";
    return _this;
  }
  bad_response_inherits(BadResponseError, _NetworkError);
  return bad_response_createClass(BadResponseError);
}(NetworkError);
;// ./src/errors/account_requires_memo.ts
function account_requires_memo_typeof(o) { "@babel/helpers - typeof"; return account_requires_memo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, account_requires_memo_typeof(o); }
function account_requires_memo_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, account_requires_memo_toPropertyKey(o.key), o); } }
function account_requires_memo_createClass(e, r, t) { return r && account_requires_memo_defineProperties(e.prototype, r), t && account_requires_memo_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function account_requires_memo_toPropertyKey(t) { var i = account_requires_memo_toPrimitive(t, "string"); return "symbol" == account_requires_memo_typeof(i) ? i : i + ""; }
function account_requires_memo_toPrimitive(t, r) { if ("object" != account_requires_memo_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != account_requires_memo_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function account_requires_memo_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function account_requires_memo_callSuper(t, o, e) { return o = account_requires_memo_getPrototypeOf(o), account_requires_memo_possibleConstructorReturn(t, account_requires_memo_isNativeReflectConstruct() ? Reflect.construct(o, e || [], account_requires_memo_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function account_requires_memo_possibleConstructorReturn(t, e) { if (e && ("object" == account_requires_memo_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return account_requires_memo_assertThisInitialized(t); }
function account_requires_memo_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function account_requires_memo_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && account_requires_memo_setPrototypeOf(t, e); }
function account_requires_memo_wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return account_requires_memo_wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !account_requires_memo_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return account_requires_memo_construct(t, arguments, account_requires_memo_getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), account_requires_memo_setPrototypeOf(Wrapper, t); }, account_requires_memo_wrapNativeSuper(t); }
function account_requires_memo_construct(t, e, r) { if (account_requires_memo_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && account_requires_memo_setPrototypeOf(p, r.prototype), p; }
function account_requires_memo_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (account_requires_memo_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function account_requires_memo_isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function account_requires_memo_setPrototypeOf(t, e) { return account_requires_memo_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, account_requires_memo_setPrototypeOf(t, e); }
function account_requires_memo_getPrototypeOf(t) { return account_requires_memo_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, account_requires_memo_getPrototypeOf(t); }
var AccountRequiresMemoError = function (_Error) {
  function AccountRequiresMemoError(message, accountId, operationIndex) {
    var _this;
    account_requires_memo_classCallCheck(this, AccountRequiresMemoError);
    var trueProto = (this instanceof AccountRequiresMemoError ? this.constructor : void 0).prototype;
    _this = account_requires_memo_callSuper(this, AccountRequiresMemoError, [message]);
    _this.__proto__ = trueProto;
    _this.constructor = AccountRequiresMemoError;
    _this.name = "AccountRequiresMemoError";
    _this.accountId = accountId;
    _this.operationIndex = operationIndex;
    return _this;
  }
  account_requires_memo_inherits(AccountRequiresMemoError, _Error);
  return account_requires_memo_createClass(AccountRequiresMemoError);
}(account_requires_memo_wrapNativeSuper(Error));
;// ./src/errors/index.ts






/***/ }),

/***/ 983:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  vt: () => (/* binding */ create),
  ok: () => (/* binding */ httpClient)
});

// UNUSED EXPORTS: CancelToken

;// ./src/http-client/types.ts
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var CancelToken = function () {
  function CancelToken(executor) {
    var _this = this;
    _classCallCheck(this, CancelToken);
    var resolvePromise;
    this.promise = new Promise(function (resolve) {
      resolvePromise = resolve;
    });
    executor(function (reason) {
      _this.reason = reason;
      resolvePromise();
    });
  }
  return _createClass(CancelToken, [{
    key: "throwIfRequested",
    value: function throwIfRequested() {
      if (this.reason) {
        throw new Error(this.reason);
      }
    }
  }]);
}();
;// ./src/http-client/index.ts
var httpClient;
var create;
if (true) {
  var axiosModule = __webpack_require__(121);
  httpClient = axiosModule.axiosClient;
  create = axiosModule.create;
} else // removed by dead control flow
{ var fetchModule; }



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(924);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});