"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.decodeSendAck = void 0;
const constants_1 = require("./constants");
const crc32_1 = require("./crypto/crc32");
const utils_1 = require("./utils");
const createChannelResponse = ({ payload }, protobufDecoder) => {
    const nonce = payload.subarray(0, 8);
    const channel = payload.subarray(8, 10);
    const props = payload.subarray(10, payload.length - constants_1.CRC_LENGTH);
    const properties = protobufDecoder('ThpDeviceProperties', props).message;
    return {
        type: 'ThpCreateChannelResponse',
        message: {
            nonce,
            channel,
            properties,
        },
    };
};
const decodeReadAck = () => ({
    type: 'ThpAck',
    message: {},
});
const decodeThpError = (payload) => {
    const [errorType] = payload;
    const error = (() => {
        switch (errorType) {
            case 0x01:
                return 'ThpTransportBusy';
            case 0x02:
                return 'ThpUnallocatedChannel';
            case 0x03:
                return 'ThpDecryptionFailed';
            case 0x04:
                return 'ThpInvalidData';
            case 0x05:
                return 'ThpDeviceLocked';
            default:
                return 'ThpUnknownError';
        }
    })();
    const message = {
        code: error,
        message: error ?? `Unknown ThpError ${errorType}`,
    };
    return {
        type: 'ThpError',
        message,
    };
};
const validateCrc = (decodedMessage) => {
    const payloadLen = decodedMessage.length - constants_1.CRC_LENGTH;
    const length = Buffer.alloc(2);
    length.writeUInt16BE(decodedMessage.length);
    const expectedCrc = (0, crc32_1.crc32)(Buffer.concat([
        decodedMessage.header,
        length,
        decodedMessage.payload.subarray(0, payloadLen),
    ]));
    const crc = decodedMessage.payload.subarray(payloadLen, decodedMessage.length);
    if (expectedCrc.compare(crc) !== 0) {
        throw new Error(`Invalid CRC. expected: ${expectedCrc.toString('hex')} received: ${crc.toString('hex')}`);
    }
};
const decodeSendAck = (decodedMessage) => {
    validateCrc(decodedMessage);
    const header = (0, utils_1.readThpHeader)(decodedMessage.header);
    const magic = (0, utils_1.clearControlBit)(header.magic);
    if (magic === constants_1.THP_ERROR_HEADER_BYTE) {
        return decodeThpError(decodedMessage.payload);
    }
    if (magic === constants_1.THP_READ_ACK_HEADER_BYTE) {
        return decodeReadAck();
    }
    throw new Error('Unexpected send response: ' + magic);
};
exports.decodeSendAck = decodeSendAck;
const decode = (decodedMessage, protobufDecoder, thpState) => {
    if (!thpState) {
        throw new Error('Cannot decode THP message without ThpState');
    }
    validateCrc(decodedMessage);
    const header = (0, utils_1.readThpHeader)(decodedMessage.header);
    const message = {
        ...decodedMessage,
        ...header,
        thpState,
    };
    const magic = (0, utils_1.clearControlBit)(message.magic);
    if (magic === constants_1.THP_ERROR_HEADER_BYTE) {
        return decodeThpError(message.payload);
    }
    if (magic === constants_1.THP_READ_ACK_HEADER_BYTE) {
        return decodeReadAck();
    }
    if (magic === constants_1.THP_CREATE_CHANNEL_RESPONSE) {
        return createChannelResponse(message, protobufDecoder);
    }
    throw new Error('Unknown message type: ' + magic);
};
exports.decode = decode;
//# sourceMappingURL=decode.js.map