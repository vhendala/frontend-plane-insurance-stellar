"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = exports.encodeAck = exports.encodeProtobufMessage = exports.encodePayload = void 0;
const constants_1 = require("./constants");
const crc32_1 = require("./crypto/crc32");
const utils_1 = require("./utils");
const getBytesFromField = (data, fieldName) => {
    const value = data[fieldName];
    if (typeof value === 'string') {
        return Buffer.from(value, 'hex');
    }
    if (Buffer.isBuffer(value)) {
        return value;
    }
};
const createChannelRequestPayload = (data) => {
    const nonce = getBytesFromField(data, 'nonce');
    if (!nonce) {
        throw new Error('Missing nonce field');
    }
    return nonce;
};
const encodePayload = (name, data, _thpState) => {
    if (name === 'ThpCreateChannelRequest') {
        return createChannelRequestPayload(data);
    }
    return Buffer.alloc(0);
};
exports.encodePayload = encodePayload;
const createChannelRequest = (data, channel) => {
    const length = Buffer.alloc(2);
    length.writeUInt16BE(data.length + constants_1.CRC_LENGTH);
    const magic = Buffer.from([constants_1.THP_CREATE_CHANNEL_REQUEST]);
    const message = Buffer.concat([magic, channel, length, data]);
    const crc = (0, crc32_1.crc32)(message);
    return Buffer.concat([message, crc]);
};
const encodeThpMessage = (messageType, data, channel, _thpState) => {
    if (messageType === 'ThpCreateChannelRequest') {
        return createChannelRequest(data, channel);
    }
    throw new Error(`Unknown ThpMessage type ${messageType}`);
};
const encodeProtobufMessage = (messageType, data, channel, thpState) => {
    if (!thpState) {
        throw new Error('ThpState missing');
    }
    const length = Buffer.alloc(2);
    length.writeUInt16BE(1 + 2 + data.length + constants_1.TAG_LENGTH + constants_1.CRC_LENGTH);
    const magic = (0, utils_1.addSequenceBit)(constants_1.THP_CONTROL_BYTE_ENCRYPTED, thpState.sendBit);
    const header = Buffer.concat([magic, channel]);
    const messageTypeBytes = Buffer.alloc(2);
    messageTypeBytes.writeUInt16BE(messageType);
    const cipheredMessage = Buffer.concat([Buffer.alloc(0), messageTypeBytes, data]);
    const message = Buffer.concat([header, length, cipheredMessage]);
    const crc = (0, crc32_1.crc32)(message);
    return Buffer.concat([message, crc]);
};
exports.encodeProtobufMessage = encodeProtobufMessage;
const encodeReadAck = (channel, syncBit) => {
    const length = Buffer.alloc(2);
    length.writeUInt16BE(constants_1.CRC_LENGTH);
    const magic = (0, utils_1.addAckBit)(constants_1.THP_READ_ACK_HEADER_BYTE, syncBit);
    const message = Buffer.concat([magic, channel, length]);
    const crc = (0, crc32_1.crc32)(message);
    return Buffer.concat([message, crc]);
};
const encodeAck = (bytesOrState) => {
    if (Buffer.isBuffer(bytesOrState)) {
        const magic = bytesOrState.readUInt8();
        const recvBit = (0, utils_1.getControlBit)(magic);
        const channel = bytesOrState.subarray(1, 3);
        return encodeReadAck(channel, recvBit);
    }
    const { channel, recvBit } = bytesOrState;
    return encodeReadAck(channel, recvBit);
};
exports.encodeAck = encodeAck;
const encode = (options) => {
    if (!options.thpState) {
        throw new Error('ThpState missing');
    }
    const channel = options.thpState.channel || constants_1.THP_DEFAULT_CHANNEL;
    const { messageName, data, protobufEncoder, thpState } = options;
    let result;
    if ((0, utils_1.isThpMessageName)(messageName)) {
        const payload = (0, exports.encodePayload)(messageName, data, thpState);
        result = encodeThpMessage(messageName, payload, channel, options.thpState);
    }
    else {
        const { messageType, message } = protobufEncoder(messageName, data);
        result = (0, exports.encodeProtobufMessage)(messageType, message, channel, thpState);
    }
    return result;
};
exports.encode = encode;
//# sourceMappingURL=encode.js.map